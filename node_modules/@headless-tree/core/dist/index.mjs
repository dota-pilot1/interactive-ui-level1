var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/utils.ts
var memo = (deps, fn) => {
  let value;
  let oldDeps = null;
  return (...a) => {
    const newDeps = deps(...a);
    if (!value) {
      value = fn(...newDeps);
      oldDeps = newDeps;
      return value;
    }
    const match = oldDeps && oldDeps.length === newDeps.length && !oldDeps.some((dep, i) => dep !== newDeps[i]);
    if (match) {
      return value;
    }
    value = fn(...newDeps);
    oldDeps = newDeps;
    return value;
  };
};
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function makeStateUpdater(key, instance) {
  return (updater) => {
    instance.setState((old) => {
      return __spreadProps(__spreadValues({}, old), {
        [key]: functionalUpdate(updater, old[key])
      });
    });
  };
}
var poll = (fn, interval = 100, timeout = 1e3) => new Promise((resolve) => {
  let clear;
  const i = setInterval(() => {
    if (fn()) {
      resolve();
      clearInterval(i);
      clearTimeout(clear);
    }
  }, interval);
  clear = setTimeout(() => {
    clearInterval(i);
  }, timeout);
});

// src/utilities/errors.ts
var prefix = "Headless Tree: ";
var throwError = (message) => Error(prefix + message);
var logWarning = (message) => console.warn(prefix + message);

// src/features/tree/feature.ts
var treeFeature = {
  key: "tree",
  getInitialState: (initialState) => __spreadValues({
    expandedItems: [],
    focusedItem: null
  }, initialState),
  getDefaultConfig: (defaultConfig, tree) => __spreadValues({
    setExpandedItems: makeStateUpdater("expandedItems", tree),
    setFocusedItem: makeStateUpdater("focusedItem", tree)
  }, defaultConfig),
  stateHandlerNames: {
    expandedItems: "setExpandedItems",
    focusedItem: "setFocusedItem"
  },
  treeInstance: {
    getItemsMeta: ({ tree }) => {
      const { rootItemId } = tree.getConfig();
      const { expandedItems } = tree.getState();
      const flatItems = [];
      const expandedItemsSet = new Set(expandedItems);
      const recursiveAdd = (itemId, path, level, setSize, posInSet) => {
        var _a;
        if (path.includes(itemId)) {
          logWarning(`Circular reference for ${path.join(".")}`);
          return;
        }
        flatItems.push({
          itemId,
          level,
          index: flatItems.length,
          parentId: path.at(-1),
          setSize,
          posInSet
        });
        if (expandedItemsSet.has(itemId)) {
          const children2 = (_a = tree.retrieveChildrenIds(itemId)) != null ? _a : [];
          let i2 = 0;
          for (const childId of children2) {
            recursiveAdd(
              childId,
              path.concat(itemId),
              level + 1,
              children2.length,
              i2++
            );
          }
        }
      };
      const children = tree.retrieveChildrenIds(rootItemId);
      let i = 0;
      for (const itemId of children) {
        recursiveAdd(itemId, [rootItemId], 0, children.length, i++);
      }
      return flatItems;
    },
    getFocusedItem: ({ tree }) => {
      var _a;
      const focusedItemId = tree.getState().focusedItem;
      return (_a = focusedItemId !== null ? tree.getItemInstance(focusedItemId) : null) != null ? _a : tree.getItems()[0];
    },
    getRootItem: ({ tree }) => {
      const { rootItemId } = tree.getConfig();
      return tree.getItemInstance(rootItemId);
    },
    focusNextItem: ({ tree }) => {
      var _a;
      const focused = tree.getFocusedItem().getItemMeta();
      if (!focused) return;
      const nextIndex = Math.min(focused.index + 1, tree.getItems().length - 1);
      (_a = tree.getItems()[nextIndex]) == null ? void 0 : _a.setFocused();
    },
    focusPreviousItem: ({ tree }) => {
      var _a;
      const focused = tree.getFocusedItem().getItemMeta();
      if (!focused) return;
      const nextIndex = Math.max(focused.index - 1, 0);
      (_a = tree.getItems()[nextIndex]) == null ? void 0 : _a.setFocused();
    },
    updateDomFocus: ({ tree }) => {
      setTimeout(() => __async(null, null, function* () {
        var _a, _b;
        const focusedItem = tree.getFocusedItem();
        (_b = (_a = tree.getConfig()).scrollToItem) == null ? void 0 : _b.call(_a, focusedItem);
        yield poll(() => focusedItem.getElement() !== null, 20);
        const focusedElement = focusedItem.getElement();
        if (!focusedElement) return;
        focusedElement.focus();
      }));
    },
    getContainerProps: ({ prev, tree }, treeLabel) => __spreadProps(__spreadValues({}, prev == null ? void 0 : prev()), {
      role: "tree",
      "aria-label": treeLabel != null ? treeLabel : "",
      ref: tree.registerElement
    }),
    // relevant for hotkeys of this feature
    isSearchOpen: () => false
  },
  itemInstance: {
    scrollTo: (_0, _1) => __async(null, [_0, _1], function* ({ tree, item }, scrollIntoViewArg) {
      var _a, _b, _c;
      (_b = (_a = tree.getConfig()).scrollToItem) == null ? void 0 : _b.call(_a, item);
      yield poll(() => item.getElement() !== null, 20);
      (_c = item.getElement()) == null ? void 0 : _c.scrollIntoView(scrollIntoViewArg);
    }),
    getId: ({ itemId }) => itemId,
    getKey: ({ itemId }) => itemId,
    // TODO apply to all stories to use
    getProps: ({ item, prev }) => {
      const itemMeta = item.getItemMeta();
      return __spreadProps(__spreadValues({}, prev == null ? void 0 : prev()), {
        ref: item.registerElement,
        role: "treeitem",
        "aria-setsize": itemMeta.setSize,
        "aria-posinset": itemMeta.posInSet + 1,
        "aria-selected": "false",
        "aria-label": item.getItemName(),
        "aria-level": itemMeta.level + 1,
        tabIndex: item.isFocused() ? 0 : -1,
        onClick: (e) => {
          item.setFocused();
          item.primaryAction();
          if (e.ctrlKey || e.shiftKey || e.metaKey) {
            return;
          }
          if (!item.isFolder()) {
            return;
          }
          if (item.isExpanded()) {
            item.collapse();
          } else {
            item.expand();
          }
        }
      });
    },
    expand: ({ tree, item, itemId }) => {
      var _a;
      if (!item.isFolder()) {
        return;
      }
      if ((_a = tree.getState().loadingItemChildrens) == null ? void 0 : _a.includes(itemId)) {
        return;
      }
      tree.applySubStateUpdate("expandedItems", (expandedItems) => [
        ...expandedItems,
        itemId
      ]);
      tree.rebuildTree();
    },
    collapse: ({ tree, item, itemId }) => {
      if (!item.isFolder()) {
        return;
      }
      tree.applySubStateUpdate(
        "expandedItems",
        (expandedItems) => expandedItems.filter((id) => id !== itemId)
      );
      tree.rebuildTree();
    },
    getItemData: ({ tree, itemId }) => tree.retrieveItemData(itemId),
    equals: ({ item }, other) => item.getId() === (other == null ? void 0 : other.getId()),
    isExpanded: ({ tree, itemId }) => tree.getState().expandedItems.includes(itemId),
    isDescendentOf: ({ item }, parentId) => {
      const parent = item.getParent();
      return Boolean(
        (parent == null ? void 0 : parent.getId()) === parentId || (parent == null ? void 0 : parent.isDescendentOf(parentId))
      );
    },
    isFocused: ({ tree, item, itemId }) => tree.getState().focusedItem === itemId || tree.getState().focusedItem === null && item.getItemMeta().index === 0,
    isFolder: ({ tree, item }) => item.getItemMeta().level === -1 || tree.getConfig().isItemFolder(item),
    getItemName: ({ tree, item }) => {
      const config = tree.getConfig();
      return config.getItemName(item);
    },
    setFocused: ({ tree, itemId }) => {
      tree.applySubStateUpdate("focusedItem", itemId);
    },
    primaryAction: ({ tree, item }) => {
      var _a, _b;
      return (_b = (_a = tree.getConfig()).onPrimaryAction) == null ? void 0 : _b.call(_a, item);
    },
    getParent: ({ tree, item }) => item.getItemMeta().parentId ? tree.getItemInstance(item.getItemMeta().parentId) : void 0,
    getIndexInParent: ({ item }) => item.getItemMeta().posInSet,
    getChildren: ({ tree, itemId }) => tree.retrieveChildrenIds(itemId).map((id) => tree.getItemInstance(id)),
    getTree: ({ tree }) => tree,
    getItemAbove: ({ tree, item }) => tree.getItems()[item.getItemMeta().index - 1],
    getItemBelow: ({ tree, item }) => tree.getItems()[item.getItemMeta().index + 1]
  },
  hotkeys: {
    focusNextItem: {
      hotkey: "ArrowDown",
      canRepeat: true,
      preventDefault: true,
      isEnabled: (tree) => {
        var _a, _b;
        return !((_b = (_a = tree.isSearchOpen) == null ? void 0 : _a.call(tree)) != null ? _b : false) && !tree.getState().dnd;
      },
      // TODO what happens when the feature doesnt exist? proxy method still claims to exist
      handler: (e, tree) => {
        tree.focusNextItem();
        tree.updateDomFocus();
      }
    },
    focusPreviousItem: {
      hotkey: "ArrowUp",
      canRepeat: true,
      preventDefault: true,
      isEnabled: (tree) => {
        var _a, _b;
        return !((_b = (_a = tree.isSearchOpen) == null ? void 0 : _a.call(tree)) != null ? _b : false) && !tree.getState().dnd;
      },
      handler: (e, tree) => {
        tree.focusPreviousItem();
        tree.updateDomFocus();
      }
    },
    expandOrDown: {
      hotkey: "ArrowRight",
      canRepeat: true,
      handler: (e, tree) => {
        const item = tree.getFocusedItem();
        if (item.isExpanded() || !item.isFolder()) {
          tree.focusNextItem();
          tree.updateDomFocus();
        } else {
          item.expand();
        }
      }
    },
    collapseOrUp: {
      hotkey: "ArrowLeft",
      canRepeat: true,
      handler: (e, tree) => {
        var _a;
        const item = tree.getFocusedItem();
        if ((!item.isExpanded() || !item.isFolder()) && item.getItemMeta().level !== 0) {
          (_a = item.getParent()) == null ? void 0 : _a.setFocused();
          tree.updateDomFocus();
        } else {
          item.collapse();
        }
      }
    },
    focusFirstItem: {
      hotkey: "Home",
      handler: (e, tree) => {
        var _a;
        (_a = tree.getItems()[0]) == null ? void 0 : _a.setFocused();
        tree.updateDomFocus();
      }
    },
    focusLastItem: {
      hotkey: "End",
      handler: (e, tree) => {
        var _a;
        (_a = tree.getItems()[tree.getItems().length - 1]) == null ? void 0 : _a.setFocused();
        tree.updateDomFocus();
      }
    }
  }
};

// src/core/build-static-instance.ts
var buildStaticInstance = (features, instanceType, buildOpts) => {
  const instance = {};
  const finalize = () => {
    const opts = buildOpts(instance);
    featureLoop: for (let i = 0; i < features.length; i++) {
      const definition = features[i][instanceType];
      if (!definition) continue featureLoop;
      methodLoop: for (const [key, method] of Object.entries(definition)) {
        if (!method) continue methodLoop;
        const prev = instance[key];
        instance[key] = (...args) => {
          return method(__spreadProps(__spreadValues({}, opts), { prev }), ...args);
        };
      }
    }
  };
  return [instance, finalize];
};

// src/core/create-tree.ts
var verifyFeatures = (features) => {
  var _a;
  const loadedFeatures = features == null ? void 0 : features.map((feature) => feature.key);
  for (const feature of features != null ? features : []) {
    const missingDependency = (_a = feature.deps) == null ? void 0 : _a.find(
      (dep) => !(loadedFeatures == null ? void 0 : loadedFeatures.includes(dep))
    );
    if (missingDependency) {
      throw throwError(`${feature.key} needs ${missingDependency}`);
    }
  }
};
var exhaustiveSort = (arr, compareFn) => {
  const n = arr.length;
  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      if (compareFn(arr[j], arr[i]) < 0) {
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }
  }
  return arr;
};
var compareFeatures = (originalOrder) => (feature1, feature2) => {
  var _a, _b;
  if (feature2.key && ((_a = feature1.overwrites) == null ? void 0 : _a.includes(feature2.key))) {
    return 1;
  }
  if (feature1.key && ((_b = feature2.overwrites) == null ? void 0 : _b.includes(feature1.key))) {
    return -1;
  }
  return originalOrder.indexOf(feature1) - originalOrder.indexOf(feature2);
};
var sortFeatures = (features = []) => exhaustiveSort(features, compareFeatures(features));
var createTree = (initialConfig) => {
  var _a, _b, _c, _d;
  const buildInstance = (_a = initialConfig.instanceBuilder) != null ? _a : buildStaticInstance;
  const additionalFeatures = [
    treeFeature,
    ...sortFeatures(initialConfig.features)
  ];
  verifyFeatures(additionalFeatures);
  const features = [...additionalFeatures];
  const [treeInstance, finalizeTree] = buildInstance(
    features,
    "treeInstance",
    (tree) => ({ tree })
  );
  let state = additionalFeatures.reduce(
    (acc, feature) => {
      var _a2, _b2;
      return (_b2 = (_a2 = feature.getInitialState) == null ? void 0 : _a2.call(feature, acc, treeInstance)) != null ? _b2 : acc;
    },
    (_c = (_b = initialConfig.initialState) != null ? _b : initialConfig.state) != null ? _c : {}
  );
  let config = additionalFeatures.reduce(
    (acc, feature) => {
      var _a2, _b2;
      return (_b2 = (_a2 = feature.getDefaultConfig) == null ? void 0 : _a2.call(feature, acc, treeInstance)) != null ? _b2 : acc;
    },
    initialConfig
  );
  const stateHandlerNames = additionalFeatures.reduce(
    (acc, feature) => __spreadValues(__spreadValues({}, acc), feature.stateHandlerNames),
    {}
  );
  let treeElement;
  const treeDataRef = { current: {} };
  const itemInstancesMap = {};
  let itemInstances = [];
  const itemElementsMap = {};
  const itemDataRefs = {};
  let itemMetaMap = {};
  const hotkeyPresets = {};
  const rebuildItemMeta = () => {
    itemInstances = [];
    itemMetaMap = {};
    const [rootInstance, finalizeRootInstance] = buildInstance(
      features,
      "itemInstance",
      (item) => ({ item, tree: treeInstance, itemId: config.rootItemId })
    );
    finalizeRootInstance();
    itemInstancesMap[config.rootItemId] = rootInstance;
    itemMetaMap[config.rootItemId] = {
      itemId: config.rootItemId,
      index: -1,
      parentId: null,
      level: -1,
      posInSet: 0,
      setSize: 1
    };
    for (const item of treeInstance.getItemsMeta()) {
      itemMetaMap[item.itemId] = item;
      if (!itemInstancesMap[item.itemId]) {
        const [instance, finalizeInstance] = buildInstance(
          features,
          "itemInstance",
          (instance2) => ({
            item: instance2,
            tree: treeInstance,
            itemId: item.itemId
          })
        );
        finalizeInstance();
        itemInstancesMap[item.itemId] = instance;
        itemInstances.push(instance);
      } else {
        itemInstances.push(itemInstancesMap[item.itemId]);
      }
    }
  };
  const eachFeature = (fn) => {
    for (const feature of additionalFeatures) {
      fn(feature);
    }
  };
  const mainFeature = {
    key: "main",
    treeInstance: {
      getState: () => state,
      setState: ({}, updater) => {
        var _a2;
        (_a2 = config.setState) == null ? void 0 : _a2.call(config, state);
      },
      applySubStateUpdate: ({}, stateName, updater) => {
        state[stateName] = typeof updater === "function" ? updater(state[stateName]) : updater;
        const externalStateSetter = config[stateHandlerNames[stateName]];
        externalStateSetter == null ? void 0 : externalStateSetter(state[stateName]);
      },
      // TODO rebuildSubTree: (itemId: string) => void;
      rebuildTree: () => {
        var _a2;
        rebuildItemMeta();
        (_a2 = config.setState) == null ? void 0 : _a2.call(config, state);
      },
      getConfig: () => config,
      setConfig: (_, updater) => {
        var _a2, _b2, _c2;
        const newConfig = typeof updater === "function" ? updater(config) : updater;
        const hasChangedExpandedItems = ((_a2 = newConfig.state) == null ? void 0 : _a2.expandedItems) && ((_b2 = newConfig.state) == null ? void 0 : _b2.expandedItems) !== state.expandedItems;
        config = newConfig;
        if (newConfig.state) {
          state = __spreadValues(__spreadValues({}, state), newConfig.state);
        }
        if (hasChangedExpandedItems) {
          rebuildItemMeta();
          (_c2 = config.setState) == null ? void 0 : _c2.call(config, state);
        }
      },
      getItemInstance: ({}, itemId) => {
        const existingInstance = itemInstancesMap[itemId];
        if (!existingInstance) {
          const [instance, finalizeInstance] = buildInstance(
            features,
            "itemInstance",
            (instance2) => ({
              item: instance2,
              tree: treeInstance,
              itemId
            })
          );
          finalizeInstance();
          return instance;
        }
        return existingInstance;
      },
      getItems: () => itemInstances,
      registerElement: ({}, element) => {
        if (treeElement === element) {
          return;
        }
        if (treeElement && !element) {
          eachFeature(
            (feature) => {
              var _a2;
              return (_a2 = feature.onTreeUnmount) == null ? void 0 : _a2.call(feature, treeInstance, treeElement);
            }
          );
        } else if (!treeElement && element) {
          eachFeature(
            (feature) => {
              var _a2;
              return (_a2 = feature.onTreeMount) == null ? void 0 : _a2.call(feature, treeInstance, element);
            }
          );
        }
        treeElement = element;
      },
      getElement: () => treeElement,
      getDataRef: () => treeDataRef,
      getHotkeyPresets: () => hotkeyPresets
    },
    itemInstance: {
      registerElement: ({ itemId, item }, element) => {
        if (itemElementsMap[itemId] === element) {
          return;
        }
        const oldElement = itemElementsMap[itemId];
        if (oldElement && !element) {
          eachFeature(
            (feature) => {
              var _a2;
              return (_a2 = feature.onItemUnmount) == null ? void 0 : _a2.call(feature, item, oldElement, treeInstance);
            }
          );
        } else if (!oldElement && element) {
          eachFeature(
            (feature) => {
              var _a2;
              return (_a2 = feature.onItemMount) == null ? void 0 : _a2.call(feature, item, element, treeInstance);
            }
          );
        }
        itemElementsMap[itemId] = element;
      },
      getElement: ({ itemId }) => itemElementsMap[itemId],
      // eslint-disable-next-line no-return-assign
      getDataRef: ({ itemId }) => {
        var _a2;
        return (_a2 = itemDataRefs[itemId]) != null ? _a2 : itemDataRefs[itemId] = { current: {} };
      },
      getItemMeta: ({ itemId }) => {
        var _a2;
        return (_a2 = itemMetaMap[itemId]) != null ? _a2 : {
          itemId,
          parentId: null,
          level: -1,
          index: -1,
          posInSet: 0,
          setSize: 1
        };
      }
    }
  };
  features.unshift(mainFeature);
  for (const feature of features) {
    Object.assign(hotkeyPresets, (_d = feature.hotkeys) != null ? _d : {});
  }
  finalizeTree();
  return treeInstance;
};

// src/features/drag-and-drop/types.ts
var DragTargetPosition = /* @__PURE__ */ ((DragTargetPosition2) => {
  DragTargetPosition2["Top"] = "top";
  DragTargetPosition2["Bottom"] = "bottom";
  DragTargetPosition2["Item"] = "item";
  return DragTargetPosition2;
})(DragTargetPosition || {});

// src/features/keyboard-drag-and-drop/types.ts
var AssistiveDndState = /* @__PURE__ */ ((AssistiveDndState2) => {
  AssistiveDndState2[AssistiveDndState2["None"] = 0] = "None";
  AssistiveDndState2[AssistiveDndState2["Started"] = 1] = "Started";
  AssistiveDndState2[AssistiveDndState2["Dragging"] = 2] = "Dragging";
  AssistiveDndState2[AssistiveDndState2["Completed"] = 3] = "Completed";
  AssistiveDndState2[AssistiveDndState2["Aborted"] = 4] = "Aborted";
  return AssistiveDndState2;
})(AssistiveDndState || {});

// src/features/checkboxes/types.ts
var CheckedState = /* @__PURE__ */ ((CheckedState2) => {
  CheckedState2["Checked"] = "checked";
  CheckedState2["Unchecked"] = "unchecked";
  CheckedState2["Indeterminate"] = "indeterminate";
  return CheckedState2;
})(CheckedState || {});

// src/features/selection/feature.ts
var selectionFeature = {
  key: "selection",
  getInitialState: (initialState) => __spreadValues({
    selectedItems: []
  }, initialState),
  getDefaultConfig: (defaultConfig, tree) => __spreadValues({
    setSelectedItems: makeStateUpdater("selectedItems", tree)
  }, defaultConfig),
  stateHandlerNames: {
    selectedItems: "setSelectedItems"
  },
  treeInstance: {
    setSelectedItems: ({ tree }, selectedItems) => {
      tree.applySubStateUpdate("selectedItems", selectedItems);
    },
    getSelectedItems: ({ tree }) => {
      return tree.getState().selectedItems.map(tree.getItemInstance);
    }
  },
  itemInstance: {
    select: ({ tree, itemId }) => {
      const { selectedItems } = tree.getState();
      tree.setSelectedItems(
        selectedItems.includes(itemId) ? selectedItems : [...selectedItems, itemId]
      );
    },
    deselect: ({ tree, itemId }) => {
      const { selectedItems } = tree.getState();
      tree.setSelectedItems(selectedItems.filter((id) => id !== itemId));
    },
    isSelected: ({ tree, itemId }) => {
      const { selectedItems } = tree.getState();
      return selectedItems.includes(itemId);
    },
    selectUpTo: ({ tree, item }, ctrl) => {
      const indexA = item.getItemMeta().index;
      const indexB = tree.getFocusedItem().getItemMeta().index;
      const [a, b] = indexA < indexB ? [indexA, indexB] : [indexB, indexA];
      const newSelectedItems = tree.getItems().slice(a, b + 1).map((treeItem) => treeItem.getItemMeta().itemId);
      if (!ctrl) {
        tree.setSelectedItems(newSelectedItems);
        return;
      }
      const { selectedItems } = tree.getState();
      const uniqueSelectedItems = [
        .../* @__PURE__ */ new Set([...selectedItems, ...newSelectedItems])
      ];
      tree.setSelectedItems(uniqueSelectedItems);
    },
    toggleSelect: ({ item }) => {
      if (item.isSelected()) {
        item.deselect();
      } else {
        item.select();
      }
    },
    getProps: ({ tree, item, prev }) => __spreadProps(__spreadValues({}, prev == null ? void 0 : prev()), {
      "aria-selected": item.isSelected() ? "true" : "false",
      onClick: (e) => {
        var _a, _b;
        if (e.shiftKey) {
          item.selectUpTo(e.ctrlKey || e.metaKey);
        } else if (e.ctrlKey || e.metaKey) {
          item.toggleSelect();
        } else {
          tree.setSelectedItems([item.getItemMeta().itemId]);
        }
        (_b = (_a = prev == null ? void 0 : prev()) == null ? void 0 : _a.onClick) == null ? void 0 : _b.call(_a, e);
      }
    })
  },
  hotkeys: {
    // setSelectedItem: {
    //   hotkey: "space",
    //   handler: (e, tree) => {
    //     tree.setSelectedItems([tree.getFocusedItem().getId()]);
    //   },
    // },
    toggleSelectedItem: {
      hotkey: "Control+Space",
      preventDefault: true,
      handler: (_, tree) => {
        tree.getFocusedItem().toggleSelect();
      }
    },
    selectUpwards: {
      hotkey: "Shift+ArrowUp",
      handler: (e, tree) => {
        const focused = tree.getFocusedItem();
        const above = focused.getItemAbove();
        if (!above) return;
        if (focused.isSelected() && above.isSelected()) {
          focused.deselect();
        } else {
          above.select();
        }
        above.setFocused();
        tree.updateDomFocus();
      }
    },
    selectDownwards: {
      hotkey: "Shift+ArrowDown",
      handler: (e, tree) => {
        const focused = tree.getFocusedItem();
        const below = focused.getItemBelow();
        if (!below) return;
        if (focused.isSelected() && below.isSelected()) {
          focused.deselect();
        } else {
          below.select();
        }
        below.setFocused();
        tree.updateDomFocus();
      }
    },
    selectAll: {
      hotkey: "Control+KeyA",
      preventDefault: true,
      handler: (e, tree) => {
        tree.setSelectedItems(tree.getItems().map((item) => item.getId()));
      }
    }
  }
};

// src/features/checkboxes/feature.ts
var getAllLoadedDescendants = (tree, itemId, includeFolders = false) => {
  if (!tree.getConfig().isItemFolder(tree.getItemInstance(itemId))) {
    return [itemId];
  }
  const descendants = tree.retrieveChildrenIds(itemId).map((child) => getAllLoadedDescendants(tree, child, includeFolders)).flat();
  return includeFolders ? [itemId, ...descendants] : descendants;
};
var checkboxesFeature = {
  key: "checkboxes",
  overwrites: ["selection"],
  getInitialState: (initialState) => __spreadValues({
    checkedItems: []
  }, initialState),
  getDefaultConfig: (defaultConfig, tree) => {
    var _a, _b, _c;
    const hasAsyncLoader = (_a = defaultConfig.features) == null ? void 0 : _a.some(
      (f) => f.key === "async-data-loader"
    );
    if (hasAsyncLoader && defaultConfig.propagateCheckedState) {
      throwError(`propagateCheckedState not supported with async trees`);
    }
    const propagateCheckedState = (_b = defaultConfig.propagateCheckedState) != null ? _b : !hasAsyncLoader;
    const canCheckFolders = (_c = defaultConfig.canCheckFolders) != null ? _c : !propagateCheckedState;
    return __spreadValues({
      setCheckedItems: makeStateUpdater("checkedItems", tree),
      propagateCheckedState,
      canCheckFolders
    }, defaultConfig);
  },
  stateHandlerNames: {
    checkedItems: "setCheckedItems"
  },
  treeInstance: {
    setCheckedItems: ({ tree }, checkedItems) => {
      tree.applySubStateUpdate("checkedItems", checkedItems);
    }
  },
  itemInstance: {
    getCheckboxProps: ({ item }) => {
      const checkedState = item.getCheckedState();
      return {
        onChange: item.toggleCheckedState,
        checked: checkedState === "checked" /* Checked */,
        ref: (r) => {
          if (r) {
            r.indeterminate = checkedState === "indeterminate" /* Indeterminate */;
          }
        }
      };
    },
    toggleCheckedState: ({ item }) => {
      if (item.getCheckedState() === "checked" /* Checked */) {
        item.setUnchecked();
      } else {
        item.setChecked();
      }
    },
    getCheckedState: ({ item, tree }) => {
      const { checkedItems } = tree.getState();
      const { propagateCheckedState } = tree.getConfig();
      const itemId = item.getId();
      if (checkedItems.includes(itemId)) {
        return "checked" /* Checked */;
      }
      if (item.isFolder() && propagateCheckedState) {
        const descendants = getAllLoadedDescendants(tree, itemId);
        if (descendants.every((d) => checkedItems.includes(d))) {
          return "checked" /* Checked */;
        }
        if (descendants.some((d) => checkedItems.includes(d))) {
          return "indeterminate" /* Indeterminate */;
        }
      }
      return "unchecked" /* Unchecked */;
    },
    setChecked: ({ item, tree, itemId }) => {
      const { propagateCheckedState, canCheckFolders } = tree.getConfig();
      if (item.isFolder() && propagateCheckedState) {
        tree.applySubStateUpdate("checkedItems", (items) => [
          ...items,
          ...getAllLoadedDescendants(tree, itemId, canCheckFolders)
        ]);
      } else if (!item.isFolder() || canCheckFolders) {
        tree.applySubStateUpdate("checkedItems", (items) => [...items, itemId]);
      }
    },
    setUnchecked: ({ item, tree, itemId }) => {
      const { propagateCheckedState, canCheckFolders } = tree.getConfig();
      if (item.isFolder() && propagateCheckedState) {
        const descendants = getAllLoadedDescendants(
          tree,
          itemId,
          canCheckFolders
        );
        tree.applySubStateUpdate(
          "checkedItems",
          (items) => items.filter((id) => !descendants.includes(id) && id !== itemId)
        );
      } else {
        tree.applySubStateUpdate(
          "checkedItems",
          (items) => items.filter((id) => id !== itemId)
        );
      }
    }
  }
};

// src/features/hotkeys-core/feature.ts
var specialKeys = {
  // TODO:breaking deprecate auto-lowercase
  letter: /^Key[A-Z]$/,
  letterornumber: /^(Key[A-Z]|Digit[0-9])$/,
  plus: /^(NumpadAdd|Plus)$/,
  minus: /^(NumpadSubtract|Minus)$/,
  control: /^(ControlLeft|ControlRight)$/,
  shift: /^(ShiftLeft|ShiftRight)$/
};
var testHotkeyMatch = (pressedKeys, tree, hotkey) => {
  const supposedKeys = hotkey.hotkey.toLowerCase().split("+");
  const doKeysMatch = supposedKeys.every((key) => {
    if (key in specialKeys) {
      return [...pressedKeys].some(
        (pressedKey) => specialKeys[key].test(pressedKey)
      );
    }
    const pressedKeysLowerCase = [...pressedKeys].map((k) => k.toLowerCase());
    if (pressedKeysLowerCase.includes(key.toLowerCase())) {
      return true;
    }
    if (pressedKeysLowerCase.includes(`key${key.toLowerCase()}`)) {
      return true;
    }
    return false;
  });
  const isEnabled = !hotkey.isEnabled || hotkey.isEnabled(tree);
  const equalCounts = pressedKeys.size === supposedKeys.length;
  return doKeysMatch && isEnabled && equalCounts;
};
var findHotkeyMatch = (pressedKeys, tree, config1, config2) => {
  var _a;
  return (_a = Object.entries(__spreadValues(__spreadValues({}, config1), config2)).find(
    ([, hotkey]) => testHotkeyMatch(pressedKeys, tree, hotkey)
  )) == null ? void 0 : _a[0];
};
var hotkeysCoreFeature = {
  key: "hotkeys-core",
  onTreeMount: (tree, element) => {
    const data = tree.getDataRef();
    const keydown = (e) => {
      var _a, _b;
      const { ignoreHotkeysOnInputs, onTreeHotkey, hotkeys } = tree.getConfig();
      if (e.target instanceof HTMLInputElement && ignoreHotkeysOnInputs) {
        return;
      }
      (_b = (_a = data.current).pressedKeys) != null ? _b : _a.pressedKeys = /* @__PURE__ */ new Set();
      const newMatch = !data.current.pressedKeys.has(e.code);
      data.current.pressedKeys.add(e.code);
      const hotkeyName = findHotkeyMatch(
        data.current.pressedKeys,
        tree,
        tree.getHotkeyPresets(),
        hotkeys
      );
      if (e.target instanceof HTMLInputElement) {
        data.current.pressedKeys.delete(e.code);
      }
      if (!hotkeyName) return;
      const hotkeyConfig = __spreadValues(__spreadValues({}, tree.getHotkeyPresets()[hotkeyName]), hotkeys == null ? void 0 : hotkeys[hotkeyName]);
      if (!hotkeyConfig) return;
      if (!hotkeyConfig.allowWhenInputFocused && e.target instanceof HTMLInputElement)
        return;
      if (!hotkeyConfig.canRepeat && !newMatch) return;
      if (hotkeyConfig.preventDefault) e.preventDefault();
      hotkeyConfig.handler(e, tree);
      onTreeHotkey == null ? void 0 : onTreeHotkey(hotkeyName, e);
    };
    const keyup = (e) => {
      var _a, _b;
      (_b = (_a = data.current).pressedKeys) != null ? _b : _a.pressedKeys = /* @__PURE__ */ new Set();
      data.current.pressedKeys.delete(e.code);
    };
    const reset = () => {
      data.current.pressedKeys = /* @__PURE__ */ new Set();
    };
    element.addEventListener("keydown", keydown);
    document.addEventListener("keyup", keyup);
    window.addEventListener("focus", reset);
    data.current.keydownHandler = keydown;
    data.current.keyupHandler = keyup;
    data.current.resetHandler = reset;
  },
  onTreeUnmount: (tree, element) => {
    const data = tree.getDataRef();
    if (data.current.keyupHandler) {
      document.removeEventListener("keyup", data.current.keyupHandler);
      delete data.current.keyupHandler;
    }
    if (data.current.keydownHandler) {
      element.removeEventListener("keydown", data.current.keydownHandler);
      delete data.current.keydownHandler;
    }
    if (data.current.resetHandler) {
      window.removeEventListener("focus", data.current.resetHandler);
      delete data.current.resetHandler;
    }
  }
};

// src/features/async-data-loader/feature.ts
var getDataRef = (tree) => {
  var _a, _b, _c, _d;
  const dataRef = tree.getDataRef();
  (_b = (_a = dataRef.current).itemData) != null ? _b : _a.itemData = {};
  (_d = (_c = dataRef.current).childrenIds) != null ? _d : _c.childrenIds = {};
  return dataRef;
};
var loadItemData = (tree, itemId) => __async(null, null, function* () {
  var _a;
  const config = tree.getConfig();
  const dataRef = getDataRef(tree);
  const item = yield config.dataLoader.getItem(itemId);
  dataRef.current.itemData[itemId] = item;
  (_a = config.onLoadedItem) == null ? void 0 : _a.call(config, itemId, item);
  tree.applySubStateUpdate(
    "loadingItemData",
    (loadingItemData) => loadingItemData.filter((id) => id !== itemId)
  );
  return item;
});
var loadChildrenIds = (tree, itemId) => __async(null, null, function* () {
  var _a, _b;
  const config = tree.getConfig();
  const dataRef = getDataRef(tree);
  let childrenIds;
  if ("getChildrenWithData" in config.dataLoader) {
    const children = yield config.dataLoader.getChildrenWithData(itemId);
    childrenIds = children.map((c) => c.id);
    dataRef.current.childrenIds[itemId] = childrenIds;
    children.forEach(({ id, data }) => {
      var _a2;
      dataRef.current.itemData[id] = data;
      (_a2 = config.onLoadedItem) == null ? void 0 : _a2.call(config, id, data);
    });
    (_a = config.onLoadedChildren) == null ? void 0 : _a.call(config, itemId, childrenIds);
    tree.rebuildTree();
    tree.applySubStateUpdate(
      "loadingItemData",
      (loadingItemData) => loadingItemData.filter((id) => !childrenIds.includes(id))
    );
  } else {
    childrenIds = yield config.dataLoader.getChildren(itemId);
    dataRef.current.childrenIds[itemId] = childrenIds;
    (_b = config.onLoadedChildren) == null ? void 0 : _b.call(config, itemId, childrenIds);
    tree.rebuildTree();
  }
  tree.applySubStateUpdate(
    "loadingItemChildrens",
    (loadingItemChildrens) => loadingItemChildrens.filter((id) => id !== itemId)
  );
  return childrenIds;
});
var asyncDataLoaderFeature = {
  key: "async-data-loader",
  getInitialState: (initialState) => __spreadValues({
    loadingItemData: [],
    loadingItemChildrens: []
  }, initialState),
  getDefaultConfig: (defaultConfig, tree) => __spreadValues({
    setLoadingItemData: makeStateUpdater("loadingItemData", tree),
    setLoadingItemChildrens: makeStateUpdater("loadingItemChildrens", tree)
  }, defaultConfig),
  stateHandlerNames: {
    loadingItemData: "setLoadingItemData",
    loadingItemChildrens: "setLoadingItemChildrens"
  },
  treeInstance: {
    waitForItemDataLoaded: ({ tree }, itemId) => tree.loadItemData(itemId),
    waitForItemChildrenLoaded: ({ tree }, itemId) => tree.loadChildrenIds(itemId),
    loadItemData: (_0, _1) => __async(null, [_0, _1], function* ({ tree }, itemId) {
      var _a;
      return (_a = getDataRef(tree).current.itemData[itemId]) != null ? _a : yield loadItemData(tree, itemId);
    }),
    loadChildrenIds: (_0, _1) => __async(null, [_0, _1], function* ({ tree }, itemId) {
      var _a;
      return (_a = getDataRef(tree).current.childrenIds[itemId]) != null ? _a : yield loadChildrenIds(tree, itemId);
    }),
    retrieveItemData: ({ tree }, itemId, skipFetch = false) => {
      var _a, _b;
      const config = tree.getConfig();
      const dataRef = getDataRef(tree);
      if (dataRef.current.itemData[itemId]) {
        return dataRef.current.itemData[itemId];
      }
      if (!tree.getState().loadingItemData.includes(itemId) && !skipFetch) {
        tree.applySubStateUpdate("loadingItemData", (loadingItemData) => [
          ...loadingItemData,
          itemId
        ]);
        loadItemData(tree, itemId);
      }
      return (_b = (_a = config.createLoadingItemData) == null ? void 0 : _a.call(config)) != null ? _b : null;
    },
    retrieveChildrenIds: ({ tree }, itemId, skipFetch = false) => {
      const dataRef = getDataRef(tree);
      if (dataRef.current.childrenIds[itemId]) {
        return dataRef.current.childrenIds[itemId];
      }
      if (tree.getState().loadingItemChildrens.includes(itemId) || skipFetch) {
        return [];
      }
      tree.applySubStateUpdate(
        "loadingItemChildrens",
        (loadingItemChildrens) => [...loadingItemChildrens, itemId]
      );
      loadChildrenIds(tree, itemId);
      return [];
    }
  },
  itemInstance: {
    isLoading: ({ tree, item }) => tree.getState().loadingItemData.includes(item.getItemMeta().itemId) || tree.getState().loadingItemChildrens.includes(item.getItemMeta().itemId),
    invalidateItemData: (_0, _1) => __async(null, [_0, _1], function* ({ tree, itemId }, optimistic) {
      var _a;
      if (!optimistic) {
        (_a = getDataRef(tree).current.itemData) == null ? true : delete _a[itemId];
        tree.applySubStateUpdate("loadingItemData", (loadingItemData) => [
          ...loadingItemData,
          itemId
        ]);
      }
      yield loadItemData(tree, itemId);
    }),
    invalidateChildrenIds: (_0, _1) => __async(null, [_0, _1], function* ({ tree, itemId }, optimistic) {
      var _a;
      if (!optimistic) {
        (_a = getDataRef(tree).current.childrenIds) == null ? true : delete _a[itemId];
        tree.applySubStateUpdate(
          "loadingItemChildrens",
          (loadingItemChildrens) => [...loadingItemChildrens, itemId]
        );
      }
      yield loadChildrenIds(tree, itemId);
    }),
    updateCachedChildrenIds: ({ tree, itemId }, childrenIds) => {
      const dataRef = tree.getDataRef();
      dataRef.current.childrenIds[itemId] = childrenIds;
      tree.rebuildTree();
    },
    updateCachedData: ({ tree, itemId }, data) => {
      const dataRef = tree.getDataRef();
      dataRef.current.itemData[itemId] = data;
      tree.rebuildTree();
    }
  }
};

// src/features/sync-data-loader/feature.ts
var undefErrorMessage = "sync dataLoader returned undefined";
var promiseErrorMessage = "sync dataLoader returned promise";
var unpromise = (data) => {
  if (!data) {
    throw throwError(undefErrorMessage);
  }
  if (typeof data === "object" && "then" in data) {
    throw throwError(promiseErrorMessage);
  }
  return data;
};
var syncDataLoaderFeature = {
  key: "sync-data-loader",
  getInitialState: (initialState) => __spreadValues({
    loadingItemData: [],
    loadingItemChildrens: []
  }, initialState),
  getDefaultConfig: (defaultConfig, tree) => __spreadValues({
    setLoadingItemData: makeStateUpdater("loadingItemData", tree),
    setLoadingItemChildrens: makeStateUpdater("loadingItemChildrens", tree)
  }, defaultConfig),
  stateHandlerNames: {
    loadingItemData: "setLoadingItemData",
    loadingItemChildrens: "setLoadingItemChildrens"
  },
  treeInstance: {
    waitForItemDataLoaded: () => __async(null, null, function* () {
    }),
    waitForItemChildrenLoaded: () => __async(null, null, function* () {
    }),
    retrieveItemData: ({ tree }, itemId) => {
      return unpromise(tree.getConfig().dataLoader.getItem(itemId));
    },
    retrieveChildrenIds: ({ tree }, itemId) => {
      const { dataLoader } = tree.getConfig();
      if ("getChildren" in dataLoader) {
        return unpromise(dataLoader.getChildren(itemId));
      }
      return unpromise(dataLoader.getChildrenWithData(itemId)).map(
        (c) => c.data
      );
    },
    loadItemData: ({ tree }, itemId) => tree.retrieveItemData(itemId),
    loadChildrenIds: ({ tree }, itemId) => tree.retrieveChildrenIds(itemId)
  },
  itemInstance: {
    isLoading: () => false
  }
};

// src/features/drag-and-drop/utils.ts
var isOrderedDragTarget = (dragTarget) => "childIndex" in dragTarget;
var canDrop = (dataTransfer, target, tree) => {
  var _a, _b, _c;
  const draggedItems = (_a = tree.getState().dnd) == null ? void 0 : _a.draggedItems;
  const config = tree.getConfig();
  if (draggedItems && !((_c = (_b = config.canDrop) == null ? void 0 : _b.call(config, draggedItems, target)) != null ? _c : true)) {
    return false;
  }
  if (draggedItems && draggedItems.some(
    (draggedItem) => target.item.getId() === draggedItem.getId() || target.item.isDescendentOf(draggedItem.getId())
  )) {
    return false;
  }
  if (!draggedItems && dataTransfer && config.canDropForeignDragObject && !config.canDropForeignDragObject(dataTransfer, target)) {
    return false;
  }
  return true;
};
var getItemDropCategory = (item) => {
  if (item.isExpanded()) {
    return 1 /* ExpandedFolder */;
  }
  const parent = item.getParent();
  if (parent && item.getIndexInParent() === item.getItemMeta().setSize - 1) {
    return 2 /* LastInGroup */;
  }
  return 0 /* Item */;
};
var getInsertionIndex = (children, childIndex, draggedItems) => {
  var _a;
  const numberOfDragItemsBeforeTarget = (_a = children.slice(0, childIndex).reduce(
    (counter, child) => child && (draggedItems == null ? void 0 : draggedItems.some((i) => i.getId() === child.getId())) ? ++counter : counter,
    0
  )) != null ? _a : 0;
  return childIndex - numberOfDragItemsBeforeTarget;
};
var getTargetPlacement = (e, item, tree, canMakeChild) => {
  var _a, _b, _c, _d, _e;
  const config = tree.getConfig();
  if (!config.canReorder) {
    return canMakeChild ? { type: 2 /* MakeChild */ } : { type: 1 /* ReorderBelow */ };
  }
  const bb = (_a = item.getElement()) == null ? void 0 : _a.getBoundingClientRect();
  const topPercent = bb ? (e.clientY - bb.top) / bb.height : 0.5;
  const leftPixels = bb ? e.clientX - bb.left : 0;
  const targetDropCategory = getItemDropCategory(item);
  const reorderAreaPercentage = !canMakeChild ? 0.5 : (_b = config.reorderAreaPercentage) != null ? _b : 0.3;
  const indent = (_c = config.indent) != null ? _c : 20;
  const makeChildType = canMakeChild ? 2 /* MakeChild */ : 1 /* ReorderBelow */;
  if (targetDropCategory === 1 /* ExpandedFolder */) {
    if (topPercent < reorderAreaPercentage) {
      return { type: 0 /* ReorderAbove */ };
    }
    return { type: makeChildType };
  }
  if (targetDropCategory === 2 /* LastInGroup */) {
    if (leftPixels < item.getItemMeta().level * indent) {
      if (topPercent < 0.5) {
        return { type: 0 /* ReorderAbove */ };
      }
      const minLevel = (_e = (_d = item.getItemBelow()) == null ? void 0 : _d.getItemMeta().level) != null ? _e : 0;
      return {
        type: 3 /* Reparent */,
        reparentLevel: Math.max(minLevel, Math.floor(leftPixels / indent))
      };
    }
  }
  if (topPercent < reorderAreaPercentage) {
    return { type: 0 /* ReorderAbove */ };
  }
  if (topPercent > 1 - reorderAreaPercentage) {
    return { type: 1 /* ReorderBelow */ };
  }
  return { type: makeChildType };
};
var getDragCode = (item, placement) => {
  return [
    item.getId(),
    placement.type,
    placement.type === 3 /* Reparent */ ? placement.reparentLevel : 0
  ].join("__");
};
var getNthParent = (item, n) => {
  if (n === item.getItemMeta().level) {
    return item;
  }
  return getNthParent(item.getParent(), n);
};
var getReparentTarget = (item, reparentLevel, draggedItems) => {
  const itemMeta = item.getItemMeta();
  const reparentedTarget = getNthParent(item, reparentLevel - 1);
  const targetItemAbove = getNthParent(item, reparentLevel);
  const targetIndex = targetItemAbove.getIndexInParent() + 1;
  return {
    item: reparentedTarget,
    childIndex: targetIndex,
    insertionIndex: getInsertionIndex(
      reparentedTarget.getChildren(),
      targetIndex,
      draggedItems
    ),
    dragLineIndex: itemMeta.index + 1,
    dragLineLevel: reparentLevel
  };
};
var getDragTarget = (e, item, tree, canReorder = tree.getConfig().canReorder) => {
  var _a;
  const draggedItems = (_a = tree.getState().dnd) == null ? void 0 : _a.draggedItems;
  const itemMeta = item.getItemMeta();
  const parent = item.getParent();
  const itemTarget = { item };
  const parentTarget = parent ? { item: parent } : null;
  const canBecomeSibling = parentTarget && canDrop(e.dataTransfer, parentTarget, tree);
  const canMakeChild = canDrop(e.dataTransfer, itemTarget, tree);
  const placement = getTargetPlacement(e, item, tree, canMakeChild);
  if (!canReorder && parent && canBecomeSibling && placement.type !== 2 /* MakeChild */) {
    if (draggedItems == null ? void 0 : draggedItems.some((item2) => item2.isDescendentOf(parent.getId()))) {
      return itemTarget;
    }
    return parentTarget;
  }
  if (!canReorder && parent && !canBecomeSibling) {
    return getDragTarget(e, parent, tree, false);
  }
  if (!parent) {
    return itemTarget;
  }
  if (placement.type === 2 /* MakeChild */) {
    return itemTarget;
  }
  if (!canBecomeSibling) {
    return getDragTarget(e, parent, tree, false);
  }
  if (placement.type === 3 /* Reparent */) {
    return getReparentTarget(item, placement.reparentLevel, draggedItems);
  }
  const maybeAddOneForBelow = placement.type === 0 /* ReorderAbove */ ? 0 : 1;
  const childIndex = item.getIndexInParent() + maybeAddOneForBelow;
  return {
    item: parent,
    dragLineIndex: itemMeta.index + maybeAddOneForBelow,
    dragLineLevel: itemMeta.level,
    childIndex,
    // TODO performance could be improved by computing this only when dragcode changed
    insertionIndex: getInsertionIndex(
      parent.getChildren(),
      childIndex,
      draggedItems
    )
  };
};

// src/features/drag-and-drop/feature.ts
var handleAutoOpenFolder = (dataRef, tree, item, placement) => {
  const { openOnDropDelay } = tree.getConfig();
  const dragCode = dataRef.current.lastDragCode;
  if (!openOnDropDelay || !item.isFolder() || item.isExpanded() || placement.type !== 2 /* MakeChild */) {
    return;
  }
  clearTimeout(dataRef.current.autoExpandTimeout);
  dataRef.current.autoExpandTimeout = setTimeout(() => {
    if (dragCode !== dataRef.current.lastDragCode || !dataRef.current.lastAllowDrop)
      return;
    item.expand();
  }, openOnDropDelay);
};
var defaultCanDropForeignDragObject = () => false;
var dragAndDropFeature = {
  key: "drag-and-drop",
  getDefaultConfig: (defaultConfig, tree) => __spreadValues({
    canDrop: (_, target) => target.item.isFolder(),
    canDropForeignDragObject: defaultCanDropForeignDragObject,
    canDragForeignDragObjectOver: defaultConfig.canDropForeignDragObject !== defaultCanDropForeignDragObject ? (dataTransfer) => dataTransfer.effectAllowed !== "none" : () => false,
    setDndState: makeStateUpdater("dnd", tree),
    canReorder: true,
    openOnDropDelay: 800
  }, defaultConfig),
  stateHandlerNames: {
    dnd: "setDndState"
  },
  onTreeMount: (tree) => {
    const listener = () => {
      tree.applySubStateUpdate("dnd", null);
    };
    tree.getDataRef().current.windowDragEndListener = listener;
    window.addEventListener("dragend", listener);
  },
  onTreeUnmount: (tree) => {
    const { windowDragEndListener } = tree.getDataRef().current;
    if (!windowDragEndListener) return;
    window.removeEventListener("dragend", windowDragEndListener);
  },
  treeInstance: {
    getDragTarget: ({ tree }) => {
      var _a, _b;
      return (_b = (_a = tree.getState().dnd) == null ? void 0 : _a.dragTarget) != null ? _b : null;
    },
    getDragLineData: ({ tree }) => {
      var _a, _b, _c, _d, _e, _f;
      const target = tree.getDragTarget();
      const indent = ((_a = target == null ? void 0 : target.item.getItemMeta().level) != null ? _a : 0) + 1;
      const treeBb = (_b = tree.getElement()) == null ? void 0 : _b.getBoundingClientRect();
      if (!target || !treeBb || !isOrderedDragTarget(target)) return null;
      const leftOffset = target.dragLineLevel * ((_c = tree.getConfig().indent) != null ? _c : 1);
      const targetItem = tree.getItems()[target.dragLineIndex];
      if (!targetItem) {
        const bb2 = (_e = (_d = tree.getItems()[target.dragLineIndex - 1]) == null ? void 0 : _d.getElement()) == null ? void 0 : _e.getBoundingClientRect();
        if (bb2) {
          return {
            indent,
            top: bb2.bottom - treeBb.top,
            left: bb2.left + leftOffset - treeBb.left,
            width: bb2.width - leftOffset
          };
        }
      }
      const bb = (_f = targetItem == null ? void 0 : targetItem.getElement()) == null ? void 0 : _f.getBoundingClientRect();
      if (bb) {
        return {
          indent,
          top: bb.top - treeBb.top,
          left: bb.left + leftOffset - treeBb.left,
          width: bb.width - leftOffset
        };
      }
      return null;
    },
    getDragLineStyle: ({ tree }, topOffset = -1, leftOffset = -8) => {
      const dragLine = tree.getDragLineData();
      return dragLine ? {
        position: "absolute",
        top: `${dragLine.top + topOffset}px`,
        left: `${dragLine.left + leftOffset}px`,
        width: `${dragLine.width - leftOffset}px`,
        pointerEvents: "none"
        // important to prevent capturing drag events
      } : { display: "none" };
    },
    getContainerProps: ({ prev, tree }, treeLabel) => {
      const prevProps = prev == null ? void 0 : prev(treeLabel);
      return __spreadProps(__spreadValues({}, prevProps), {
        onDragOver: (e) => {
          e.preventDefault();
        },
        onDrop: (e) => __async(null, null, function* () {
          var _a, _b, _c;
          const dataRef = tree.getDataRef();
          const target = { item: tree.getRootItem() };
          if (!canDrop(e.dataTransfer, target, tree)) {
            return;
          }
          e.preventDefault();
          const config = tree.getConfig();
          const draggedItems = (_a = tree.getState().dnd) == null ? void 0 : _a.draggedItems;
          dataRef.current.lastDragCode = void 0;
          if (draggedItems) {
            yield (_b = config.onDrop) == null ? void 0 : _b.call(config, draggedItems, target);
          } else if (e.dataTransfer) {
            yield (_c = config.onDropForeignDragObject) == null ? void 0 : _c.call(config, e.dataTransfer, target);
          }
        }),
        style: __spreadProps(__spreadValues({}, prevProps == null ? void 0 : prevProps.style), {
          position: "relative"
        })
      });
    }
  },
  itemInstance: {
    getProps: ({ tree, item, prev }) => __spreadProps(__spreadValues({}, prev == null ? void 0 : prev()), {
      draggable: true,
      onDragEnter: (e) => e.preventDefault(),
      onDragStart: (e) => {
        var _a, _b, _c, _d;
        const selectedItems = tree.getSelectedItems ? tree.getSelectedItems() : [tree.getFocusedItem()];
        const items = selectedItems.includes(item) ? selectedItems : [item];
        const config = tree.getConfig();
        if (!selectedItems.includes(item)) {
          (_a = tree.setSelectedItems) == null ? void 0 : _a.call(tree, [item.getItemMeta().itemId]);
        }
        if (!((_c = (_b = config.canDrag) == null ? void 0 : _b.call(config, items)) != null ? _c : true)) {
          e.preventDefault();
          return;
        }
        if (config.setDragImage) {
          const { imgElement, xOffset, yOffset } = config.setDragImage(items);
          (_d = e.dataTransfer) == null ? void 0 : _d.setDragImage(imgElement, xOffset != null ? xOffset : 0, yOffset != null ? yOffset : 0);
        }
        if (config.createForeignDragObject && e.dataTransfer) {
          const { format, data, dropEffect, effectAllowed } = config.createForeignDragObject(items);
          e.dataTransfer.setData(format, data);
          if (dropEffect) e.dataTransfer.dropEffect = dropEffect;
          if (effectAllowed) e.dataTransfer.effectAllowed = effectAllowed;
        }
        tree.applySubStateUpdate("dnd", {
          draggedItems: items,
          draggingOverItem: tree.getFocusedItem()
        });
      },
      onDragOver: (e) => {
        var _a, _b, _c;
        e.stopPropagation();
        const dataRef = tree.getDataRef();
        const placement = getTargetPlacement(e, item, tree, true);
        const nextDragCode = getDragCode(item, placement);
        if (nextDragCode === dataRef.current.lastDragCode) {
          if (dataRef.current.lastAllowDrop) {
            e.preventDefault();
          }
          return;
        }
        dataRef.current.lastDragCode = nextDragCode;
        dataRef.current.lastDragEnter = Date.now();
        handleAutoOpenFolder(dataRef, tree, item, placement);
        const target = getDragTarget(e, item, tree);
        if (!((_a = tree.getState().dnd) == null ? void 0 : _a.draggedItems) && (!e.dataTransfer || !((_c = (_b = tree.getConfig()).canDragForeignDragObjectOver) == null ? void 0 : _c.call(_b, e.dataTransfer, target)))) {
          dataRef.current.lastAllowDrop = false;
          return;
        }
        if (!canDrop(e.dataTransfer, target, tree)) {
          dataRef.current.lastAllowDrop = false;
          return;
        }
        tree.applySubStateUpdate("dnd", (state) => __spreadProps(__spreadValues({}, state), {
          dragTarget: target,
          draggingOverItem: item
        }));
        dataRef.current.lastAllowDrop = true;
        e.preventDefault();
      },
      onDragLeave: () => {
        setTimeout(() => {
          var _a;
          const dataRef = tree.getDataRef();
          if (((_a = dataRef.current.lastDragEnter) != null ? _a : 0) + 100 >= Date.now()) return;
          dataRef.current.lastDragCode = "no-drag";
          tree.applySubStateUpdate("dnd", (state) => __spreadProps(__spreadValues({}, state), {
            draggingOverItem: void 0,
            dragTarget: void 0
          }));
        }, 100);
      },
      onDragEnd: (e) => {
        var _a, _b;
        const { onCompleteForeignDrop, canDragForeignDragObjectOver } = tree.getConfig();
        const draggedItems = (_a = tree.getState().dnd) == null ? void 0 : _a.draggedItems;
        if (((_b = e.dataTransfer) == null ? void 0 : _b.dropEffect) === "none" || !draggedItems) {
          return;
        }
        const target = getDragTarget(e, item, tree);
        if (canDragForeignDragObjectOver && e.dataTransfer && !canDragForeignDragObjectOver(e.dataTransfer, target)) {
          return;
        }
        onCompleteForeignDrop == null ? void 0 : onCompleteForeignDrop(draggedItems);
      },
      onDrop: (e) => __async(null, null, function* () {
        var _a, _b, _c;
        e.stopPropagation();
        const dataRef = tree.getDataRef();
        const target = getDragTarget(e, item, tree);
        const draggedItems = (_a = tree.getState().dnd) == null ? void 0 : _a.draggedItems;
        const isValidDrop = canDrop(e.dataTransfer, target, tree);
        tree.applySubStateUpdate("dnd", {
          draggedItems: void 0,
          draggingOverItem: void 0,
          dragTarget: void 0
        });
        if (!isValidDrop) {
          return;
        }
        e.preventDefault();
        const config = tree.getConfig();
        dataRef.current.lastDragCode = void 0;
        if (draggedItems) {
          yield (_b = config.onDrop) == null ? void 0 : _b.call(config, draggedItems, target);
        } else if (e.dataTransfer) {
          yield (_c = config.onDropForeignDragObject) == null ? void 0 : _c.call(config, e.dataTransfer, target);
        }
      })
    }),
    isDragTarget: ({ tree, item }) => {
      const target = tree.getDragTarget();
      return target ? target.item.getId() === item.getId() : false;
    },
    isDragTargetAbove: ({ tree, item }) => {
      const target = tree.getDragTarget();
      if (!target || !isOrderedDragTarget(target) || target.item !== item.getParent())
        return false;
      return target.childIndex === item.getItemMeta().posInSet;
    },
    isDragTargetBelow: ({ tree, item }) => {
      const target = tree.getDragTarget();
      if (!target || !isOrderedDragTarget(target) || target.item !== item.getParent())
        return false;
      return target.childIndex - 1 === item.getItemMeta().posInSet;
    },
    isDraggingOver: ({ tree, item }) => {
      var _a, _b;
      return ((_b = (_a = tree.getState().dnd) == null ? void 0 : _a.draggingOverItem) == null ? void 0 : _b.getId()) === item.getId();
    }
  }
};

// src/features/keyboard-drag-and-drop/feature.ts
var getNextDragTarget = (tree, isUp, dragTarget) => {
  var _a, _b, _c, _d;
  const direction = isUp ? 0 : 1;
  const draggedItems = (_a = tree.getState().dnd) == null ? void 0 : _a.draggedItems;
  if (isOrderedDragTarget(dragTarget)) {
    const parent = dragTarget.item.getParent();
    const targetedItem = tree.getItems()[dragTarget.dragLineIndex - 1];
    const targetCategory = targetedItem ? getItemDropCategory(targetedItem) : 0 /* Item */;
    const maxLevel = (_b = targetedItem == null ? void 0 : targetedItem.getItemMeta().level) != null ? _b : 0;
    const minLevel = (_d = (_c = targetedItem == null ? void 0 : targetedItem.getItemBelow()) == null ? void 0 : _c.getItemMeta().level) != null ? _d : 0;
    if (targetCategory === 2 /* LastInGroup */) {
      if (isUp && dragTarget.dragLineLevel < maxLevel) {
        return getReparentTarget(
          targetedItem,
          dragTarget.dragLineLevel + 1,
          draggedItems
        );
      }
      if (!isUp && dragTarget.dragLineLevel > minLevel && parent) {
        return getReparentTarget(
          targetedItem,
          dragTarget.dragLineLevel - 1,
          draggedItems
        );
      }
    }
    const newIndex = dragTarget.dragLineIndex - 1 + direction;
    const item = tree.getItems()[newIndex];
    return item ? { item } : void 0;
  }
  const targetingExpandedFolder = getItemDropCategory(dragTarget.item) === 1 /* ExpandedFolder */;
  if (targetingExpandedFolder && !isUp) {
    return {
      item: dragTarget.item,
      childIndex: 0,
      insertionIndex: getInsertionIndex(
        dragTarget.item.getChildren(),
        0,
        draggedItems
      ),
      dragLineIndex: dragTarget.item.getItemMeta().index + direction,
      dragLineLevel: dragTarget.item.getItemMeta().level + 1
    };
  }
  const childIndex = dragTarget.item.getIndexInParent() + direction;
  return {
    item: dragTarget.item.getParent(),
    childIndex,
    insertionIndex: getInsertionIndex(
      dragTarget.item.getParent().getChildren(),
      childIndex,
      draggedItems
    ),
    dragLineIndex: dragTarget.item.getItemMeta().index + direction,
    dragLineLevel: dragTarget.item.getItemMeta().level
  };
};
var getNextValidDragTarget = (tree, isUp, previousTarget = ((_a) => (_a = tree.getState().dnd) == null ? void 0 : _a.dragTarget)()) => {
  var _a2;
  if (!previousTarget) return void 0;
  const nextTarget = getNextDragTarget(tree, isUp, previousTarget);
  const dataTransfer = (_a2 = tree.getDataRef().current.kDndDataTransfer) != null ? _a2 : null;
  if (!nextTarget) return void 0;
  if (canDrop(dataTransfer, nextTarget, tree)) {
    return nextTarget;
  }
  return getNextValidDragTarget(tree, isUp, nextTarget);
};
var updateScroll = (tree) => {
  const state = tree.getState().dnd;
  if (!(state == null ? void 0 : state.dragTarget) || isOrderedDragTarget(state.dragTarget)) return;
  state.dragTarget.item.scrollTo({ block: "nearest", inline: "nearest" });
};
var initiateDrag = (tree, draggedItems, dataTransfer) => {
  var _a, _b;
  const focusedItem = tree.getFocusedItem();
  const { canDrag } = tree.getConfig();
  if (draggedItems && canDrag && !canDrag(draggedItems)) {
    return;
  }
  if (draggedItems) {
    tree.applySubStateUpdate("dnd", { draggedItems });
    (_b = (_a = tree.getConfig()).onStartKeyboardDrag) == null ? void 0 : _b.call(_a, draggedItems);
  } else if (dataTransfer) {
    tree.getDataRef().current.kDndDataTransfer = dataTransfer;
  }
  const dragTarget = getNextValidDragTarget(tree, false, {
    item: focusedItem
  });
  if (!dragTarget) return;
  tree.applySubStateUpdate("dnd", {
    draggedItems,
    dragTarget
  });
  tree.applySubStateUpdate("assistiveDndState", 1 /* Started */);
  updateScroll(tree);
};
var moveDragPosition = (tree, isUp) => {
  var _a;
  const dragTarget = getNextValidDragTarget(tree, isUp);
  if (!dragTarget) return;
  tree.applySubStateUpdate("dnd", {
    draggedItems: (_a = tree.getState().dnd) == null ? void 0 : _a.draggedItems,
    dragTarget
  });
  tree.applySubStateUpdate("assistiveDndState", 2 /* Dragging */);
  if (!isOrderedDragTarget(dragTarget)) {
    dragTarget.item.setFocused();
  }
  updateScroll(tree);
};
var keyboardDragAndDropFeature = {
  key: "keyboard-drag-and-drop",
  deps: ["drag-and-drop"],
  getDefaultConfig: (defaultConfig, tree) => __spreadValues({
    setAssistiveDndState: makeStateUpdater("assistiveDndState", tree)
  }, defaultConfig),
  stateHandlerNames: {
    assistiveDndState: "setAssistiveDndState"
  },
  treeInstance: {
    startKeyboardDrag: ({ tree }, draggedItems) => {
      initiateDrag(tree, draggedItems, void 0);
    },
    startKeyboardDragOnForeignObject: ({ tree }, dataTransfer) => {
      initiateDrag(tree, void 0, dataTransfer);
    },
    stopKeyboardDrag: ({ tree }) => {
      tree.getDataRef().current.kDndDataTransfer = void 0;
      tree.applySubStateUpdate("dnd", null);
      tree.applySubStateUpdate("assistiveDndState", 0 /* None */);
    }
  },
  hotkeys: {
    startDrag: {
      hotkey: "Control+Shift+KeyD",
      preventDefault: true,
      isEnabled: (tree) => !tree.getState().dnd,
      handler: (_, tree) => {
        var _a, _b;
        const selectedItems = (_b = (_a = tree.getSelectedItems) == null ? void 0 : _a.call(tree)) != null ? _b : [
          tree.getFocusedItem()
        ];
        const focusedItem = tree.getFocusedItem();
        tree.startKeyboardDrag(
          selectedItems.includes(focusedItem) ? selectedItems : selectedItems.concat(focusedItem)
        );
      }
    },
    dragUp: {
      hotkey: "ArrowUp",
      preventDefault: true,
      isEnabled: (tree) => !!tree.getState().dnd,
      handler: (_, tree) => {
        moveDragPosition(tree, true);
      }
    },
    dragDown: {
      hotkey: "ArrowDown",
      preventDefault: true,
      isEnabled: (tree) => !!tree.getState().dnd,
      handler: (_, tree) => {
        moveDragPosition(tree, false);
      }
    },
    cancelDrag: {
      hotkey: "Escape",
      isEnabled: (tree) => !!tree.getState().dnd,
      handler: (_, tree) => {
        tree.stopKeyboardDrag();
      }
    },
    completeDrag: {
      hotkey: "Enter",
      preventDefault: true,
      isEnabled: (tree) => !!tree.getState().dnd,
      handler: (e, tree) => __async(null, null, function* () {
        var _a, _b, _c, _d;
        e.stopPropagation();
        const dataRef = tree.getDataRef();
        const target = tree.getDragTarget();
        const dataTransfer = (_a = dataRef.current.kDndDataTransfer) != null ? _a : null;
        if (!target || !canDrop(dataTransfer, target, tree)) {
          return;
        }
        const config = tree.getConfig();
        const draggedItems = (_b = tree.getState().dnd) == null ? void 0 : _b.draggedItems;
        dataRef.current.lastDragCode = void 0;
        tree.applySubStateUpdate("dnd", null);
        if (draggedItems) {
          yield (_c = config.onDrop) == null ? void 0 : _c.call(config, draggedItems, target);
          tree.getItemInstance(draggedItems[0].getId()).setFocused();
        } else if (dataTransfer) {
          yield (_d = config.onDropForeignDragObject) == null ? void 0 : _d.call(config, dataTransfer, target);
        }
        tree.applySubStateUpdate(
          "assistiveDndState",
          3 /* Completed */
        );
      })
    }
  }
};

// src/features/search/feature.ts
var searchFeature = {
  key: "search",
  getInitialState: (initialState) => __spreadValues({
    search: null
  }, initialState),
  getDefaultConfig: (defaultConfig, tree) => __spreadValues({
    setSearch: makeStateUpdater("search", tree),
    isSearchMatchingItem: (search, item) => search.length > 0 && item.getItemName().toLowerCase().includes(search.toLowerCase())
  }, defaultConfig),
  stateHandlerNames: {
    search: "setSearch"
  },
  treeInstance: {
    setSearch: ({ tree }, search) => {
      var _a;
      tree.applySubStateUpdate("search", search);
      (_a = tree.getItems().find(
        (item) => {
          var _a2, _b;
          return (_b = (_a2 = tree.getConfig()).isSearchMatchingItem) == null ? void 0 : _b.call(_a2, tree.getSearchValue(), item);
        }
      )) == null ? void 0 : _a.setFocused();
    },
    openSearch: ({ tree }, initialValue = "") => {
      var _a, _b;
      tree.setSearch(initialValue);
      (_b = (_a = tree.getConfig()).onOpenSearch) == null ? void 0 : _b.call(_a);
      setTimeout(() => {
        var _a2;
        (_a2 = tree.getDataRef().current.searchInput) == null ? void 0 : _a2.focus();
      });
    },
    closeSearch: ({ tree }) => {
      var _a, _b;
      tree.setSearch(null);
      (_b = (_a = tree.getConfig()).onCloseSearch) == null ? void 0 : _b.call(_a);
      tree.updateDomFocus();
    },
    isSearchOpen: ({ tree }) => tree.getState().search !== null,
    getSearchValue: ({ tree }) => tree.getState().search || "",
    registerSearchInputElement: ({ tree }, element) => {
      const dataRef = tree.getDataRef();
      dataRef.current.searchInput = element;
      if (element && dataRef.current.keydownHandler) {
        element.addEventListener("keydown", dataRef.current.keydownHandler);
      }
    },
    getSearchInputElement: ({ tree }) => {
      var _a;
      return (_a = tree.getDataRef().current.searchInput) != null ? _a : null;
    },
    // TODO memoize with propMemoizationFeature
    getSearchInputElementProps: ({ tree }) => ({
      value: tree.getSearchValue(),
      onChange: (e) => tree.setSearch(e.target.value),
      onBlur: () => tree.closeSearch(),
      ref: tree.registerSearchInputElement
    }),
    getSearchMatchingItems: memo(
      ({ tree }) => [
        tree.getSearchValue(),
        tree.getItems(),
        tree.getConfig().isSearchMatchingItem
      ],
      (search, items, isSearchMatchingItem) => items.filter((item) => search && (isSearchMatchingItem == null ? void 0 : isSearchMatchingItem(search, item)))
    )
  },
  itemInstance: {
    isMatchingSearch: ({ tree, item }) => tree.getSearchMatchingItems().some((i) => i.getId() === item.getId())
  },
  hotkeys: {
    openSearch: {
      hotkey: "LetterOrNumber",
      preventDefault: true,
      // TODO make true default
      isEnabled: (tree) => !tree.isSearchOpen(),
      handler: (e, tree) => {
        e.stopPropagation();
        tree.openSearch(e.key);
      }
    },
    closeSearch: {
      // TODO allow multiple, i.e. Enter
      hotkey: "Escape",
      allowWhenInputFocused: true,
      isEnabled: (tree) => tree.isSearchOpen(),
      handler: (e, tree) => {
        tree.closeSearch();
      }
    },
    submitSearch: {
      hotkey: "Enter",
      allowWhenInputFocused: true,
      isEnabled: (tree) => tree.isSearchOpen(),
      handler: (e, tree) => {
        tree.closeSearch();
        tree.setSelectedItems([tree.getFocusedItem().getId()]);
      }
    },
    nextSearchItem: {
      hotkey: "ArrowDown",
      allowWhenInputFocused: true,
      canRepeat: true,
      isEnabled: (tree) => tree.isSearchOpen(),
      handler: (e, tree) => {
        const focusItem = tree.getSearchMatchingItems().find(
          (item) => item.getItemMeta().index > tree.getFocusedItem().getItemMeta().index
        );
        focusItem == null ? void 0 : focusItem.setFocused();
        focusItem == null ? void 0 : focusItem.scrollTo({ block: "nearest", inline: "nearest" });
      }
    },
    previousSearchItem: {
      hotkey: "ArrowUp",
      allowWhenInputFocused: true,
      canRepeat: true,
      isEnabled: (tree) => tree.isSearchOpen(),
      handler: (e, tree) => {
        const focusItem = [...tree.getSearchMatchingItems()].reverse().find(
          (item) => item.getItemMeta().index < tree.getFocusedItem().getItemMeta().index
        );
        focusItem == null ? void 0 : focusItem.setFocused();
        focusItem == null ? void 0 : focusItem.scrollTo({ block: "nearest", inline: "nearest" });
      }
    }
  }
};

// src/features/renaming/feature.ts
var renamingFeature = {
  key: "renaming",
  overwrites: ["drag-and-drop"],
  getDefaultConfig: (defaultConfig, tree) => __spreadValues({
    setRenamingItem: makeStateUpdater("renamingItem", tree),
    setRenamingValue: makeStateUpdater("renamingValue", tree),
    canRename: () => true
  }, defaultConfig),
  stateHandlerNames: {
    renamingItem: "setRenamingItem",
    renamingValue: "setRenamingValue"
  },
  treeInstance: {
    getRenamingItem: ({ tree }) => {
      const itemId = tree.getState().renamingItem;
      return itemId ? tree.getItemInstance(itemId) : null;
    },
    getRenamingValue: ({ tree }) => tree.getState().renamingValue || "",
    abortRenaming: ({ tree }) => {
      tree.applySubStateUpdate("renamingItem", null);
      tree.updateDomFocus();
    },
    completeRenaming: ({ tree }) => {
      var _a;
      const config = tree.getConfig();
      const item = tree.getRenamingItem();
      if (item) {
        (_a = config.onRename) == null ? void 0 : _a.call(config, item, tree.getState().renamingValue || "");
      }
      tree.applySubStateUpdate("renamingItem", null);
      tree.updateDomFocus();
    },
    isRenamingItem: ({ tree }) => !!tree.getState().renamingItem
  },
  itemInstance: {
    startRenaming: ({ tree, item, itemId }) => {
      if (!item.canRename()) {
        return;
      }
      tree.applySubStateUpdate("renamingItem", itemId);
      tree.applySubStateUpdate("renamingValue", item.getItemName());
    },
    getRenameInputProps: ({ tree }) => ({
      ref: (r) => r == null ? void 0 : r.focus(),
      onBlur: () => tree.abortRenaming(),
      value: tree.getRenamingValue(),
      onChange: (e) => {
        var _a;
        tree.applySubStateUpdate("renamingValue", (_a = e.target) == null ? void 0 : _a.value);
      }
    }),
    canRename: ({ tree, item }) => {
      var _a, _b, _c;
      return (_c = (_b = (_a = tree.getConfig()).canRename) == null ? void 0 : _b.call(_a, item)) != null ? _c : true;
    },
    isRenaming: ({ tree, item }) => item.getId() === tree.getState().renamingItem,
    getProps: ({ prev, item }) => {
      var _a;
      const isRenaming = item.isRenaming();
      const prevProps = (_a = prev == null ? void 0 : prev()) != null ? _a : {};
      return isRenaming ? __spreadProps(__spreadValues({}, prevProps), {
        draggable: false,
        onDragStart: () => {
        }
      }) : prevProps;
    }
  },
  hotkeys: {
    renameItem: {
      hotkey: "F2",
      handler: (e, tree) => {
        tree.getFocusedItem().startRenaming();
      }
    },
    abortRenaming: {
      hotkey: "Escape",
      allowWhenInputFocused: true,
      isEnabled: (tree) => tree.isRenamingItem(),
      handler: (e, tree) => {
        tree.abortRenaming();
      }
    },
    completeRenaming: {
      hotkey: "Enter",
      allowWhenInputFocused: true,
      isEnabled: (tree) => tree.isRenamingItem(),
      handler: (e, tree) => {
        tree.completeRenaming();
      }
    }
  }
};

// src/features/expand-all/feature.ts
var expandAllFeature = {
  key: "expand-all",
  treeInstance: {
    expandAll: (_0, _1) => __async(null, [_0, _1], function* ({ tree }, cancelToken) {
      yield Promise.all(
        tree.getItems().map((item) => item.expandAll(cancelToken))
      );
    }),
    collapseAll: ({ tree }) => {
      tree.applySubStateUpdate("expandedItems", []);
      tree.rebuildTree();
    }
  },
  itemInstance: {
    expandAll: (_0, _1) => __async(null, [_0, _1], function* ({ tree, item }, cancelToken) {
      if (cancelToken == null ? void 0 : cancelToken.current) {
        return;
      }
      if (!item.isFolder()) {
        return;
      }
      item.expand();
      yield tree.waitForItemChildrenLoaded(item.getId());
      yield Promise.all(
        item.getChildren().map((child) => __async(null, null, function* () {
          yield tree.waitForItemChildrenLoaded(item.getId());
          yield child == null ? void 0 : child.expandAll(cancelToken);
        }))
      );
    }),
    collapseAll: ({ item }) => {
      if (!item.isExpanded()) return;
      for (const child of item.getChildren()) {
        child == null ? void 0 : child.collapseAll();
      }
      item.collapse();
    }
  },
  hotkeys: {
    expandSelected: {
      hotkey: "Control+Shift+Plus",
      handler: (_, tree) => __async(null, null, function* () {
        const cancelToken = { current: false };
        const cancelHandler = (e) => {
          if (e.code === "Escape") {
            cancelToken.current = true;
          }
        };
        document.addEventListener("keydown", cancelHandler);
        yield Promise.all(
          tree.getSelectedItems().map((item) => item.expandAll(cancelToken))
        );
        document.removeEventListener("keydown", cancelHandler);
      })
    },
    collapseSelected: {
      hotkey: "Control+Shift+Minus",
      handler: (_, tree) => {
        tree.getSelectedItems().forEach((item) => item.collapseAll());
      }
    }
  }
};

// src/features/prop-memoization/feature.ts
var memoize = (props, memoizedProps) => {
  for (const key in props) {
    if (typeof props[key] === "function") {
      if (memoizedProps && key in memoizedProps) {
        props[key] = memoizedProps[key];
      } else {
        memoizedProps[key] = props[key];
      }
    }
  }
  return props;
};
var propMemoizationFeature = {
  key: "prop-memoization",
  overwrites: [
    "main",
    "async-data-loader",
    "sync-data-loader",
    "drag-and-drop",
    "expand-all",
    "hotkeys-core",
    "renaming",
    "search",
    "selection"
  ],
  treeInstance: {
    getContainerProps: ({ tree, prev }, treeLabel) => {
      var _a, _b, _c, _d, _e;
      const dataRef = tree.getDataRef();
      const props = (_a = prev == null ? void 0 : prev(treeLabel)) != null ? _a : {};
      (_c = (_b = dataRef.current).memo) != null ? _c : _b.memo = {};
      (_e = (_d = dataRef.current.memo).tree) != null ? _e : _d.tree = {};
      return memoize(props, dataRef.current.memo.tree);
    },
    getSearchInputElementProps: ({ tree, prev }) => {
      var _a, _b, _c, _d, _e;
      const dataRef = tree.getDataRef();
      const props = (_a = prev == null ? void 0 : prev()) != null ? _a : {};
      (_c = (_b = dataRef.current).memo) != null ? _c : _b.memo = {};
      (_e = (_d = dataRef.current.memo).search) != null ? _e : _d.search = {};
      return memoize(props, dataRef.current.memo.search);
    }
  },
  itemInstance: {
    getProps: ({ item, prev }) => {
      var _a, _b, _c, _d, _e;
      const dataRef = item.getDataRef();
      const props = (_a = prev == null ? void 0 : prev()) != null ? _a : {};
      (_c = (_b = dataRef.current).memo) != null ? _c : _b.memo = {};
      (_e = (_d = dataRef.current.memo).item) != null ? _e : _d.item = {};
      return memoize(props, dataRef.current.memo.item);
    },
    getRenameInputProps: ({ item, prev }) => {
      var _a, _b, _c, _d, _e;
      const dataRef = item.getDataRef();
      const props = (_a = prev == null ? void 0 : prev()) != null ? _a : {};
      (_c = (_b = dataRef.current).memo) != null ? _c : _b.memo = {};
      (_e = (_d = dataRef.current.memo).rename) != null ? _e : _d.rename = {};
      return memoize(props, dataRef.current.memo.rename);
    }
  }
};

// src/utilities/remove-items-from-parents.ts
var removeItemsFromParents = (movedItems, onChangeChildren) => __async(null, null, function* () {
  const movedItemsIds = movedItems.map((item) => item.getId());
  const uniqueParents = [
    ...new Set(movedItems.map((item) => item.getParent()))
  ];
  for (const parent of uniqueParents) {
    const siblings = parent == null ? void 0 : parent.getChildren();
    if (siblings && parent) {
      const newChildren = siblings.filter((sibling) => !movedItemsIds.includes(sibling.getId())).map((i) => i.getId());
      yield onChangeChildren(parent, newChildren);
      if (parent && "updateCachedChildrenIds" in parent) {
        parent == null ? void 0 : parent.updateCachedChildrenIds(newChildren);
      }
    }
  }
  movedItems[0].getTree().rebuildTree();
});

// src/utilities/insert-items-at-target.ts
var insertItemsAtTarget = (itemIds, target, onChangeChildren) => __async(null, null, function* () {
  yield target.item.getTree().waitForItemChildrenLoaded(target.item.getId());
  const oldChildrenIds = target.item.getTree().retrieveChildrenIds(target.item.getId());
  if (!("childIndex" in target)) {
    const newChildren2 = [...oldChildrenIds, ...itemIds];
    yield onChangeChildren(target.item, newChildren2);
    if (target.item && "updateCachedChildrenIds" in target.item) {
      target.item.updateCachedChildrenIds(newChildren2);
    }
    target.item.getTree().rebuildTree();
    return;
  }
  const newChildren = [
    ...oldChildrenIds.slice(0, target.insertionIndex),
    ...itemIds,
    ...oldChildrenIds.slice(target.insertionIndex)
  ];
  yield onChangeChildren(target.item, newChildren);
  if (target.item && "updateCachedChildrenIds" in target.item) {
    target.item.updateCachedChildrenIds(newChildren);
  }
  target.item.getTree().rebuildTree();
});

// src/utilities/create-on-drop-handler.ts
var createOnDropHandler = (onChangeChildren) => (items, target) => __async(null, null, function* () {
  const itemIds = items.map((item) => item.getId());
  yield removeItemsFromParents(items, onChangeChildren);
  yield insertItemsAtTarget(itemIds, target, onChangeChildren);
});

// src/core/build-proxified-instance.ts
var noop = () => {
};
var findPrevInstanceMethod = (features, instanceType, methodKey, featureSearchIndex) => {
  var _a;
  for (let i = featureSearchIndex; i >= 0; i--) {
    const feature = features[i];
    const itemInstanceMethod = (_a = feature[instanceType]) == null ? void 0 : _a[methodKey];
    if (itemInstanceMethod) {
      return i;
    }
  }
  return null;
};
var invokeInstanceMethod = (features, instanceType, opts, methodKey, featureIndex, args) => {
  var _a;
  const prevIndex = findPrevInstanceMethod(
    features,
    instanceType,
    methodKey,
    featureIndex - 1
  );
  const itemInstanceMethod = (_a = features[featureIndex][instanceType]) == null ? void 0 : _a[methodKey];
  return itemInstanceMethod(
    __spreadProps(__spreadValues({}, opts), {
      prev: prevIndex !== null ? (...newArgs) => invokeInstanceMethod(
        features,
        instanceType,
        opts,
        methodKey,
        prevIndex,
        newArgs
      ) : null
    }),
    ...args
  );
};
var buildProxiedInstance = (features, instanceType, buildOpts) => {
  const opts = {};
  const item = new Proxy(
    {},
    {
      has(target, key) {
        if (typeof key === "symbol") {
          return false;
        }
        if (key === "toJSON") {
          return false;
        }
        const hasInstanceMethod = findPrevInstanceMethod(
          features,
          instanceType,
          key,
          features.length - 1
        );
        return Boolean(hasInstanceMethod);
      },
      get(target, key) {
        if (typeof key === "symbol") {
          return void 0;
        }
        if (key === "toJSON") {
          return {};
        }
        return (...args) => {
          const featureIndex = findPrevInstanceMethod(
            features,
            instanceType,
            key,
            features.length - 1
          );
          if (featureIndex === null) {
            throw throwError(`feature missing for method ${key}`);
          }
          return invokeInstanceMethod(
            features,
            instanceType,
            opts,
            key,
            featureIndex,
            args
          );
        };
      }
    }
  );
  Object.assign(opts, buildOpts(item));
  return [item, noop];
};
export {
  AssistiveDndState,
  CheckedState,
  DragTargetPosition,
  asyncDataLoaderFeature,
  buildProxiedInstance,
  buildStaticInstance,
  checkboxesFeature,
  createOnDropHandler,
  createTree,
  dragAndDropFeature,
  expandAllFeature,
  hotkeysCoreFeature,
  insertItemsAtTarget,
  isOrderedDragTarget,
  keyboardDragAndDropFeature,
  makeStateUpdater,
  propMemoizationFeature,
  removeItemsFromParents,
  renamingFeature,
  searchFeature,
  selectionFeature,
  syncDataLoaderFeature
};

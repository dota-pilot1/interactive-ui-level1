/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/headless-tree/level-1/page"],{

/***/ "(app-pages-browser)/./node_modules/@headless-tree/core/dist/index.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@headless-tree/core/dist/index.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AssistiveDndState: () => (/* binding */ AssistiveDndState),\n/* harmony export */   CheckedState: () => (/* binding */ CheckedState),\n/* harmony export */   DragTargetPosition: () => (/* binding */ DragTargetPosition),\n/* harmony export */   asyncDataLoaderFeature: () => (/* binding */ asyncDataLoaderFeature),\n/* harmony export */   buildProxiedInstance: () => (/* binding */ buildProxiedInstance),\n/* harmony export */   buildStaticInstance: () => (/* binding */ buildStaticInstance),\n/* harmony export */   checkboxesFeature: () => (/* binding */ checkboxesFeature),\n/* harmony export */   createOnDropHandler: () => (/* binding */ createOnDropHandler),\n/* harmony export */   createTree: () => (/* binding */ createTree),\n/* harmony export */   dragAndDropFeature: () => (/* binding */ dragAndDropFeature),\n/* harmony export */   expandAllFeature: () => (/* binding */ expandAllFeature),\n/* harmony export */   hotkeysCoreFeature: () => (/* binding */ hotkeysCoreFeature),\n/* harmony export */   insertItemsAtTarget: () => (/* binding */ insertItemsAtTarget),\n/* harmony export */   isOrderedDragTarget: () => (/* binding */ isOrderedDragTarget),\n/* harmony export */   keyboardDragAndDropFeature: () => (/* binding */ keyboardDragAndDropFeature),\n/* harmony export */   makeStateUpdater: () => (/* binding */ makeStateUpdater),\n/* harmony export */   propMemoizationFeature: () => (/* binding */ propMemoizationFeature),\n/* harmony export */   removeItemsFromParents: () => (/* binding */ removeItemsFromParents),\n/* harmony export */   renamingFeature: () => (/* binding */ renamingFeature),\n/* harmony export */   searchFeature: () => (/* binding */ searchFeature),\n/* harmony export */   selectionFeature: () => (/* binding */ selectionFeature),\n/* harmony export */   syncDataLoaderFeature: () => (/* binding */ syncDataLoaderFeature)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/utils.ts\nvar memo = (deps, fn) => {\n  let value;\n  let oldDeps = null;\n  return (...a) => {\n    const newDeps = deps(...a);\n    if (!value) {\n      value = fn(...newDeps);\n      oldDeps = newDeps;\n      return value;\n    }\n    const match = oldDeps && oldDeps.length === newDeps.length && !oldDeps.some((dep, i) => dep !== newDeps[i]);\n    if (match) {\n      return value;\n    }\n    value = fn(...newDeps);\n    oldDeps = newDeps;\n    return value;\n  };\n};\nfunction functionalUpdate(updater, input) {\n  return typeof updater === \"function\" ? updater(input) : updater;\n}\nfunction makeStateUpdater(key, instance) {\n  return (updater) => {\n    instance.setState((old) => {\n      return __spreadProps(__spreadValues({}, old), {\n        [key]: functionalUpdate(updater, old[key])\n      });\n    });\n  };\n}\nvar poll = (fn, interval = 100, timeout = 1e3) => new Promise((resolve) => {\n  let clear;\n  const i = setInterval(() => {\n    if (fn()) {\n      resolve();\n      clearInterval(i);\n      clearTimeout(clear);\n    }\n  }, interval);\n  clear = setTimeout(() => {\n    clearInterval(i);\n  }, timeout);\n});\n\n// src/utilities/errors.ts\nvar prefix = \"Headless Tree: \";\nvar throwError = (message) => Error(prefix + message);\nvar logWarning = (message) => console.warn(prefix + message);\n\n// src/features/tree/feature.ts\nvar treeFeature = {\n  key: \"tree\",\n  getInitialState: (initialState) => __spreadValues({\n    expandedItems: [],\n    focusedItem: null\n  }, initialState),\n  getDefaultConfig: (defaultConfig, tree) => __spreadValues({\n    setExpandedItems: makeStateUpdater(\"expandedItems\", tree),\n    setFocusedItem: makeStateUpdater(\"focusedItem\", tree)\n  }, defaultConfig),\n  stateHandlerNames: {\n    expandedItems: \"setExpandedItems\",\n    focusedItem: \"setFocusedItem\"\n  },\n  treeInstance: {\n    getItemsMeta: ({ tree }) => {\n      const { rootItemId } = tree.getConfig();\n      const { expandedItems } = tree.getState();\n      const flatItems = [];\n      const expandedItemsSet = new Set(expandedItems);\n      const recursiveAdd = (itemId, path, level, setSize, posInSet) => {\n        var _a;\n        if (path.includes(itemId)) {\n          logWarning(`Circular reference for ${path.join(\".\")}`);\n          return;\n        }\n        flatItems.push({\n          itemId,\n          level,\n          index: flatItems.length,\n          parentId: path.at(-1),\n          setSize,\n          posInSet\n        });\n        if (expandedItemsSet.has(itemId)) {\n          const children2 = (_a = tree.retrieveChildrenIds(itemId)) != null ? _a : [];\n          let i2 = 0;\n          for (const childId of children2) {\n            recursiveAdd(\n              childId,\n              path.concat(itemId),\n              level + 1,\n              children2.length,\n              i2++\n            );\n          }\n        }\n      };\n      const children = tree.retrieveChildrenIds(rootItemId);\n      let i = 0;\n      for (const itemId of children) {\n        recursiveAdd(itemId, [rootItemId], 0, children.length, i++);\n      }\n      return flatItems;\n    },\n    getFocusedItem: ({ tree }) => {\n      var _a;\n      const focusedItemId = tree.getState().focusedItem;\n      return (_a = focusedItemId !== null ? tree.getItemInstance(focusedItemId) : null) != null ? _a : tree.getItems()[0];\n    },\n    getRootItem: ({ tree }) => {\n      const { rootItemId } = tree.getConfig();\n      return tree.getItemInstance(rootItemId);\n    },\n    focusNextItem: ({ tree }) => {\n      var _a;\n      const focused = tree.getFocusedItem().getItemMeta();\n      if (!focused) return;\n      const nextIndex = Math.min(focused.index + 1, tree.getItems().length - 1);\n      (_a = tree.getItems()[nextIndex]) == null ? void 0 : _a.setFocused();\n    },\n    focusPreviousItem: ({ tree }) => {\n      var _a;\n      const focused = tree.getFocusedItem().getItemMeta();\n      if (!focused) return;\n      const nextIndex = Math.max(focused.index - 1, 0);\n      (_a = tree.getItems()[nextIndex]) == null ? void 0 : _a.setFocused();\n    },\n    updateDomFocus: ({ tree }) => {\n      setTimeout(() => __async(null, null, function* () {\n        var _a, _b;\n        const focusedItem = tree.getFocusedItem();\n        (_b = (_a = tree.getConfig()).scrollToItem) == null ? void 0 : _b.call(_a, focusedItem);\n        yield poll(() => focusedItem.getElement() !== null, 20);\n        const focusedElement = focusedItem.getElement();\n        if (!focusedElement) return;\n        focusedElement.focus();\n      }));\n    },\n    getContainerProps: ({ prev, tree }, treeLabel) => __spreadProps(__spreadValues({}, prev == null ? void 0 : prev()), {\n      role: \"tree\",\n      \"aria-label\": treeLabel != null ? treeLabel : \"\",\n      ref: tree.registerElement\n    }),\n    // relevant for hotkeys of this feature\n    isSearchOpen: () => false\n  },\n  itemInstance: {\n    scrollTo: (_0, _1) => __async(null, [_0, _1], function* ({ tree, item }, scrollIntoViewArg) {\n      var _a, _b, _c;\n      (_b = (_a = tree.getConfig()).scrollToItem) == null ? void 0 : _b.call(_a, item);\n      yield poll(() => item.getElement() !== null, 20);\n      (_c = item.getElement()) == null ? void 0 : _c.scrollIntoView(scrollIntoViewArg);\n    }),\n    getId: ({ itemId }) => itemId,\n    getKey: ({ itemId }) => itemId,\n    // TODO apply to all stories to use\n    getProps: ({ item, prev }) => {\n      const itemMeta = item.getItemMeta();\n      return __spreadProps(__spreadValues({}, prev == null ? void 0 : prev()), {\n        ref: item.registerElement,\n        role: \"treeitem\",\n        \"aria-setsize\": itemMeta.setSize,\n        \"aria-posinset\": itemMeta.posInSet + 1,\n        \"aria-selected\": \"false\",\n        \"aria-label\": item.getItemName(),\n        \"aria-level\": itemMeta.level + 1,\n        tabIndex: item.isFocused() ? 0 : -1,\n        onClick: (e) => {\n          item.setFocused();\n          item.primaryAction();\n          if (e.ctrlKey || e.shiftKey || e.metaKey) {\n            return;\n          }\n          if (!item.isFolder()) {\n            return;\n          }\n          if (item.isExpanded()) {\n            item.collapse();\n          } else {\n            item.expand();\n          }\n        }\n      });\n    },\n    expand: ({ tree, item, itemId }) => {\n      var _a;\n      if (!item.isFolder()) {\n        return;\n      }\n      if ((_a = tree.getState().loadingItemChildrens) == null ? void 0 : _a.includes(itemId)) {\n        return;\n      }\n      tree.applySubStateUpdate(\"expandedItems\", (expandedItems) => [\n        ...expandedItems,\n        itemId\n      ]);\n      tree.rebuildTree();\n    },\n    collapse: ({ tree, item, itemId }) => {\n      if (!item.isFolder()) {\n        return;\n      }\n      tree.applySubStateUpdate(\n        \"expandedItems\",\n        (expandedItems) => expandedItems.filter((id) => id !== itemId)\n      );\n      tree.rebuildTree();\n    },\n    getItemData: ({ tree, itemId }) => tree.retrieveItemData(itemId),\n    equals: ({ item }, other) => item.getId() === (other == null ? void 0 : other.getId()),\n    isExpanded: ({ tree, itemId }) => tree.getState().expandedItems.includes(itemId),\n    isDescendentOf: ({ item }, parentId) => {\n      const parent = item.getParent();\n      return Boolean(\n        (parent == null ? void 0 : parent.getId()) === parentId || (parent == null ? void 0 : parent.isDescendentOf(parentId))\n      );\n    },\n    isFocused: ({ tree, item, itemId }) => tree.getState().focusedItem === itemId || tree.getState().focusedItem === null && item.getItemMeta().index === 0,\n    isFolder: ({ tree, item }) => item.getItemMeta().level === -1 || tree.getConfig().isItemFolder(item),\n    getItemName: ({ tree, item }) => {\n      const config = tree.getConfig();\n      return config.getItemName(item);\n    },\n    setFocused: ({ tree, itemId }) => {\n      tree.applySubStateUpdate(\"focusedItem\", itemId);\n    },\n    primaryAction: ({ tree, item }) => {\n      var _a, _b;\n      return (_b = (_a = tree.getConfig()).onPrimaryAction) == null ? void 0 : _b.call(_a, item);\n    },\n    getParent: ({ tree, item }) => item.getItemMeta().parentId ? tree.getItemInstance(item.getItemMeta().parentId) : void 0,\n    getIndexInParent: ({ item }) => item.getItemMeta().posInSet,\n    getChildren: ({ tree, itemId }) => tree.retrieveChildrenIds(itemId).map((id) => tree.getItemInstance(id)),\n    getTree: ({ tree }) => tree,\n    getItemAbove: ({ tree, item }) => tree.getItems()[item.getItemMeta().index - 1],\n    getItemBelow: ({ tree, item }) => tree.getItems()[item.getItemMeta().index + 1]\n  },\n  hotkeys: {\n    focusNextItem: {\n      hotkey: \"ArrowDown\",\n      canRepeat: true,\n      preventDefault: true,\n      isEnabled: (tree) => {\n        var _a, _b;\n        return !((_b = (_a = tree.isSearchOpen) == null ? void 0 : _a.call(tree)) != null ? _b : false) && !tree.getState().dnd;\n      },\n      // TODO what happens when the feature doesnt exist? proxy method still claims to exist\n      handler: (e, tree) => {\n        tree.focusNextItem();\n        tree.updateDomFocus();\n      }\n    },\n    focusPreviousItem: {\n      hotkey: \"ArrowUp\",\n      canRepeat: true,\n      preventDefault: true,\n      isEnabled: (tree) => {\n        var _a, _b;\n        return !((_b = (_a = tree.isSearchOpen) == null ? void 0 : _a.call(tree)) != null ? _b : false) && !tree.getState().dnd;\n      },\n      handler: (e, tree) => {\n        tree.focusPreviousItem();\n        tree.updateDomFocus();\n      }\n    },\n    expandOrDown: {\n      hotkey: \"ArrowRight\",\n      canRepeat: true,\n      handler: (e, tree) => {\n        const item = tree.getFocusedItem();\n        if (item.isExpanded() || !item.isFolder()) {\n          tree.focusNextItem();\n          tree.updateDomFocus();\n        } else {\n          item.expand();\n        }\n      }\n    },\n    collapseOrUp: {\n      hotkey: \"ArrowLeft\",\n      canRepeat: true,\n      handler: (e, tree) => {\n        var _a;\n        const item = tree.getFocusedItem();\n        if ((!item.isExpanded() || !item.isFolder()) && item.getItemMeta().level !== 0) {\n          (_a = item.getParent()) == null ? void 0 : _a.setFocused();\n          tree.updateDomFocus();\n        } else {\n          item.collapse();\n        }\n      }\n    },\n    focusFirstItem: {\n      hotkey: \"Home\",\n      handler: (e, tree) => {\n        var _a;\n        (_a = tree.getItems()[0]) == null ? void 0 : _a.setFocused();\n        tree.updateDomFocus();\n      }\n    },\n    focusLastItem: {\n      hotkey: \"End\",\n      handler: (e, tree) => {\n        var _a;\n        (_a = tree.getItems()[tree.getItems().length - 1]) == null ? void 0 : _a.setFocused();\n        tree.updateDomFocus();\n      }\n    }\n  }\n};\n\n// src/core/build-static-instance.ts\nvar buildStaticInstance = (features, instanceType, buildOpts) => {\n  const instance = {};\n  const finalize = () => {\n    const opts = buildOpts(instance);\n    featureLoop: for (let i = 0; i < features.length; i++) {\n      const definition = features[i][instanceType];\n      if (!definition) continue featureLoop;\n      methodLoop: for (const [key, method] of Object.entries(definition)) {\n        if (!method) continue methodLoop;\n        const prev = instance[key];\n        instance[key] = (...args) => {\n          return method(__spreadProps(__spreadValues({}, opts), { prev }), ...args);\n        };\n      }\n    }\n  };\n  return [instance, finalize];\n};\n\n// src/core/create-tree.ts\nvar verifyFeatures = (features) => {\n  var _a;\n  const loadedFeatures = features == null ? void 0 : features.map((feature) => feature.key);\n  for (const feature of features != null ? features : []) {\n    const missingDependency = (_a = feature.deps) == null ? void 0 : _a.find(\n      (dep) => !(loadedFeatures == null ? void 0 : loadedFeatures.includes(dep))\n    );\n    if (missingDependency) {\n      throw throwError(`${feature.key} needs ${missingDependency}`);\n    }\n  }\n};\nvar exhaustiveSort = (arr, compareFn) => {\n  const n = arr.length;\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      if (compareFn(arr[j], arr[i]) < 0) {\n        [arr[i], arr[j]] = [arr[j], arr[i]];\n      }\n    }\n  }\n  return arr;\n};\nvar compareFeatures = (originalOrder) => (feature1, feature2) => {\n  var _a, _b;\n  if (feature2.key && ((_a = feature1.overwrites) == null ? void 0 : _a.includes(feature2.key))) {\n    return 1;\n  }\n  if (feature1.key && ((_b = feature2.overwrites) == null ? void 0 : _b.includes(feature1.key))) {\n    return -1;\n  }\n  return originalOrder.indexOf(feature1) - originalOrder.indexOf(feature2);\n};\nvar sortFeatures = (features = []) => exhaustiveSort(features, compareFeatures(features));\nvar createTree = (initialConfig) => {\n  var _a, _b, _c, _d;\n  const buildInstance = (_a = initialConfig.instanceBuilder) != null ? _a : buildStaticInstance;\n  const additionalFeatures = [\n    treeFeature,\n    ...sortFeatures(initialConfig.features)\n  ];\n  verifyFeatures(additionalFeatures);\n  const features = [...additionalFeatures];\n  const [treeInstance, finalizeTree] = buildInstance(\n    features,\n    \"treeInstance\",\n    (tree) => ({ tree })\n  );\n  let state = additionalFeatures.reduce(\n    (acc, feature) => {\n      var _a2, _b2;\n      return (_b2 = (_a2 = feature.getInitialState) == null ? void 0 : _a2.call(feature, acc, treeInstance)) != null ? _b2 : acc;\n    },\n    (_c = (_b = initialConfig.initialState) != null ? _b : initialConfig.state) != null ? _c : {}\n  );\n  let config = additionalFeatures.reduce(\n    (acc, feature) => {\n      var _a2, _b2;\n      return (_b2 = (_a2 = feature.getDefaultConfig) == null ? void 0 : _a2.call(feature, acc, treeInstance)) != null ? _b2 : acc;\n    },\n    initialConfig\n  );\n  const stateHandlerNames = additionalFeatures.reduce(\n    (acc, feature) => __spreadValues(__spreadValues({}, acc), feature.stateHandlerNames),\n    {}\n  );\n  let treeElement;\n  const treeDataRef = { current: {} };\n  const itemInstancesMap = {};\n  let itemInstances = [];\n  const itemElementsMap = {};\n  const itemDataRefs = {};\n  let itemMetaMap = {};\n  const hotkeyPresets = {};\n  const rebuildItemMeta = () => {\n    itemInstances = [];\n    itemMetaMap = {};\n    const [rootInstance, finalizeRootInstance] = buildInstance(\n      features,\n      \"itemInstance\",\n      (item) => ({ item, tree: treeInstance, itemId: config.rootItemId })\n    );\n    finalizeRootInstance();\n    itemInstancesMap[config.rootItemId] = rootInstance;\n    itemMetaMap[config.rootItemId] = {\n      itemId: config.rootItemId,\n      index: -1,\n      parentId: null,\n      level: -1,\n      posInSet: 0,\n      setSize: 1\n    };\n    for (const item of treeInstance.getItemsMeta()) {\n      itemMetaMap[item.itemId] = item;\n      if (!itemInstancesMap[item.itemId]) {\n        const [instance, finalizeInstance] = buildInstance(\n          features,\n          \"itemInstance\",\n          (instance2) => ({\n            item: instance2,\n            tree: treeInstance,\n            itemId: item.itemId\n          })\n        );\n        finalizeInstance();\n        itemInstancesMap[item.itemId] = instance;\n        itemInstances.push(instance);\n      } else {\n        itemInstances.push(itemInstancesMap[item.itemId]);\n      }\n    }\n  };\n  const eachFeature = (fn) => {\n    for (const feature of additionalFeatures) {\n      fn(feature);\n    }\n  };\n  const mainFeature = {\n    key: \"main\",\n    treeInstance: {\n      getState: () => state,\n      setState: ({}, updater) => {\n        var _a2;\n        (_a2 = config.setState) == null ? void 0 : _a2.call(config, state);\n      },\n      applySubStateUpdate: ({}, stateName, updater) => {\n        state[stateName] = typeof updater === \"function\" ? updater(state[stateName]) : updater;\n        const externalStateSetter = config[stateHandlerNames[stateName]];\n        externalStateSetter == null ? void 0 : externalStateSetter(state[stateName]);\n      },\n      // TODO rebuildSubTree: (itemId: string) => void;\n      rebuildTree: () => {\n        var _a2;\n        rebuildItemMeta();\n        (_a2 = config.setState) == null ? void 0 : _a2.call(config, state);\n      },\n      getConfig: () => config,\n      setConfig: (_, updater) => {\n        var _a2, _b2, _c2;\n        const newConfig = typeof updater === \"function\" ? updater(config) : updater;\n        const hasChangedExpandedItems = ((_a2 = newConfig.state) == null ? void 0 : _a2.expandedItems) && ((_b2 = newConfig.state) == null ? void 0 : _b2.expandedItems) !== state.expandedItems;\n        config = newConfig;\n        if (newConfig.state) {\n          state = __spreadValues(__spreadValues({}, state), newConfig.state);\n        }\n        if (hasChangedExpandedItems) {\n          rebuildItemMeta();\n          (_c2 = config.setState) == null ? void 0 : _c2.call(config, state);\n        }\n      },\n      getItemInstance: ({}, itemId) => {\n        const existingInstance = itemInstancesMap[itemId];\n        if (!existingInstance) {\n          const [instance, finalizeInstance] = buildInstance(\n            features,\n            \"itemInstance\",\n            (instance2) => ({\n              item: instance2,\n              tree: treeInstance,\n              itemId\n            })\n          );\n          finalizeInstance();\n          return instance;\n        }\n        return existingInstance;\n      },\n      getItems: () => itemInstances,\n      registerElement: ({}, element) => {\n        if (treeElement === element) {\n          return;\n        }\n        if (treeElement && !element) {\n          eachFeature(\n            (feature) => {\n              var _a2;\n              return (_a2 = feature.onTreeUnmount) == null ? void 0 : _a2.call(feature, treeInstance, treeElement);\n            }\n          );\n        } else if (!treeElement && element) {\n          eachFeature(\n            (feature) => {\n              var _a2;\n              return (_a2 = feature.onTreeMount) == null ? void 0 : _a2.call(feature, treeInstance, element);\n            }\n          );\n        }\n        treeElement = element;\n      },\n      getElement: () => treeElement,\n      getDataRef: () => treeDataRef,\n      getHotkeyPresets: () => hotkeyPresets\n    },\n    itemInstance: {\n      registerElement: ({ itemId, item }, element) => {\n        if (itemElementsMap[itemId] === element) {\n          return;\n        }\n        const oldElement = itemElementsMap[itemId];\n        if (oldElement && !element) {\n          eachFeature(\n            (feature) => {\n              var _a2;\n              return (_a2 = feature.onItemUnmount) == null ? void 0 : _a2.call(feature, item, oldElement, treeInstance);\n            }\n          );\n        } else if (!oldElement && element) {\n          eachFeature(\n            (feature) => {\n              var _a2;\n              return (_a2 = feature.onItemMount) == null ? void 0 : _a2.call(feature, item, element, treeInstance);\n            }\n          );\n        }\n        itemElementsMap[itemId] = element;\n      },\n      getElement: ({ itemId }) => itemElementsMap[itemId],\n      // eslint-disable-next-line no-return-assign\n      getDataRef: ({ itemId }) => {\n        var _a2;\n        return (_a2 = itemDataRefs[itemId]) != null ? _a2 : itemDataRefs[itemId] = { current: {} };\n      },\n      getItemMeta: ({ itemId }) => {\n        var _a2;\n        return (_a2 = itemMetaMap[itemId]) != null ? _a2 : {\n          itemId,\n          parentId: null,\n          level: -1,\n          index: -1,\n          posInSet: 0,\n          setSize: 1\n        };\n      }\n    }\n  };\n  features.unshift(mainFeature);\n  for (const feature of features) {\n    Object.assign(hotkeyPresets, (_d = feature.hotkeys) != null ? _d : {});\n  }\n  finalizeTree();\n  return treeInstance;\n};\n\n// src/features/drag-and-drop/types.ts\nvar DragTargetPosition = /* @__PURE__ */ ((DragTargetPosition2) => {\n  DragTargetPosition2[\"Top\"] = \"top\";\n  DragTargetPosition2[\"Bottom\"] = \"bottom\";\n  DragTargetPosition2[\"Item\"] = \"item\";\n  return DragTargetPosition2;\n})(DragTargetPosition || {});\n\n// src/features/keyboard-drag-and-drop/types.ts\nvar AssistiveDndState = /* @__PURE__ */ ((AssistiveDndState2) => {\n  AssistiveDndState2[AssistiveDndState2[\"None\"] = 0] = \"None\";\n  AssistiveDndState2[AssistiveDndState2[\"Started\"] = 1] = \"Started\";\n  AssistiveDndState2[AssistiveDndState2[\"Dragging\"] = 2] = \"Dragging\";\n  AssistiveDndState2[AssistiveDndState2[\"Completed\"] = 3] = \"Completed\";\n  AssistiveDndState2[AssistiveDndState2[\"Aborted\"] = 4] = \"Aborted\";\n  return AssistiveDndState2;\n})(AssistiveDndState || {});\n\n// src/features/checkboxes/types.ts\nvar CheckedState = /* @__PURE__ */ ((CheckedState2) => {\n  CheckedState2[\"Checked\"] = \"checked\";\n  CheckedState2[\"Unchecked\"] = \"unchecked\";\n  CheckedState2[\"Indeterminate\"] = \"indeterminate\";\n  return CheckedState2;\n})(CheckedState || {});\n\n// src/features/selection/feature.ts\nvar selectionFeature = {\n  key: \"selection\",\n  getInitialState: (initialState) => __spreadValues({\n    selectedItems: []\n  }, initialState),\n  getDefaultConfig: (defaultConfig, tree) => __spreadValues({\n    setSelectedItems: makeStateUpdater(\"selectedItems\", tree)\n  }, defaultConfig),\n  stateHandlerNames: {\n    selectedItems: \"setSelectedItems\"\n  },\n  treeInstance: {\n    setSelectedItems: ({ tree }, selectedItems) => {\n      tree.applySubStateUpdate(\"selectedItems\", selectedItems);\n    },\n    getSelectedItems: ({ tree }) => {\n      return tree.getState().selectedItems.map(tree.getItemInstance);\n    }\n  },\n  itemInstance: {\n    select: ({ tree, itemId }) => {\n      const { selectedItems } = tree.getState();\n      tree.setSelectedItems(\n        selectedItems.includes(itemId) ? selectedItems : [...selectedItems, itemId]\n      );\n    },\n    deselect: ({ tree, itemId }) => {\n      const { selectedItems } = tree.getState();\n      tree.setSelectedItems(selectedItems.filter((id) => id !== itemId));\n    },\n    isSelected: ({ tree, itemId }) => {\n      const { selectedItems } = tree.getState();\n      return selectedItems.includes(itemId);\n    },\n    selectUpTo: ({ tree, item }, ctrl) => {\n      const indexA = item.getItemMeta().index;\n      const indexB = tree.getFocusedItem().getItemMeta().index;\n      const [a, b] = indexA < indexB ? [indexA, indexB] : [indexB, indexA];\n      const newSelectedItems = tree.getItems().slice(a, b + 1).map((treeItem) => treeItem.getItemMeta().itemId);\n      if (!ctrl) {\n        tree.setSelectedItems(newSelectedItems);\n        return;\n      }\n      const { selectedItems } = tree.getState();\n      const uniqueSelectedItems = [\n        .../* @__PURE__ */ new Set([...selectedItems, ...newSelectedItems])\n      ];\n      tree.setSelectedItems(uniqueSelectedItems);\n    },\n    toggleSelect: ({ item }) => {\n      if (item.isSelected()) {\n        item.deselect();\n      } else {\n        item.select();\n      }\n    },\n    getProps: ({ tree, item, prev }) => __spreadProps(__spreadValues({}, prev == null ? void 0 : prev()), {\n      \"aria-selected\": item.isSelected() ? \"true\" : \"false\",\n      onClick: (e) => {\n        var _a, _b;\n        if (e.shiftKey) {\n          item.selectUpTo(e.ctrlKey || e.metaKey);\n        } else if (e.ctrlKey || e.metaKey) {\n          item.toggleSelect();\n        } else {\n          tree.setSelectedItems([item.getItemMeta().itemId]);\n        }\n        (_b = (_a = prev == null ? void 0 : prev()) == null ? void 0 : _a.onClick) == null ? void 0 : _b.call(_a, e);\n      }\n    })\n  },\n  hotkeys: {\n    // setSelectedItem: {\n    //   hotkey: \"space\",\n    //   handler: (e, tree) => {\n    //     tree.setSelectedItems([tree.getFocusedItem().getId()]);\n    //   },\n    // },\n    toggleSelectedItem: {\n      hotkey: \"Control+Space\",\n      preventDefault: true,\n      handler: (_, tree) => {\n        tree.getFocusedItem().toggleSelect();\n      }\n    },\n    selectUpwards: {\n      hotkey: \"Shift+ArrowUp\",\n      handler: (e, tree) => {\n        const focused = tree.getFocusedItem();\n        const above = focused.getItemAbove();\n        if (!above) return;\n        if (focused.isSelected() && above.isSelected()) {\n          focused.deselect();\n        } else {\n          above.select();\n        }\n        above.setFocused();\n        tree.updateDomFocus();\n      }\n    },\n    selectDownwards: {\n      hotkey: \"Shift+ArrowDown\",\n      handler: (e, tree) => {\n        const focused = tree.getFocusedItem();\n        const below = focused.getItemBelow();\n        if (!below) return;\n        if (focused.isSelected() && below.isSelected()) {\n          focused.deselect();\n        } else {\n          below.select();\n        }\n        below.setFocused();\n        tree.updateDomFocus();\n      }\n    },\n    selectAll: {\n      hotkey: \"Control+KeyA\",\n      preventDefault: true,\n      handler: (e, tree) => {\n        tree.setSelectedItems(tree.getItems().map((item) => item.getId()));\n      }\n    }\n  }\n};\n\n// src/features/checkboxes/feature.ts\nvar getAllLoadedDescendants = (tree, itemId, includeFolders = false) => {\n  if (!tree.getConfig().isItemFolder(tree.getItemInstance(itemId))) {\n    return [itemId];\n  }\n  const descendants = tree.retrieveChildrenIds(itemId).map((child) => getAllLoadedDescendants(tree, child, includeFolders)).flat();\n  return includeFolders ? [itemId, ...descendants] : descendants;\n};\nvar checkboxesFeature = {\n  key: \"checkboxes\",\n  overwrites: [\"selection\"],\n  getInitialState: (initialState) => __spreadValues({\n    checkedItems: []\n  }, initialState),\n  getDefaultConfig: (defaultConfig, tree) => {\n    var _a, _b, _c;\n    const hasAsyncLoader = (_a = defaultConfig.features) == null ? void 0 : _a.some(\n      (f) => f.key === \"async-data-loader\"\n    );\n    if (hasAsyncLoader && defaultConfig.propagateCheckedState) {\n      throwError(`propagateCheckedState not supported with async trees`);\n    }\n    const propagateCheckedState = (_b = defaultConfig.propagateCheckedState) != null ? _b : !hasAsyncLoader;\n    const canCheckFolders = (_c = defaultConfig.canCheckFolders) != null ? _c : !propagateCheckedState;\n    return __spreadValues({\n      setCheckedItems: makeStateUpdater(\"checkedItems\", tree),\n      propagateCheckedState,\n      canCheckFolders\n    }, defaultConfig);\n  },\n  stateHandlerNames: {\n    checkedItems: \"setCheckedItems\"\n  },\n  treeInstance: {\n    setCheckedItems: ({ tree }, checkedItems) => {\n      tree.applySubStateUpdate(\"checkedItems\", checkedItems);\n    }\n  },\n  itemInstance: {\n    getCheckboxProps: ({ item }) => {\n      const checkedState = item.getCheckedState();\n      return {\n        onChange: item.toggleCheckedState,\n        checked: checkedState === \"checked\" /* Checked */,\n        ref: (r) => {\n          if (r) {\n            r.indeterminate = checkedState === \"indeterminate\" /* Indeterminate */;\n          }\n        }\n      };\n    },\n    toggleCheckedState: ({ item }) => {\n      if (item.getCheckedState() === \"checked\" /* Checked */) {\n        item.setUnchecked();\n      } else {\n        item.setChecked();\n      }\n    },\n    getCheckedState: ({ item, tree }) => {\n      const { checkedItems } = tree.getState();\n      const { propagateCheckedState } = tree.getConfig();\n      const itemId = item.getId();\n      if (checkedItems.includes(itemId)) {\n        return \"checked\" /* Checked */;\n      }\n      if (item.isFolder() && propagateCheckedState) {\n        const descendants = getAllLoadedDescendants(tree, itemId);\n        if (descendants.every((d) => checkedItems.includes(d))) {\n          return \"checked\" /* Checked */;\n        }\n        if (descendants.some((d) => checkedItems.includes(d))) {\n          return \"indeterminate\" /* Indeterminate */;\n        }\n      }\n      return \"unchecked\" /* Unchecked */;\n    },\n    setChecked: ({ item, tree, itemId }) => {\n      const { propagateCheckedState, canCheckFolders } = tree.getConfig();\n      if (item.isFolder() && propagateCheckedState) {\n        tree.applySubStateUpdate(\"checkedItems\", (items) => [\n          ...items,\n          ...getAllLoadedDescendants(tree, itemId, canCheckFolders)\n        ]);\n      } else if (!item.isFolder() || canCheckFolders) {\n        tree.applySubStateUpdate(\"checkedItems\", (items) => [...items, itemId]);\n      }\n    },\n    setUnchecked: ({ item, tree, itemId }) => {\n      const { propagateCheckedState, canCheckFolders } = tree.getConfig();\n      if (item.isFolder() && propagateCheckedState) {\n        const descendants = getAllLoadedDescendants(\n          tree,\n          itemId,\n          canCheckFolders\n        );\n        tree.applySubStateUpdate(\n          \"checkedItems\",\n          (items) => items.filter((id) => !descendants.includes(id) && id !== itemId)\n        );\n      } else {\n        tree.applySubStateUpdate(\n          \"checkedItems\",\n          (items) => items.filter((id) => id !== itemId)\n        );\n      }\n    }\n  }\n};\n\n// src/features/hotkeys-core/feature.ts\nvar specialKeys = {\n  // TODO:breaking deprecate auto-lowercase\n  letter: /^Key[A-Z]$/,\n  letterornumber: /^(Key[A-Z]|Digit[0-9])$/,\n  plus: /^(NumpadAdd|Plus)$/,\n  minus: /^(NumpadSubtract|Minus)$/,\n  control: /^(ControlLeft|ControlRight)$/,\n  shift: /^(ShiftLeft|ShiftRight)$/\n};\nvar testHotkeyMatch = (pressedKeys, tree, hotkey) => {\n  const supposedKeys = hotkey.hotkey.toLowerCase().split(\"+\");\n  const doKeysMatch = supposedKeys.every((key) => {\n    if (key in specialKeys) {\n      return [...pressedKeys].some(\n        (pressedKey) => specialKeys[key].test(pressedKey)\n      );\n    }\n    const pressedKeysLowerCase = [...pressedKeys].map((k) => k.toLowerCase());\n    if (pressedKeysLowerCase.includes(key.toLowerCase())) {\n      return true;\n    }\n    if (pressedKeysLowerCase.includes(`key${key.toLowerCase()}`)) {\n      return true;\n    }\n    return false;\n  });\n  const isEnabled = !hotkey.isEnabled || hotkey.isEnabled(tree);\n  const equalCounts = pressedKeys.size === supposedKeys.length;\n  return doKeysMatch && isEnabled && equalCounts;\n};\nvar findHotkeyMatch = (pressedKeys, tree, config1, config2) => {\n  var _a;\n  return (_a = Object.entries(__spreadValues(__spreadValues({}, config1), config2)).find(\n    ([, hotkey]) => testHotkeyMatch(pressedKeys, tree, hotkey)\n  )) == null ? void 0 : _a[0];\n};\nvar hotkeysCoreFeature = {\n  key: \"hotkeys-core\",\n  onTreeMount: (tree, element) => {\n    const data = tree.getDataRef();\n    const keydown = (e) => {\n      var _a, _b;\n      const { ignoreHotkeysOnInputs, onTreeHotkey, hotkeys } = tree.getConfig();\n      if (e.target instanceof HTMLInputElement && ignoreHotkeysOnInputs) {\n        return;\n      }\n      (_b = (_a = data.current).pressedKeys) != null ? _b : _a.pressedKeys = /* @__PURE__ */ new Set();\n      const newMatch = !data.current.pressedKeys.has(e.code);\n      data.current.pressedKeys.add(e.code);\n      const hotkeyName = findHotkeyMatch(\n        data.current.pressedKeys,\n        tree,\n        tree.getHotkeyPresets(),\n        hotkeys\n      );\n      if (e.target instanceof HTMLInputElement) {\n        data.current.pressedKeys.delete(e.code);\n      }\n      if (!hotkeyName) return;\n      const hotkeyConfig = __spreadValues(__spreadValues({}, tree.getHotkeyPresets()[hotkeyName]), hotkeys == null ? void 0 : hotkeys[hotkeyName]);\n      if (!hotkeyConfig) return;\n      if (!hotkeyConfig.allowWhenInputFocused && e.target instanceof HTMLInputElement)\n        return;\n      if (!hotkeyConfig.canRepeat && !newMatch) return;\n      if (hotkeyConfig.preventDefault) e.preventDefault();\n      hotkeyConfig.handler(e, tree);\n      onTreeHotkey == null ? void 0 : onTreeHotkey(hotkeyName, e);\n    };\n    const keyup = (e) => {\n      var _a, _b;\n      (_b = (_a = data.current).pressedKeys) != null ? _b : _a.pressedKeys = /* @__PURE__ */ new Set();\n      data.current.pressedKeys.delete(e.code);\n    };\n    const reset = () => {\n      data.current.pressedKeys = /* @__PURE__ */ new Set();\n    };\n    element.addEventListener(\"keydown\", keydown);\n    document.addEventListener(\"keyup\", keyup);\n    window.addEventListener(\"focus\", reset);\n    data.current.keydownHandler = keydown;\n    data.current.keyupHandler = keyup;\n    data.current.resetHandler = reset;\n  },\n  onTreeUnmount: (tree, element) => {\n    const data = tree.getDataRef();\n    if (data.current.keyupHandler) {\n      document.removeEventListener(\"keyup\", data.current.keyupHandler);\n      delete data.current.keyupHandler;\n    }\n    if (data.current.keydownHandler) {\n      element.removeEventListener(\"keydown\", data.current.keydownHandler);\n      delete data.current.keydownHandler;\n    }\n    if (data.current.resetHandler) {\n      window.removeEventListener(\"focus\", data.current.resetHandler);\n      delete data.current.resetHandler;\n    }\n  }\n};\n\n// src/features/async-data-loader/feature.ts\nvar getDataRef = (tree) => {\n  var _a, _b, _c, _d;\n  const dataRef = tree.getDataRef();\n  (_b = (_a = dataRef.current).itemData) != null ? _b : _a.itemData = {};\n  (_d = (_c = dataRef.current).childrenIds) != null ? _d : _c.childrenIds = {};\n  return dataRef;\n};\nvar loadItemData = (tree, itemId) => __async(null, null, function* () {\n  var _a;\n  const config = tree.getConfig();\n  const dataRef = getDataRef(tree);\n  const item = yield config.dataLoader.getItem(itemId);\n  dataRef.current.itemData[itemId] = item;\n  (_a = config.onLoadedItem) == null ? void 0 : _a.call(config, itemId, item);\n  tree.applySubStateUpdate(\n    \"loadingItemData\",\n    (loadingItemData) => loadingItemData.filter((id) => id !== itemId)\n  );\n  return item;\n});\nvar loadChildrenIds = (tree, itemId) => __async(null, null, function* () {\n  var _a, _b;\n  const config = tree.getConfig();\n  const dataRef = getDataRef(tree);\n  let childrenIds;\n  if (\"getChildrenWithData\" in config.dataLoader) {\n    const children = yield config.dataLoader.getChildrenWithData(itemId);\n    childrenIds = children.map((c) => c.id);\n    dataRef.current.childrenIds[itemId] = childrenIds;\n    children.forEach(({ id, data }) => {\n      var _a2;\n      dataRef.current.itemData[id] = data;\n      (_a2 = config.onLoadedItem) == null ? void 0 : _a2.call(config, id, data);\n    });\n    (_a = config.onLoadedChildren) == null ? void 0 : _a.call(config, itemId, childrenIds);\n    tree.rebuildTree();\n    tree.applySubStateUpdate(\n      \"loadingItemData\",\n      (loadingItemData) => loadingItemData.filter((id) => !childrenIds.includes(id))\n    );\n  } else {\n    childrenIds = yield config.dataLoader.getChildren(itemId);\n    dataRef.current.childrenIds[itemId] = childrenIds;\n    (_b = config.onLoadedChildren) == null ? void 0 : _b.call(config, itemId, childrenIds);\n    tree.rebuildTree();\n  }\n  tree.applySubStateUpdate(\n    \"loadingItemChildrens\",\n    (loadingItemChildrens) => loadingItemChildrens.filter((id) => id !== itemId)\n  );\n  return childrenIds;\n});\nvar asyncDataLoaderFeature = {\n  key: \"async-data-loader\",\n  getInitialState: (initialState) => __spreadValues({\n    loadingItemData: [],\n    loadingItemChildrens: []\n  }, initialState),\n  getDefaultConfig: (defaultConfig, tree) => __spreadValues({\n    setLoadingItemData: makeStateUpdater(\"loadingItemData\", tree),\n    setLoadingItemChildrens: makeStateUpdater(\"loadingItemChildrens\", tree)\n  }, defaultConfig),\n  stateHandlerNames: {\n    loadingItemData: \"setLoadingItemData\",\n    loadingItemChildrens: \"setLoadingItemChildrens\"\n  },\n  treeInstance: {\n    waitForItemDataLoaded: ({ tree }, itemId) => tree.loadItemData(itemId),\n    waitForItemChildrenLoaded: ({ tree }, itemId) => tree.loadChildrenIds(itemId),\n    loadItemData: (_0, _1) => __async(null, [_0, _1], function* ({ tree }, itemId) {\n      var _a;\n      return (_a = getDataRef(tree).current.itemData[itemId]) != null ? _a : yield loadItemData(tree, itemId);\n    }),\n    loadChildrenIds: (_0, _1) => __async(null, [_0, _1], function* ({ tree }, itemId) {\n      var _a;\n      return (_a = getDataRef(tree).current.childrenIds[itemId]) != null ? _a : yield loadChildrenIds(tree, itemId);\n    }),\n    retrieveItemData: ({ tree }, itemId, skipFetch = false) => {\n      var _a, _b;\n      const config = tree.getConfig();\n      const dataRef = getDataRef(tree);\n      if (dataRef.current.itemData[itemId]) {\n        return dataRef.current.itemData[itemId];\n      }\n      if (!tree.getState().loadingItemData.includes(itemId) && !skipFetch) {\n        tree.applySubStateUpdate(\"loadingItemData\", (loadingItemData) => [\n          ...loadingItemData,\n          itemId\n        ]);\n        loadItemData(tree, itemId);\n      }\n      return (_b = (_a = config.createLoadingItemData) == null ? void 0 : _a.call(config)) != null ? _b : null;\n    },\n    retrieveChildrenIds: ({ tree }, itemId, skipFetch = false) => {\n      const dataRef = getDataRef(tree);\n      if (dataRef.current.childrenIds[itemId]) {\n        return dataRef.current.childrenIds[itemId];\n      }\n      if (tree.getState().loadingItemChildrens.includes(itemId) || skipFetch) {\n        return [];\n      }\n      tree.applySubStateUpdate(\n        \"loadingItemChildrens\",\n        (loadingItemChildrens) => [...loadingItemChildrens, itemId]\n      );\n      loadChildrenIds(tree, itemId);\n      return [];\n    }\n  },\n  itemInstance: {\n    isLoading: ({ tree, item }) => tree.getState().loadingItemData.includes(item.getItemMeta().itemId) || tree.getState().loadingItemChildrens.includes(item.getItemMeta().itemId),\n    invalidateItemData: (_0, _1) => __async(null, [_0, _1], function* ({ tree, itemId }, optimistic) {\n      var _a;\n      if (!optimistic) {\n        (_a = getDataRef(tree).current.itemData) == null ? true : delete _a[itemId];\n        tree.applySubStateUpdate(\"loadingItemData\", (loadingItemData) => [\n          ...loadingItemData,\n          itemId\n        ]);\n      }\n      yield loadItemData(tree, itemId);\n    }),\n    invalidateChildrenIds: (_0, _1) => __async(null, [_0, _1], function* ({ tree, itemId }, optimistic) {\n      var _a;\n      if (!optimistic) {\n        (_a = getDataRef(tree).current.childrenIds) == null ? true : delete _a[itemId];\n        tree.applySubStateUpdate(\n          \"loadingItemChildrens\",\n          (loadingItemChildrens) => [...loadingItemChildrens, itemId]\n        );\n      }\n      yield loadChildrenIds(tree, itemId);\n    }),\n    updateCachedChildrenIds: ({ tree, itemId }, childrenIds) => {\n      const dataRef = tree.getDataRef();\n      dataRef.current.childrenIds[itemId] = childrenIds;\n      tree.rebuildTree();\n    },\n    updateCachedData: ({ tree, itemId }, data) => {\n      const dataRef = tree.getDataRef();\n      dataRef.current.itemData[itemId] = data;\n      tree.rebuildTree();\n    }\n  }\n};\n\n// src/features/sync-data-loader/feature.ts\nvar undefErrorMessage = \"sync dataLoader returned undefined\";\nvar promiseErrorMessage = \"sync dataLoader returned promise\";\nvar unpromise = (data) => {\n  if (!data) {\n    throw throwError(undefErrorMessage);\n  }\n  if (typeof data === \"object\" && \"then\" in data) {\n    throw throwError(promiseErrorMessage);\n  }\n  return data;\n};\nvar syncDataLoaderFeature = {\n  key: \"sync-data-loader\",\n  getInitialState: (initialState) => __spreadValues({\n    loadingItemData: [],\n    loadingItemChildrens: []\n  }, initialState),\n  getDefaultConfig: (defaultConfig, tree) => __spreadValues({\n    setLoadingItemData: makeStateUpdater(\"loadingItemData\", tree),\n    setLoadingItemChildrens: makeStateUpdater(\"loadingItemChildrens\", tree)\n  }, defaultConfig),\n  stateHandlerNames: {\n    loadingItemData: \"setLoadingItemData\",\n    loadingItemChildrens: \"setLoadingItemChildrens\"\n  },\n  treeInstance: {\n    waitForItemDataLoaded: () => __async(null, null, function* () {\n    }),\n    waitForItemChildrenLoaded: () => __async(null, null, function* () {\n    }),\n    retrieveItemData: ({ tree }, itemId) => {\n      return unpromise(tree.getConfig().dataLoader.getItem(itemId));\n    },\n    retrieveChildrenIds: ({ tree }, itemId) => {\n      const { dataLoader } = tree.getConfig();\n      if (\"getChildren\" in dataLoader) {\n        return unpromise(dataLoader.getChildren(itemId));\n      }\n      return unpromise(dataLoader.getChildrenWithData(itemId)).map(\n        (c) => c.data\n      );\n    },\n    loadItemData: ({ tree }, itemId) => tree.retrieveItemData(itemId),\n    loadChildrenIds: ({ tree }, itemId) => tree.retrieveChildrenIds(itemId)\n  },\n  itemInstance: {\n    isLoading: () => false\n  }\n};\n\n// src/features/drag-and-drop/utils.ts\nvar isOrderedDragTarget = (dragTarget) => \"childIndex\" in dragTarget;\nvar canDrop = (dataTransfer, target, tree) => {\n  var _a, _b, _c;\n  const draggedItems = (_a = tree.getState().dnd) == null ? void 0 : _a.draggedItems;\n  const config = tree.getConfig();\n  if (draggedItems && !((_c = (_b = config.canDrop) == null ? void 0 : _b.call(config, draggedItems, target)) != null ? _c : true)) {\n    return false;\n  }\n  if (draggedItems && draggedItems.some(\n    (draggedItem) => target.item.getId() === draggedItem.getId() || target.item.isDescendentOf(draggedItem.getId())\n  )) {\n    return false;\n  }\n  if (!draggedItems && dataTransfer && config.canDropForeignDragObject && !config.canDropForeignDragObject(dataTransfer, target)) {\n    return false;\n  }\n  return true;\n};\nvar getItemDropCategory = (item) => {\n  if (item.isExpanded()) {\n    return 1 /* ExpandedFolder */;\n  }\n  const parent = item.getParent();\n  if (parent && item.getIndexInParent() === item.getItemMeta().setSize - 1) {\n    return 2 /* LastInGroup */;\n  }\n  return 0 /* Item */;\n};\nvar getInsertionIndex = (children, childIndex, draggedItems) => {\n  var _a;\n  const numberOfDragItemsBeforeTarget = (_a = children.slice(0, childIndex).reduce(\n    (counter, child) => child && (draggedItems == null ? void 0 : draggedItems.some((i) => i.getId() === child.getId())) ? ++counter : counter,\n    0\n  )) != null ? _a : 0;\n  return childIndex - numberOfDragItemsBeforeTarget;\n};\nvar getTargetPlacement = (e, item, tree, canMakeChild) => {\n  var _a, _b, _c, _d, _e;\n  const config = tree.getConfig();\n  if (!config.canReorder) {\n    return canMakeChild ? { type: 2 /* MakeChild */ } : { type: 1 /* ReorderBelow */ };\n  }\n  const bb = (_a = item.getElement()) == null ? void 0 : _a.getBoundingClientRect();\n  const topPercent = bb ? (e.clientY - bb.top) / bb.height : 0.5;\n  const leftPixels = bb ? e.clientX - bb.left : 0;\n  const targetDropCategory = getItemDropCategory(item);\n  const reorderAreaPercentage = !canMakeChild ? 0.5 : (_b = config.reorderAreaPercentage) != null ? _b : 0.3;\n  const indent = (_c = config.indent) != null ? _c : 20;\n  const makeChildType = canMakeChild ? 2 /* MakeChild */ : 1 /* ReorderBelow */;\n  if (targetDropCategory === 1 /* ExpandedFolder */) {\n    if (topPercent < reorderAreaPercentage) {\n      return { type: 0 /* ReorderAbove */ };\n    }\n    return { type: makeChildType };\n  }\n  if (targetDropCategory === 2 /* LastInGroup */) {\n    if (leftPixels < item.getItemMeta().level * indent) {\n      if (topPercent < 0.5) {\n        return { type: 0 /* ReorderAbove */ };\n      }\n      const minLevel = (_e = (_d = item.getItemBelow()) == null ? void 0 : _d.getItemMeta().level) != null ? _e : 0;\n      return {\n        type: 3 /* Reparent */,\n        reparentLevel: Math.max(minLevel, Math.floor(leftPixels / indent))\n      };\n    }\n  }\n  if (topPercent < reorderAreaPercentage) {\n    return { type: 0 /* ReorderAbove */ };\n  }\n  if (topPercent > 1 - reorderAreaPercentage) {\n    return { type: 1 /* ReorderBelow */ };\n  }\n  return { type: makeChildType };\n};\nvar getDragCode = (item, placement) => {\n  return [\n    item.getId(),\n    placement.type,\n    placement.type === 3 /* Reparent */ ? placement.reparentLevel : 0\n  ].join(\"__\");\n};\nvar getNthParent = (item, n) => {\n  if (n === item.getItemMeta().level) {\n    return item;\n  }\n  return getNthParent(item.getParent(), n);\n};\nvar getReparentTarget = (item, reparentLevel, draggedItems) => {\n  const itemMeta = item.getItemMeta();\n  const reparentedTarget = getNthParent(item, reparentLevel - 1);\n  const targetItemAbove = getNthParent(item, reparentLevel);\n  const targetIndex = targetItemAbove.getIndexInParent() + 1;\n  return {\n    item: reparentedTarget,\n    childIndex: targetIndex,\n    insertionIndex: getInsertionIndex(\n      reparentedTarget.getChildren(),\n      targetIndex,\n      draggedItems\n    ),\n    dragLineIndex: itemMeta.index + 1,\n    dragLineLevel: reparentLevel\n  };\n};\nvar getDragTarget = (e, item, tree, canReorder = tree.getConfig().canReorder) => {\n  var _a;\n  const draggedItems = (_a = tree.getState().dnd) == null ? void 0 : _a.draggedItems;\n  const itemMeta = item.getItemMeta();\n  const parent = item.getParent();\n  const itemTarget = { item };\n  const parentTarget = parent ? { item: parent } : null;\n  const canBecomeSibling = parentTarget && canDrop(e.dataTransfer, parentTarget, tree);\n  const canMakeChild = canDrop(e.dataTransfer, itemTarget, tree);\n  const placement = getTargetPlacement(e, item, tree, canMakeChild);\n  if (!canReorder && parent && canBecomeSibling && placement.type !== 2 /* MakeChild */) {\n    if (draggedItems == null ? void 0 : draggedItems.some((item2) => item2.isDescendentOf(parent.getId()))) {\n      return itemTarget;\n    }\n    return parentTarget;\n  }\n  if (!canReorder && parent && !canBecomeSibling) {\n    return getDragTarget(e, parent, tree, false);\n  }\n  if (!parent) {\n    return itemTarget;\n  }\n  if (placement.type === 2 /* MakeChild */) {\n    return itemTarget;\n  }\n  if (!canBecomeSibling) {\n    return getDragTarget(e, parent, tree, false);\n  }\n  if (placement.type === 3 /* Reparent */) {\n    return getReparentTarget(item, placement.reparentLevel, draggedItems);\n  }\n  const maybeAddOneForBelow = placement.type === 0 /* ReorderAbove */ ? 0 : 1;\n  const childIndex = item.getIndexInParent() + maybeAddOneForBelow;\n  return {\n    item: parent,\n    dragLineIndex: itemMeta.index + maybeAddOneForBelow,\n    dragLineLevel: itemMeta.level,\n    childIndex,\n    // TODO performance could be improved by computing this only when dragcode changed\n    insertionIndex: getInsertionIndex(\n      parent.getChildren(),\n      childIndex,\n      draggedItems\n    )\n  };\n};\n\n// src/features/drag-and-drop/feature.ts\nvar handleAutoOpenFolder = (dataRef, tree, item, placement) => {\n  const { openOnDropDelay } = tree.getConfig();\n  const dragCode = dataRef.current.lastDragCode;\n  if (!openOnDropDelay || !item.isFolder() || item.isExpanded() || placement.type !== 2 /* MakeChild */) {\n    return;\n  }\n  clearTimeout(dataRef.current.autoExpandTimeout);\n  dataRef.current.autoExpandTimeout = setTimeout(() => {\n    if (dragCode !== dataRef.current.lastDragCode || !dataRef.current.lastAllowDrop)\n      return;\n    item.expand();\n  }, openOnDropDelay);\n};\nvar defaultCanDropForeignDragObject = () => false;\nvar dragAndDropFeature = {\n  key: \"drag-and-drop\",\n  getDefaultConfig: (defaultConfig, tree) => __spreadValues({\n    canDrop: (_, target) => target.item.isFolder(),\n    canDropForeignDragObject: defaultCanDropForeignDragObject,\n    canDragForeignDragObjectOver: defaultConfig.canDropForeignDragObject !== defaultCanDropForeignDragObject ? (dataTransfer) => dataTransfer.effectAllowed !== \"none\" : () => false,\n    setDndState: makeStateUpdater(\"dnd\", tree),\n    canReorder: true,\n    openOnDropDelay: 800\n  }, defaultConfig),\n  stateHandlerNames: {\n    dnd: \"setDndState\"\n  },\n  onTreeMount: (tree) => {\n    const listener = () => {\n      tree.applySubStateUpdate(\"dnd\", null);\n    };\n    tree.getDataRef().current.windowDragEndListener = listener;\n    window.addEventListener(\"dragend\", listener);\n  },\n  onTreeUnmount: (tree) => {\n    const { windowDragEndListener } = tree.getDataRef().current;\n    if (!windowDragEndListener) return;\n    window.removeEventListener(\"dragend\", windowDragEndListener);\n  },\n  treeInstance: {\n    getDragTarget: ({ tree }) => {\n      var _a, _b;\n      return (_b = (_a = tree.getState().dnd) == null ? void 0 : _a.dragTarget) != null ? _b : null;\n    },\n    getDragLineData: ({ tree }) => {\n      var _a, _b, _c, _d, _e, _f;\n      const target = tree.getDragTarget();\n      const indent = ((_a = target == null ? void 0 : target.item.getItemMeta().level) != null ? _a : 0) + 1;\n      const treeBb = (_b = tree.getElement()) == null ? void 0 : _b.getBoundingClientRect();\n      if (!target || !treeBb || !isOrderedDragTarget(target)) return null;\n      const leftOffset = target.dragLineLevel * ((_c = tree.getConfig().indent) != null ? _c : 1);\n      const targetItem = tree.getItems()[target.dragLineIndex];\n      if (!targetItem) {\n        const bb2 = (_e = (_d = tree.getItems()[target.dragLineIndex - 1]) == null ? void 0 : _d.getElement()) == null ? void 0 : _e.getBoundingClientRect();\n        if (bb2) {\n          return {\n            indent,\n            top: bb2.bottom - treeBb.top,\n            left: bb2.left + leftOffset - treeBb.left,\n            width: bb2.width - leftOffset\n          };\n        }\n      }\n      const bb = (_f = targetItem == null ? void 0 : targetItem.getElement()) == null ? void 0 : _f.getBoundingClientRect();\n      if (bb) {\n        return {\n          indent,\n          top: bb.top - treeBb.top,\n          left: bb.left + leftOffset - treeBb.left,\n          width: bb.width - leftOffset\n        };\n      }\n      return null;\n    },\n    getDragLineStyle: ({ tree }, topOffset = -1, leftOffset = -8) => {\n      const dragLine = tree.getDragLineData();\n      return dragLine ? {\n        position: \"absolute\",\n        top: `${dragLine.top + topOffset}px`,\n        left: `${dragLine.left + leftOffset}px`,\n        width: `${dragLine.width - leftOffset}px`,\n        pointerEvents: \"none\"\n        // important to prevent capturing drag events\n      } : { display: \"none\" };\n    },\n    getContainerProps: ({ prev, tree }, treeLabel) => {\n      const prevProps = prev == null ? void 0 : prev(treeLabel);\n      return __spreadProps(__spreadValues({}, prevProps), {\n        onDragOver: (e) => {\n          e.preventDefault();\n        },\n        onDrop: (e) => __async(null, null, function* () {\n          var _a, _b, _c;\n          const dataRef = tree.getDataRef();\n          const target = { item: tree.getRootItem() };\n          if (!canDrop(e.dataTransfer, target, tree)) {\n            return;\n          }\n          e.preventDefault();\n          const config = tree.getConfig();\n          const draggedItems = (_a = tree.getState().dnd) == null ? void 0 : _a.draggedItems;\n          dataRef.current.lastDragCode = void 0;\n          if (draggedItems) {\n            yield (_b = config.onDrop) == null ? void 0 : _b.call(config, draggedItems, target);\n          } else if (e.dataTransfer) {\n            yield (_c = config.onDropForeignDragObject) == null ? void 0 : _c.call(config, e.dataTransfer, target);\n          }\n        }),\n        style: __spreadProps(__spreadValues({}, prevProps == null ? void 0 : prevProps.style), {\n          position: \"relative\"\n        })\n      });\n    }\n  },\n  itemInstance: {\n    getProps: ({ tree, item, prev }) => __spreadProps(__spreadValues({}, prev == null ? void 0 : prev()), {\n      draggable: true,\n      onDragEnter: (e) => e.preventDefault(),\n      onDragStart: (e) => {\n        var _a, _b, _c, _d;\n        const selectedItems = tree.getSelectedItems ? tree.getSelectedItems() : [tree.getFocusedItem()];\n        const items = selectedItems.includes(item) ? selectedItems : [item];\n        const config = tree.getConfig();\n        if (!selectedItems.includes(item)) {\n          (_a = tree.setSelectedItems) == null ? void 0 : _a.call(tree, [item.getItemMeta().itemId]);\n        }\n        if (!((_c = (_b = config.canDrag) == null ? void 0 : _b.call(config, items)) != null ? _c : true)) {\n          e.preventDefault();\n          return;\n        }\n        if (config.setDragImage) {\n          const { imgElement, xOffset, yOffset } = config.setDragImage(items);\n          (_d = e.dataTransfer) == null ? void 0 : _d.setDragImage(imgElement, xOffset != null ? xOffset : 0, yOffset != null ? yOffset : 0);\n        }\n        if (config.createForeignDragObject && e.dataTransfer) {\n          const { format, data, dropEffect, effectAllowed } = config.createForeignDragObject(items);\n          e.dataTransfer.setData(format, data);\n          if (dropEffect) e.dataTransfer.dropEffect = dropEffect;\n          if (effectAllowed) e.dataTransfer.effectAllowed = effectAllowed;\n        }\n        tree.applySubStateUpdate(\"dnd\", {\n          draggedItems: items,\n          draggingOverItem: tree.getFocusedItem()\n        });\n      },\n      onDragOver: (e) => {\n        var _a, _b, _c;\n        e.stopPropagation();\n        const dataRef = tree.getDataRef();\n        const placement = getTargetPlacement(e, item, tree, true);\n        const nextDragCode = getDragCode(item, placement);\n        if (nextDragCode === dataRef.current.lastDragCode) {\n          if (dataRef.current.lastAllowDrop) {\n            e.preventDefault();\n          }\n          return;\n        }\n        dataRef.current.lastDragCode = nextDragCode;\n        dataRef.current.lastDragEnter = Date.now();\n        handleAutoOpenFolder(dataRef, tree, item, placement);\n        const target = getDragTarget(e, item, tree);\n        if (!((_a = tree.getState().dnd) == null ? void 0 : _a.draggedItems) && (!e.dataTransfer || !((_c = (_b = tree.getConfig()).canDragForeignDragObjectOver) == null ? void 0 : _c.call(_b, e.dataTransfer, target)))) {\n          dataRef.current.lastAllowDrop = false;\n          return;\n        }\n        if (!canDrop(e.dataTransfer, target, tree)) {\n          dataRef.current.lastAllowDrop = false;\n          return;\n        }\n        tree.applySubStateUpdate(\"dnd\", (state) => __spreadProps(__spreadValues({}, state), {\n          dragTarget: target,\n          draggingOverItem: item\n        }));\n        dataRef.current.lastAllowDrop = true;\n        e.preventDefault();\n      },\n      onDragLeave: () => {\n        setTimeout(() => {\n          var _a;\n          const dataRef = tree.getDataRef();\n          if (((_a = dataRef.current.lastDragEnter) != null ? _a : 0) + 100 >= Date.now()) return;\n          dataRef.current.lastDragCode = \"no-drag\";\n          tree.applySubStateUpdate(\"dnd\", (state) => __spreadProps(__spreadValues({}, state), {\n            draggingOverItem: void 0,\n            dragTarget: void 0\n          }));\n        }, 100);\n      },\n      onDragEnd: (e) => {\n        var _a, _b;\n        const { onCompleteForeignDrop, canDragForeignDragObjectOver } = tree.getConfig();\n        const draggedItems = (_a = tree.getState().dnd) == null ? void 0 : _a.draggedItems;\n        if (((_b = e.dataTransfer) == null ? void 0 : _b.dropEffect) === \"none\" || !draggedItems) {\n          return;\n        }\n        const target = getDragTarget(e, item, tree);\n        if (canDragForeignDragObjectOver && e.dataTransfer && !canDragForeignDragObjectOver(e.dataTransfer, target)) {\n          return;\n        }\n        onCompleteForeignDrop == null ? void 0 : onCompleteForeignDrop(draggedItems);\n      },\n      onDrop: (e) => __async(null, null, function* () {\n        var _a, _b, _c;\n        e.stopPropagation();\n        const dataRef = tree.getDataRef();\n        const target = getDragTarget(e, item, tree);\n        const draggedItems = (_a = tree.getState().dnd) == null ? void 0 : _a.draggedItems;\n        const isValidDrop = canDrop(e.dataTransfer, target, tree);\n        tree.applySubStateUpdate(\"dnd\", {\n          draggedItems: void 0,\n          draggingOverItem: void 0,\n          dragTarget: void 0\n        });\n        if (!isValidDrop) {\n          return;\n        }\n        e.preventDefault();\n        const config = tree.getConfig();\n        dataRef.current.lastDragCode = void 0;\n        if (draggedItems) {\n          yield (_b = config.onDrop) == null ? void 0 : _b.call(config, draggedItems, target);\n        } else if (e.dataTransfer) {\n          yield (_c = config.onDropForeignDragObject) == null ? void 0 : _c.call(config, e.dataTransfer, target);\n        }\n      })\n    }),\n    isDragTarget: ({ tree, item }) => {\n      const target = tree.getDragTarget();\n      return target ? target.item.getId() === item.getId() : false;\n    },\n    isDragTargetAbove: ({ tree, item }) => {\n      const target = tree.getDragTarget();\n      if (!target || !isOrderedDragTarget(target) || target.item !== item.getParent())\n        return false;\n      return target.childIndex === item.getItemMeta().posInSet;\n    },\n    isDragTargetBelow: ({ tree, item }) => {\n      const target = tree.getDragTarget();\n      if (!target || !isOrderedDragTarget(target) || target.item !== item.getParent())\n        return false;\n      return target.childIndex - 1 === item.getItemMeta().posInSet;\n    },\n    isDraggingOver: ({ tree, item }) => {\n      var _a, _b;\n      return ((_b = (_a = tree.getState().dnd) == null ? void 0 : _a.draggingOverItem) == null ? void 0 : _b.getId()) === item.getId();\n    }\n  }\n};\n\n// src/features/keyboard-drag-and-drop/feature.ts\nvar getNextDragTarget = (tree, isUp, dragTarget) => {\n  var _a, _b, _c, _d;\n  const direction = isUp ? 0 : 1;\n  const draggedItems = (_a = tree.getState().dnd) == null ? void 0 : _a.draggedItems;\n  if (isOrderedDragTarget(dragTarget)) {\n    const parent = dragTarget.item.getParent();\n    const targetedItem = tree.getItems()[dragTarget.dragLineIndex - 1];\n    const targetCategory = targetedItem ? getItemDropCategory(targetedItem) : 0 /* Item */;\n    const maxLevel = (_b = targetedItem == null ? void 0 : targetedItem.getItemMeta().level) != null ? _b : 0;\n    const minLevel = (_d = (_c = targetedItem == null ? void 0 : targetedItem.getItemBelow()) == null ? void 0 : _c.getItemMeta().level) != null ? _d : 0;\n    if (targetCategory === 2 /* LastInGroup */) {\n      if (isUp && dragTarget.dragLineLevel < maxLevel) {\n        return getReparentTarget(\n          targetedItem,\n          dragTarget.dragLineLevel + 1,\n          draggedItems\n        );\n      }\n      if (!isUp && dragTarget.dragLineLevel > minLevel && parent) {\n        return getReparentTarget(\n          targetedItem,\n          dragTarget.dragLineLevel - 1,\n          draggedItems\n        );\n      }\n    }\n    const newIndex = dragTarget.dragLineIndex - 1 + direction;\n    const item = tree.getItems()[newIndex];\n    return item ? { item } : void 0;\n  }\n  const targetingExpandedFolder = getItemDropCategory(dragTarget.item) === 1 /* ExpandedFolder */;\n  if (targetingExpandedFolder && !isUp) {\n    return {\n      item: dragTarget.item,\n      childIndex: 0,\n      insertionIndex: getInsertionIndex(\n        dragTarget.item.getChildren(),\n        0,\n        draggedItems\n      ),\n      dragLineIndex: dragTarget.item.getItemMeta().index + direction,\n      dragLineLevel: dragTarget.item.getItemMeta().level + 1\n    };\n  }\n  const childIndex = dragTarget.item.getIndexInParent() + direction;\n  return {\n    item: dragTarget.item.getParent(),\n    childIndex,\n    insertionIndex: getInsertionIndex(\n      dragTarget.item.getParent().getChildren(),\n      childIndex,\n      draggedItems\n    ),\n    dragLineIndex: dragTarget.item.getItemMeta().index + direction,\n    dragLineLevel: dragTarget.item.getItemMeta().level\n  };\n};\nvar getNextValidDragTarget = (tree, isUp, previousTarget = ((_a) => (_a = tree.getState().dnd) == null ? void 0 : _a.dragTarget)()) => {\n  var _a2;\n  if (!previousTarget) return void 0;\n  const nextTarget = getNextDragTarget(tree, isUp, previousTarget);\n  const dataTransfer = (_a2 = tree.getDataRef().current.kDndDataTransfer) != null ? _a2 : null;\n  if (!nextTarget) return void 0;\n  if (canDrop(dataTransfer, nextTarget, tree)) {\n    return nextTarget;\n  }\n  return getNextValidDragTarget(tree, isUp, nextTarget);\n};\nvar updateScroll = (tree) => {\n  const state = tree.getState().dnd;\n  if (!(state == null ? void 0 : state.dragTarget) || isOrderedDragTarget(state.dragTarget)) return;\n  state.dragTarget.item.scrollTo({ block: \"nearest\", inline: \"nearest\" });\n};\nvar initiateDrag = (tree, draggedItems, dataTransfer) => {\n  var _a, _b;\n  const focusedItem = tree.getFocusedItem();\n  const { canDrag } = tree.getConfig();\n  if (draggedItems && canDrag && !canDrag(draggedItems)) {\n    return;\n  }\n  if (draggedItems) {\n    tree.applySubStateUpdate(\"dnd\", { draggedItems });\n    (_b = (_a = tree.getConfig()).onStartKeyboardDrag) == null ? void 0 : _b.call(_a, draggedItems);\n  } else if (dataTransfer) {\n    tree.getDataRef().current.kDndDataTransfer = dataTransfer;\n  }\n  const dragTarget = getNextValidDragTarget(tree, false, {\n    item: focusedItem\n  });\n  if (!dragTarget) return;\n  tree.applySubStateUpdate(\"dnd\", {\n    draggedItems,\n    dragTarget\n  });\n  tree.applySubStateUpdate(\"assistiveDndState\", 1 /* Started */);\n  updateScroll(tree);\n};\nvar moveDragPosition = (tree, isUp) => {\n  var _a;\n  const dragTarget = getNextValidDragTarget(tree, isUp);\n  if (!dragTarget) return;\n  tree.applySubStateUpdate(\"dnd\", {\n    draggedItems: (_a = tree.getState().dnd) == null ? void 0 : _a.draggedItems,\n    dragTarget\n  });\n  tree.applySubStateUpdate(\"assistiveDndState\", 2 /* Dragging */);\n  if (!isOrderedDragTarget(dragTarget)) {\n    dragTarget.item.setFocused();\n  }\n  updateScroll(tree);\n};\nvar keyboardDragAndDropFeature = {\n  key: \"keyboard-drag-and-drop\",\n  deps: [\"drag-and-drop\"],\n  getDefaultConfig: (defaultConfig, tree) => __spreadValues({\n    setAssistiveDndState: makeStateUpdater(\"assistiveDndState\", tree)\n  }, defaultConfig),\n  stateHandlerNames: {\n    assistiveDndState: \"setAssistiveDndState\"\n  },\n  treeInstance: {\n    startKeyboardDrag: ({ tree }, draggedItems) => {\n      initiateDrag(tree, draggedItems, void 0);\n    },\n    startKeyboardDragOnForeignObject: ({ tree }, dataTransfer) => {\n      initiateDrag(tree, void 0, dataTransfer);\n    },\n    stopKeyboardDrag: ({ tree }) => {\n      tree.getDataRef().current.kDndDataTransfer = void 0;\n      tree.applySubStateUpdate(\"dnd\", null);\n      tree.applySubStateUpdate(\"assistiveDndState\", 0 /* None */);\n    }\n  },\n  hotkeys: {\n    startDrag: {\n      hotkey: \"Control+Shift+KeyD\",\n      preventDefault: true,\n      isEnabled: (tree) => !tree.getState().dnd,\n      handler: (_, tree) => {\n        var _a, _b;\n        const selectedItems = (_b = (_a = tree.getSelectedItems) == null ? void 0 : _a.call(tree)) != null ? _b : [\n          tree.getFocusedItem()\n        ];\n        const focusedItem = tree.getFocusedItem();\n        tree.startKeyboardDrag(\n          selectedItems.includes(focusedItem) ? selectedItems : selectedItems.concat(focusedItem)\n        );\n      }\n    },\n    dragUp: {\n      hotkey: \"ArrowUp\",\n      preventDefault: true,\n      isEnabled: (tree) => !!tree.getState().dnd,\n      handler: (_, tree) => {\n        moveDragPosition(tree, true);\n      }\n    },\n    dragDown: {\n      hotkey: \"ArrowDown\",\n      preventDefault: true,\n      isEnabled: (tree) => !!tree.getState().dnd,\n      handler: (_, tree) => {\n        moveDragPosition(tree, false);\n      }\n    },\n    cancelDrag: {\n      hotkey: \"Escape\",\n      isEnabled: (tree) => !!tree.getState().dnd,\n      handler: (_, tree) => {\n        tree.stopKeyboardDrag();\n      }\n    },\n    completeDrag: {\n      hotkey: \"Enter\",\n      preventDefault: true,\n      isEnabled: (tree) => !!tree.getState().dnd,\n      handler: (e, tree) => __async(null, null, function* () {\n        var _a, _b, _c, _d;\n        e.stopPropagation();\n        const dataRef = tree.getDataRef();\n        const target = tree.getDragTarget();\n        const dataTransfer = (_a = dataRef.current.kDndDataTransfer) != null ? _a : null;\n        if (!target || !canDrop(dataTransfer, target, tree)) {\n          return;\n        }\n        const config = tree.getConfig();\n        const draggedItems = (_b = tree.getState().dnd) == null ? void 0 : _b.draggedItems;\n        dataRef.current.lastDragCode = void 0;\n        tree.applySubStateUpdate(\"dnd\", null);\n        if (draggedItems) {\n          yield (_c = config.onDrop) == null ? void 0 : _c.call(config, draggedItems, target);\n          tree.getItemInstance(draggedItems[0].getId()).setFocused();\n        } else if (dataTransfer) {\n          yield (_d = config.onDropForeignDragObject) == null ? void 0 : _d.call(config, dataTransfer, target);\n        }\n        tree.applySubStateUpdate(\n          \"assistiveDndState\",\n          3 /* Completed */\n        );\n      })\n    }\n  }\n};\n\n// src/features/search/feature.ts\nvar searchFeature = {\n  key: \"search\",\n  getInitialState: (initialState) => __spreadValues({\n    search: null\n  }, initialState),\n  getDefaultConfig: (defaultConfig, tree) => __spreadValues({\n    setSearch: makeStateUpdater(\"search\", tree),\n    isSearchMatchingItem: (search, item) => search.length > 0 && item.getItemName().toLowerCase().includes(search.toLowerCase())\n  }, defaultConfig),\n  stateHandlerNames: {\n    search: \"setSearch\"\n  },\n  treeInstance: {\n    setSearch: ({ tree }, search) => {\n      var _a;\n      tree.applySubStateUpdate(\"search\", search);\n      (_a = tree.getItems().find(\n        (item) => {\n          var _a2, _b;\n          return (_b = (_a2 = tree.getConfig()).isSearchMatchingItem) == null ? void 0 : _b.call(_a2, tree.getSearchValue(), item);\n        }\n      )) == null ? void 0 : _a.setFocused();\n    },\n    openSearch: ({ tree }, initialValue = \"\") => {\n      var _a, _b;\n      tree.setSearch(initialValue);\n      (_b = (_a = tree.getConfig()).onOpenSearch) == null ? void 0 : _b.call(_a);\n      setTimeout(() => {\n        var _a2;\n        (_a2 = tree.getDataRef().current.searchInput) == null ? void 0 : _a2.focus();\n      });\n    },\n    closeSearch: ({ tree }) => {\n      var _a, _b;\n      tree.setSearch(null);\n      (_b = (_a = tree.getConfig()).onCloseSearch) == null ? void 0 : _b.call(_a);\n      tree.updateDomFocus();\n    },\n    isSearchOpen: ({ tree }) => tree.getState().search !== null,\n    getSearchValue: ({ tree }) => tree.getState().search || \"\",\n    registerSearchInputElement: ({ tree }, element) => {\n      const dataRef = tree.getDataRef();\n      dataRef.current.searchInput = element;\n      if (element && dataRef.current.keydownHandler) {\n        element.addEventListener(\"keydown\", dataRef.current.keydownHandler);\n      }\n    },\n    getSearchInputElement: ({ tree }) => {\n      var _a;\n      return (_a = tree.getDataRef().current.searchInput) != null ? _a : null;\n    },\n    // TODO memoize with propMemoizationFeature\n    getSearchInputElementProps: ({ tree }) => ({\n      value: tree.getSearchValue(),\n      onChange: (e) => tree.setSearch(e.target.value),\n      onBlur: () => tree.closeSearch(),\n      ref: tree.registerSearchInputElement\n    }),\n    getSearchMatchingItems: memo(\n      ({ tree }) => [\n        tree.getSearchValue(),\n        tree.getItems(),\n        tree.getConfig().isSearchMatchingItem\n      ],\n      (search, items, isSearchMatchingItem) => items.filter((item) => search && (isSearchMatchingItem == null ? void 0 : isSearchMatchingItem(search, item)))\n    )\n  },\n  itemInstance: {\n    isMatchingSearch: ({ tree, item }) => tree.getSearchMatchingItems().some((i) => i.getId() === item.getId())\n  },\n  hotkeys: {\n    openSearch: {\n      hotkey: \"LetterOrNumber\",\n      preventDefault: true,\n      // TODO make true default\n      isEnabled: (tree) => !tree.isSearchOpen(),\n      handler: (e, tree) => {\n        e.stopPropagation();\n        tree.openSearch(e.key);\n      }\n    },\n    closeSearch: {\n      // TODO allow multiple, i.e. Enter\n      hotkey: \"Escape\",\n      allowWhenInputFocused: true,\n      isEnabled: (tree) => tree.isSearchOpen(),\n      handler: (e, tree) => {\n        tree.closeSearch();\n      }\n    },\n    submitSearch: {\n      hotkey: \"Enter\",\n      allowWhenInputFocused: true,\n      isEnabled: (tree) => tree.isSearchOpen(),\n      handler: (e, tree) => {\n        tree.closeSearch();\n        tree.setSelectedItems([tree.getFocusedItem().getId()]);\n      }\n    },\n    nextSearchItem: {\n      hotkey: \"ArrowDown\",\n      allowWhenInputFocused: true,\n      canRepeat: true,\n      isEnabled: (tree) => tree.isSearchOpen(),\n      handler: (e, tree) => {\n        const focusItem = tree.getSearchMatchingItems().find(\n          (item) => item.getItemMeta().index > tree.getFocusedItem().getItemMeta().index\n        );\n        focusItem == null ? void 0 : focusItem.setFocused();\n        focusItem == null ? void 0 : focusItem.scrollTo({ block: \"nearest\", inline: \"nearest\" });\n      }\n    },\n    previousSearchItem: {\n      hotkey: \"ArrowUp\",\n      allowWhenInputFocused: true,\n      canRepeat: true,\n      isEnabled: (tree) => tree.isSearchOpen(),\n      handler: (e, tree) => {\n        const focusItem = [...tree.getSearchMatchingItems()].reverse().find(\n          (item) => item.getItemMeta().index < tree.getFocusedItem().getItemMeta().index\n        );\n        focusItem == null ? void 0 : focusItem.setFocused();\n        focusItem == null ? void 0 : focusItem.scrollTo({ block: \"nearest\", inline: \"nearest\" });\n      }\n    }\n  }\n};\n\n// src/features/renaming/feature.ts\nvar renamingFeature = {\n  key: \"renaming\",\n  overwrites: [\"drag-and-drop\"],\n  getDefaultConfig: (defaultConfig, tree) => __spreadValues({\n    setRenamingItem: makeStateUpdater(\"renamingItem\", tree),\n    setRenamingValue: makeStateUpdater(\"renamingValue\", tree),\n    canRename: () => true\n  }, defaultConfig),\n  stateHandlerNames: {\n    renamingItem: \"setRenamingItem\",\n    renamingValue: \"setRenamingValue\"\n  },\n  treeInstance: {\n    getRenamingItem: ({ tree }) => {\n      const itemId = tree.getState().renamingItem;\n      return itemId ? tree.getItemInstance(itemId) : null;\n    },\n    getRenamingValue: ({ tree }) => tree.getState().renamingValue || \"\",\n    abortRenaming: ({ tree }) => {\n      tree.applySubStateUpdate(\"renamingItem\", null);\n      tree.updateDomFocus();\n    },\n    completeRenaming: ({ tree }) => {\n      var _a;\n      const config = tree.getConfig();\n      const item = tree.getRenamingItem();\n      if (item) {\n        (_a = config.onRename) == null ? void 0 : _a.call(config, item, tree.getState().renamingValue || \"\");\n      }\n      tree.applySubStateUpdate(\"renamingItem\", null);\n      tree.updateDomFocus();\n    },\n    isRenamingItem: ({ tree }) => !!tree.getState().renamingItem\n  },\n  itemInstance: {\n    startRenaming: ({ tree, item, itemId }) => {\n      if (!item.canRename()) {\n        return;\n      }\n      tree.applySubStateUpdate(\"renamingItem\", itemId);\n      tree.applySubStateUpdate(\"renamingValue\", item.getItemName());\n    },\n    getRenameInputProps: ({ tree }) => ({\n      ref: (r) => r == null ? void 0 : r.focus(),\n      onBlur: () => tree.abortRenaming(),\n      value: tree.getRenamingValue(),\n      onChange: (e) => {\n        var _a;\n        tree.applySubStateUpdate(\"renamingValue\", (_a = e.target) == null ? void 0 : _a.value);\n      }\n    }),\n    canRename: ({ tree, item }) => {\n      var _a, _b, _c;\n      return (_c = (_b = (_a = tree.getConfig()).canRename) == null ? void 0 : _b.call(_a, item)) != null ? _c : true;\n    },\n    isRenaming: ({ tree, item }) => item.getId() === tree.getState().renamingItem,\n    getProps: ({ prev, item }) => {\n      var _a;\n      const isRenaming = item.isRenaming();\n      const prevProps = (_a = prev == null ? void 0 : prev()) != null ? _a : {};\n      return isRenaming ? __spreadProps(__spreadValues({}, prevProps), {\n        draggable: false,\n        onDragStart: () => {\n        }\n      }) : prevProps;\n    }\n  },\n  hotkeys: {\n    renameItem: {\n      hotkey: \"F2\",\n      handler: (e, tree) => {\n        tree.getFocusedItem().startRenaming();\n      }\n    },\n    abortRenaming: {\n      hotkey: \"Escape\",\n      allowWhenInputFocused: true,\n      isEnabled: (tree) => tree.isRenamingItem(),\n      handler: (e, tree) => {\n        tree.abortRenaming();\n      }\n    },\n    completeRenaming: {\n      hotkey: \"Enter\",\n      allowWhenInputFocused: true,\n      isEnabled: (tree) => tree.isRenamingItem(),\n      handler: (e, tree) => {\n        tree.completeRenaming();\n      }\n    }\n  }\n};\n\n// src/features/expand-all/feature.ts\nvar expandAllFeature = {\n  key: \"expand-all\",\n  treeInstance: {\n    expandAll: (_0, _1) => __async(null, [_0, _1], function* ({ tree }, cancelToken) {\n      yield Promise.all(\n        tree.getItems().map((item) => item.expandAll(cancelToken))\n      );\n    }),\n    collapseAll: ({ tree }) => {\n      tree.applySubStateUpdate(\"expandedItems\", []);\n      tree.rebuildTree();\n    }\n  },\n  itemInstance: {\n    expandAll: (_0, _1) => __async(null, [_0, _1], function* ({ tree, item }, cancelToken) {\n      if (cancelToken == null ? void 0 : cancelToken.current) {\n        return;\n      }\n      if (!item.isFolder()) {\n        return;\n      }\n      item.expand();\n      yield tree.waitForItemChildrenLoaded(item.getId());\n      yield Promise.all(\n        item.getChildren().map((child) => __async(null, null, function* () {\n          yield tree.waitForItemChildrenLoaded(item.getId());\n          yield child == null ? void 0 : child.expandAll(cancelToken);\n        }))\n      );\n    }),\n    collapseAll: ({ item }) => {\n      if (!item.isExpanded()) return;\n      for (const child of item.getChildren()) {\n        child == null ? void 0 : child.collapseAll();\n      }\n      item.collapse();\n    }\n  },\n  hotkeys: {\n    expandSelected: {\n      hotkey: \"Control+Shift+Plus\",\n      handler: (_, tree) => __async(null, null, function* () {\n        const cancelToken = { current: false };\n        const cancelHandler = (e) => {\n          if (e.code === \"Escape\") {\n            cancelToken.current = true;\n          }\n        };\n        document.addEventListener(\"keydown\", cancelHandler);\n        yield Promise.all(\n          tree.getSelectedItems().map((item) => item.expandAll(cancelToken))\n        );\n        document.removeEventListener(\"keydown\", cancelHandler);\n      })\n    },\n    collapseSelected: {\n      hotkey: \"Control+Shift+Minus\",\n      handler: (_, tree) => {\n        tree.getSelectedItems().forEach((item) => item.collapseAll());\n      }\n    }\n  }\n};\n\n// src/features/prop-memoization/feature.ts\nvar memoize = (props, memoizedProps) => {\n  for (const key in props) {\n    if (typeof props[key] === \"function\") {\n      if (memoizedProps && key in memoizedProps) {\n        props[key] = memoizedProps[key];\n      } else {\n        memoizedProps[key] = props[key];\n      }\n    }\n  }\n  return props;\n};\nvar propMemoizationFeature = {\n  key: \"prop-memoization\",\n  overwrites: [\n    \"main\",\n    \"async-data-loader\",\n    \"sync-data-loader\",\n    \"drag-and-drop\",\n    \"expand-all\",\n    \"hotkeys-core\",\n    \"renaming\",\n    \"search\",\n    \"selection\"\n  ],\n  treeInstance: {\n    getContainerProps: ({ tree, prev }, treeLabel) => {\n      var _a, _b, _c, _d, _e;\n      const dataRef = tree.getDataRef();\n      const props = (_a = prev == null ? void 0 : prev(treeLabel)) != null ? _a : {};\n      (_c = (_b = dataRef.current).memo) != null ? _c : _b.memo = {};\n      (_e = (_d = dataRef.current.memo).tree) != null ? _e : _d.tree = {};\n      return memoize(props, dataRef.current.memo.tree);\n    },\n    getSearchInputElementProps: ({ tree, prev }) => {\n      var _a, _b, _c, _d, _e;\n      const dataRef = tree.getDataRef();\n      const props = (_a = prev == null ? void 0 : prev()) != null ? _a : {};\n      (_c = (_b = dataRef.current).memo) != null ? _c : _b.memo = {};\n      (_e = (_d = dataRef.current.memo).search) != null ? _e : _d.search = {};\n      return memoize(props, dataRef.current.memo.search);\n    }\n  },\n  itemInstance: {\n    getProps: ({ item, prev }) => {\n      var _a, _b, _c, _d, _e;\n      const dataRef = item.getDataRef();\n      const props = (_a = prev == null ? void 0 : prev()) != null ? _a : {};\n      (_c = (_b = dataRef.current).memo) != null ? _c : _b.memo = {};\n      (_e = (_d = dataRef.current.memo).item) != null ? _e : _d.item = {};\n      return memoize(props, dataRef.current.memo.item);\n    },\n    getRenameInputProps: ({ item, prev }) => {\n      var _a, _b, _c, _d, _e;\n      const dataRef = item.getDataRef();\n      const props = (_a = prev == null ? void 0 : prev()) != null ? _a : {};\n      (_c = (_b = dataRef.current).memo) != null ? _c : _b.memo = {};\n      (_e = (_d = dataRef.current.memo).rename) != null ? _e : _d.rename = {};\n      return memoize(props, dataRef.current.memo.rename);\n    }\n  }\n};\n\n// src/utilities/remove-items-from-parents.ts\nvar removeItemsFromParents = (movedItems, onChangeChildren) => __async(null, null, function* () {\n  const movedItemsIds = movedItems.map((item) => item.getId());\n  const uniqueParents = [\n    ...new Set(movedItems.map((item) => item.getParent()))\n  ];\n  for (const parent of uniqueParents) {\n    const siblings = parent == null ? void 0 : parent.getChildren();\n    if (siblings && parent) {\n      const newChildren = siblings.filter((sibling) => !movedItemsIds.includes(sibling.getId())).map((i) => i.getId());\n      yield onChangeChildren(parent, newChildren);\n      if (parent && \"updateCachedChildrenIds\" in parent) {\n        parent == null ? void 0 : parent.updateCachedChildrenIds(newChildren);\n      }\n    }\n  }\n  movedItems[0].getTree().rebuildTree();\n});\n\n// src/utilities/insert-items-at-target.ts\nvar insertItemsAtTarget = (itemIds, target, onChangeChildren) => __async(null, null, function* () {\n  yield target.item.getTree().waitForItemChildrenLoaded(target.item.getId());\n  const oldChildrenIds = target.item.getTree().retrieveChildrenIds(target.item.getId());\n  if (!(\"childIndex\" in target)) {\n    const newChildren2 = [...oldChildrenIds, ...itemIds];\n    yield onChangeChildren(target.item, newChildren2);\n    if (target.item && \"updateCachedChildrenIds\" in target.item) {\n      target.item.updateCachedChildrenIds(newChildren2);\n    }\n    target.item.getTree().rebuildTree();\n    return;\n  }\n  const newChildren = [\n    ...oldChildrenIds.slice(0, target.insertionIndex),\n    ...itemIds,\n    ...oldChildrenIds.slice(target.insertionIndex)\n  ];\n  yield onChangeChildren(target.item, newChildren);\n  if (target.item && \"updateCachedChildrenIds\" in target.item) {\n    target.item.updateCachedChildrenIds(newChildren);\n  }\n  target.item.getTree().rebuildTree();\n});\n\n// src/utilities/create-on-drop-handler.ts\nvar createOnDropHandler = (onChangeChildren) => (items, target) => __async(null, null, function* () {\n  const itemIds = items.map((item) => item.getId());\n  yield removeItemsFromParents(items, onChangeChildren);\n  yield insertItemsAtTarget(itemIds, target, onChangeChildren);\n});\n\n// src/core/build-proxified-instance.ts\nvar noop = () => {\n};\nvar findPrevInstanceMethod = (features, instanceType, methodKey, featureSearchIndex) => {\n  var _a;\n  for (let i = featureSearchIndex; i >= 0; i--) {\n    const feature = features[i];\n    const itemInstanceMethod = (_a = feature[instanceType]) == null ? void 0 : _a[methodKey];\n    if (itemInstanceMethod) {\n      return i;\n    }\n  }\n  return null;\n};\nvar invokeInstanceMethod = (features, instanceType, opts, methodKey, featureIndex, args) => {\n  var _a;\n  const prevIndex = findPrevInstanceMethod(\n    features,\n    instanceType,\n    methodKey,\n    featureIndex - 1\n  );\n  const itemInstanceMethod = (_a = features[featureIndex][instanceType]) == null ? void 0 : _a[methodKey];\n  return itemInstanceMethod(\n    __spreadProps(__spreadValues({}, opts), {\n      prev: prevIndex !== null ? (...newArgs) => invokeInstanceMethod(\n        features,\n        instanceType,\n        opts,\n        methodKey,\n        prevIndex,\n        newArgs\n      ) : null\n    }),\n    ...args\n  );\n};\nvar buildProxiedInstance = (features, instanceType, buildOpts) => {\n  const opts = {};\n  const item = new Proxy(\n    {},\n    {\n      has(target, key) {\n        if (typeof key === \"symbol\") {\n          return false;\n        }\n        if (key === \"toJSON\") {\n          return false;\n        }\n        const hasInstanceMethod = findPrevInstanceMethod(\n          features,\n          instanceType,\n          key,\n          features.length - 1\n        );\n        return Boolean(hasInstanceMethod);\n      },\n      get(target, key) {\n        if (typeof key === \"symbol\") {\n          return void 0;\n        }\n        if (key === \"toJSON\") {\n          return {};\n        }\n        return (...args) => {\n          const featureIndex = findPrevInstanceMethod(\n            features,\n            instanceType,\n            key,\n            features.length - 1\n          );\n          if (featureIndex === null) {\n            throw throwError(`feature missing for method ${key}`);\n          }\n          return invokeInstanceMethod(\n            features,\n            instanceType,\n            opts,\n            key,\n            featureIndex,\n            args\n          );\n        };\n      }\n    }\n  );\n  Object.assign(opts, buildOpts(item));\n  return [item, noop];\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AaGVhZGxlc3MtdHJlZS9jb3JlL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxxQkFBcUIsTUFBTTtBQUMzQixjQUFjLGFBQWE7QUFDM0IsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxlQUFlO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxtQ0FBbUMsWUFBWTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELElBQUk7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF3QkUiLCJzb3VyY2VzIjpbIi9Vc2Vycy90ZXJlY2FsL3VpLWludGVyYWNpdHZlLWxldjEvbXktYWRtaW4tcHJvamVjdC91aS1leGFtcGxlLWZyb250L25vZGVfbW9kdWxlcy9AaGVhZGxlc3MtdHJlZS9jb3JlL2Rpc3QvaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xudmFyIF9fYXN5bmMgPSAoX190aGlzLCBfX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdmFyIGZ1bGZpbGxlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVqZWN0ZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLnRocm93KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzdGVwID0gKHgpID0+IHguZG9uZSA/IHJlc29sdmUoeC52YWx1ZSkgOiBQcm9taXNlLnJlc29sdmUoeC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkoX190aGlzLCBfX2FyZ3VtZW50cykpLm5leHQoKSk7XG4gIH0pO1xufTtcblxuLy8gc3JjL3V0aWxzLnRzXG52YXIgbWVtbyA9IChkZXBzLCBmbikgPT4ge1xuICBsZXQgdmFsdWU7XG4gIGxldCBvbGREZXBzID0gbnVsbDtcbiAgcmV0dXJuICguLi5hKSA9PiB7XG4gICAgY29uc3QgbmV3RGVwcyA9IGRlcHMoLi4uYSk7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgdmFsdWUgPSBmbiguLi5uZXdEZXBzKTtcbiAgICAgIG9sZERlcHMgPSBuZXdEZXBzO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaCA9IG9sZERlcHMgJiYgb2xkRGVwcy5sZW5ndGggPT09IG5ld0RlcHMubGVuZ3RoICYmICFvbGREZXBzLnNvbWUoKGRlcCwgaSkgPT4gZGVwICE9PSBuZXdEZXBzW2ldKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgdmFsdWUgPSBmbiguLi5uZXdEZXBzKTtcbiAgICBvbGREZXBzID0gbmV3RGVwcztcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59O1xuZnVuY3Rpb24gZnVuY3Rpb25hbFVwZGF0ZSh1cGRhdGVyLCBpbnB1dCkge1xuICByZXR1cm4gdHlwZW9mIHVwZGF0ZXIgPT09IFwiZnVuY3Rpb25cIiA/IHVwZGF0ZXIoaW5wdXQpIDogdXBkYXRlcjtcbn1cbmZ1bmN0aW9uIG1ha2VTdGF0ZVVwZGF0ZXIoa2V5LCBpbnN0YW5jZSkge1xuICByZXR1cm4gKHVwZGF0ZXIpID0+IHtcbiAgICBpbnN0YW5jZS5zZXRTdGF0ZSgob2xkKSA9PiB7XG4gICAgICByZXR1cm4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb2xkKSwge1xuICAgICAgICBba2V5XTogZnVuY3Rpb25hbFVwZGF0ZSh1cGRhdGVyLCBvbGRba2V5XSlcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xufVxudmFyIHBvbGwgPSAoZm4sIGludGVydmFsID0gMTAwLCB0aW1lb3V0ID0gMWUzKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICBsZXQgY2xlYXI7XG4gIGNvbnN0IGkgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgaWYgKGZuKCkpIHtcbiAgICAgIHJlc29sdmUoKTtcbiAgICAgIGNsZWFySW50ZXJ2YWwoaSk7XG4gICAgICBjbGVhclRpbWVvdXQoY2xlYXIpO1xuICAgIH1cbiAgfSwgaW50ZXJ2YWwpO1xuICBjbGVhciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGNsZWFySW50ZXJ2YWwoaSk7XG4gIH0sIHRpbWVvdXQpO1xufSk7XG5cbi8vIHNyYy91dGlsaXRpZXMvZXJyb3JzLnRzXG52YXIgcHJlZml4ID0gXCJIZWFkbGVzcyBUcmVlOiBcIjtcbnZhciB0aHJvd0Vycm9yID0gKG1lc3NhZ2UpID0+IEVycm9yKHByZWZpeCArIG1lc3NhZ2UpO1xudmFyIGxvZ1dhcm5pbmcgPSAobWVzc2FnZSkgPT4gY29uc29sZS53YXJuKHByZWZpeCArIG1lc3NhZ2UpO1xuXG4vLyBzcmMvZmVhdHVyZXMvdHJlZS9mZWF0dXJlLnRzXG52YXIgdHJlZUZlYXR1cmUgPSB7XG4gIGtleTogXCJ0cmVlXCIsXG4gIGdldEluaXRpYWxTdGF0ZTogKGluaXRpYWxTdGF0ZSkgPT4gX19zcHJlYWRWYWx1ZXMoe1xuICAgIGV4cGFuZGVkSXRlbXM6IFtdLFxuICAgIGZvY3VzZWRJdGVtOiBudWxsXG4gIH0sIGluaXRpYWxTdGF0ZSksXG4gIGdldERlZmF1bHRDb25maWc6IChkZWZhdWx0Q29uZmlnLCB0cmVlKSA9PiBfX3NwcmVhZFZhbHVlcyh7XG4gICAgc2V0RXhwYW5kZWRJdGVtczogbWFrZVN0YXRlVXBkYXRlcihcImV4cGFuZGVkSXRlbXNcIiwgdHJlZSksXG4gICAgc2V0Rm9jdXNlZEl0ZW06IG1ha2VTdGF0ZVVwZGF0ZXIoXCJmb2N1c2VkSXRlbVwiLCB0cmVlKVxuICB9LCBkZWZhdWx0Q29uZmlnKSxcbiAgc3RhdGVIYW5kbGVyTmFtZXM6IHtcbiAgICBleHBhbmRlZEl0ZW1zOiBcInNldEV4cGFuZGVkSXRlbXNcIixcbiAgICBmb2N1c2VkSXRlbTogXCJzZXRGb2N1c2VkSXRlbVwiXG4gIH0sXG4gIHRyZWVJbnN0YW5jZToge1xuICAgIGdldEl0ZW1zTWV0YTogKHsgdHJlZSB9KSA9PiB7XG4gICAgICBjb25zdCB7IHJvb3RJdGVtSWQgfSA9IHRyZWUuZ2V0Q29uZmlnKCk7XG4gICAgICBjb25zdCB7IGV4cGFuZGVkSXRlbXMgfSA9IHRyZWUuZ2V0U3RhdGUoKTtcbiAgICAgIGNvbnN0IGZsYXRJdGVtcyA9IFtdO1xuICAgICAgY29uc3QgZXhwYW5kZWRJdGVtc1NldCA9IG5ldyBTZXQoZXhwYW5kZWRJdGVtcyk7XG4gICAgICBjb25zdCByZWN1cnNpdmVBZGQgPSAoaXRlbUlkLCBwYXRoLCBsZXZlbCwgc2V0U2l6ZSwgcG9zSW5TZXQpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAocGF0aC5pbmNsdWRlcyhpdGVtSWQpKSB7XG4gICAgICAgICAgbG9nV2FybmluZyhgQ2lyY3VsYXIgcmVmZXJlbmNlIGZvciAke3BhdGguam9pbihcIi5cIil9YCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZsYXRJdGVtcy5wdXNoKHtcbiAgICAgICAgICBpdGVtSWQsXG4gICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgaW5kZXg6IGZsYXRJdGVtcy5sZW5ndGgsXG4gICAgICAgICAgcGFyZW50SWQ6IHBhdGguYXQoLTEpLFxuICAgICAgICAgIHNldFNpemUsXG4gICAgICAgICAgcG9zSW5TZXRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChleHBhbmRlZEl0ZW1zU2V0LmhhcyhpdGVtSWQpKSB7XG4gICAgICAgICAgY29uc3QgY2hpbGRyZW4yID0gKF9hID0gdHJlZS5yZXRyaWV2ZUNoaWxkcmVuSWRzKGl0ZW1JZCkpICE9IG51bGwgPyBfYSA6IFtdO1xuICAgICAgICAgIGxldCBpMiA9IDA7XG4gICAgICAgICAgZm9yIChjb25zdCBjaGlsZElkIG9mIGNoaWxkcmVuMikge1xuICAgICAgICAgICAgcmVjdXJzaXZlQWRkKFxuICAgICAgICAgICAgICBjaGlsZElkLFxuICAgICAgICAgICAgICBwYXRoLmNvbmNhdChpdGVtSWQpLFxuICAgICAgICAgICAgICBsZXZlbCArIDEsXG4gICAgICAgICAgICAgIGNoaWxkcmVuMi5sZW5ndGgsXG4gICAgICAgICAgICAgIGkyKytcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSB0cmVlLnJldHJpZXZlQ2hpbGRyZW5JZHMocm9vdEl0ZW1JZCk7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBmb3IgKGNvbnN0IGl0ZW1JZCBvZiBjaGlsZHJlbikge1xuICAgICAgICByZWN1cnNpdmVBZGQoaXRlbUlkLCBbcm9vdEl0ZW1JZF0sIDAsIGNoaWxkcmVuLmxlbmd0aCwgaSsrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmbGF0SXRlbXM7XG4gICAgfSxcbiAgICBnZXRGb2N1c2VkSXRlbTogKHsgdHJlZSB9KSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBmb2N1c2VkSXRlbUlkID0gdHJlZS5nZXRTdGF0ZSgpLmZvY3VzZWRJdGVtO1xuICAgICAgcmV0dXJuIChfYSA9IGZvY3VzZWRJdGVtSWQgIT09IG51bGwgPyB0cmVlLmdldEl0ZW1JbnN0YW5jZShmb2N1c2VkSXRlbUlkKSA6IG51bGwpICE9IG51bGwgPyBfYSA6IHRyZWUuZ2V0SXRlbXMoKVswXTtcbiAgICB9LFxuICAgIGdldFJvb3RJdGVtOiAoeyB0cmVlIH0pID0+IHtcbiAgICAgIGNvbnN0IHsgcm9vdEl0ZW1JZCB9ID0gdHJlZS5nZXRDb25maWcoKTtcbiAgICAgIHJldHVybiB0cmVlLmdldEl0ZW1JbnN0YW5jZShyb290SXRlbUlkKTtcbiAgICB9LFxuICAgIGZvY3VzTmV4dEl0ZW06ICh7IHRyZWUgfSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgZm9jdXNlZCA9IHRyZWUuZ2V0Rm9jdXNlZEl0ZW0oKS5nZXRJdGVtTWV0YSgpO1xuICAgICAgaWYgKCFmb2N1c2VkKSByZXR1cm47XG4gICAgICBjb25zdCBuZXh0SW5kZXggPSBNYXRoLm1pbihmb2N1c2VkLmluZGV4ICsgMSwgdHJlZS5nZXRJdGVtcygpLmxlbmd0aCAtIDEpO1xuICAgICAgKF9hID0gdHJlZS5nZXRJdGVtcygpW25leHRJbmRleF0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5zZXRGb2N1c2VkKCk7XG4gICAgfSxcbiAgICBmb2N1c1ByZXZpb3VzSXRlbTogKHsgdHJlZSB9KSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBmb2N1c2VkID0gdHJlZS5nZXRGb2N1c2VkSXRlbSgpLmdldEl0ZW1NZXRhKCk7XG4gICAgICBpZiAoIWZvY3VzZWQpIHJldHVybjtcbiAgICAgIGNvbnN0IG5leHRJbmRleCA9IE1hdGgubWF4KGZvY3VzZWQuaW5kZXggLSAxLCAwKTtcbiAgICAgIChfYSA9IHRyZWUuZ2V0SXRlbXMoKVtuZXh0SW5kZXhdKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2V0Rm9jdXNlZCgpO1xuICAgIH0sXG4gICAgdXBkYXRlRG9tRm9jdXM6ICh7IHRyZWUgfSkgPT4ge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBfX2FzeW5jKG51bGwsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGZvY3VzZWRJdGVtID0gdHJlZS5nZXRGb2N1c2VkSXRlbSgpO1xuICAgICAgICAoX2IgPSAoX2EgPSB0cmVlLmdldENvbmZpZygpKS5zY3JvbGxUb0l0ZW0pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBmb2N1c2VkSXRlbSk7XG4gICAgICAgIHlpZWxkIHBvbGwoKCkgPT4gZm9jdXNlZEl0ZW0uZ2V0RWxlbWVudCgpICE9PSBudWxsLCAyMCk7XG4gICAgICAgIGNvbnN0IGZvY3VzZWRFbGVtZW50ID0gZm9jdXNlZEl0ZW0uZ2V0RWxlbWVudCgpO1xuICAgICAgICBpZiAoIWZvY3VzZWRFbGVtZW50KSByZXR1cm47XG4gICAgICAgIGZvY3VzZWRFbGVtZW50LmZvY3VzKCk7XG4gICAgICB9KSk7XG4gICAgfSxcbiAgICBnZXRDb250YWluZXJQcm9wczogKHsgcHJldiwgdHJlZSB9LCB0cmVlTGFiZWwpID0+IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHByZXYgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXYoKSksIHtcbiAgICAgIHJvbGU6IFwidHJlZVwiLFxuICAgICAgXCJhcmlhLWxhYmVsXCI6IHRyZWVMYWJlbCAhPSBudWxsID8gdHJlZUxhYmVsIDogXCJcIixcbiAgICAgIHJlZjogdHJlZS5yZWdpc3RlckVsZW1lbnRcbiAgICB9KSxcbiAgICAvLyByZWxldmFudCBmb3IgaG90a2V5cyBvZiB0aGlzIGZlYXR1cmVcbiAgICBpc1NlYXJjaE9wZW46ICgpID0+IGZhbHNlXG4gIH0sXG4gIGl0ZW1JbnN0YW5jZToge1xuICAgIHNjcm9sbFRvOiAoXzAsIF8xKSA9PiBfX2FzeW5jKG51bGwsIFtfMCwgXzFdLCBmdW5jdGlvbiogKHsgdHJlZSwgaXRlbSB9LCBzY3JvbGxJbnRvVmlld0FyZykge1xuICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAoX2IgPSAoX2EgPSB0cmVlLmdldENvbmZpZygpKS5zY3JvbGxUb0l0ZW0pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBpdGVtKTtcbiAgICAgIHlpZWxkIHBvbGwoKCkgPT4gaXRlbS5nZXRFbGVtZW50KCkgIT09IG51bGwsIDIwKTtcbiAgICAgIChfYyA9IGl0ZW0uZ2V0RWxlbWVudCgpKSA9PSBudWxsID8gdm9pZCAwIDogX2Muc2Nyb2xsSW50b1ZpZXcoc2Nyb2xsSW50b1ZpZXdBcmcpO1xuICAgIH0pLFxuICAgIGdldElkOiAoeyBpdGVtSWQgfSkgPT4gaXRlbUlkLFxuICAgIGdldEtleTogKHsgaXRlbUlkIH0pID0+IGl0ZW1JZCxcbiAgICAvLyBUT0RPIGFwcGx5IHRvIGFsbCBzdG9yaWVzIHRvIHVzZVxuICAgIGdldFByb3BzOiAoeyBpdGVtLCBwcmV2IH0pID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1NZXRhID0gaXRlbS5nZXRJdGVtTWV0YSgpO1xuICAgICAgcmV0dXJuIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHByZXYgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXYoKSksIHtcbiAgICAgICAgcmVmOiBpdGVtLnJlZ2lzdGVyRWxlbWVudCxcbiAgICAgICAgcm9sZTogXCJ0cmVlaXRlbVwiLFxuICAgICAgICBcImFyaWEtc2V0c2l6ZVwiOiBpdGVtTWV0YS5zZXRTaXplLFxuICAgICAgICBcImFyaWEtcG9zaW5zZXRcIjogaXRlbU1ldGEucG9zSW5TZXQgKyAxLFxuICAgICAgICBcImFyaWEtc2VsZWN0ZWRcIjogXCJmYWxzZVwiLFxuICAgICAgICBcImFyaWEtbGFiZWxcIjogaXRlbS5nZXRJdGVtTmFtZSgpLFxuICAgICAgICBcImFyaWEtbGV2ZWxcIjogaXRlbU1ldGEubGV2ZWwgKyAxLFxuICAgICAgICB0YWJJbmRleDogaXRlbS5pc0ZvY3VzZWQoKSA/IDAgOiAtMSxcbiAgICAgICAgb25DbGljazogKGUpID0+IHtcbiAgICAgICAgICBpdGVtLnNldEZvY3VzZWQoKTtcbiAgICAgICAgICBpdGVtLnByaW1hcnlBY3Rpb24oKTtcbiAgICAgICAgICBpZiAoZS5jdHJsS2V5IHx8IGUuc2hpZnRLZXkgfHwgZS5tZXRhS2V5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXRlbS5pc0ZvbGRlcigpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdGVtLmlzRXhwYW5kZWQoKSkge1xuICAgICAgICAgICAgaXRlbS5jb2xsYXBzZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtLmV4cGFuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBleHBhbmQ6ICh7IHRyZWUsIGl0ZW0sIGl0ZW1JZCB9KSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoIWl0ZW0uaXNGb2xkZXIoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoKF9hID0gdHJlZS5nZXRTdGF0ZSgpLmxvYWRpbmdJdGVtQ2hpbGRyZW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaW5jbHVkZXMoaXRlbUlkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0cmVlLmFwcGx5U3ViU3RhdGVVcGRhdGUoXCJleHBhbmRlZEl0ZW1zXCIsIChleHBhbmRlZEl0ZW1zKSA9PiBbXG4gICAgICAgIC4uLmV4cGFuZGVkSXRlbXMsXG4gICAgICAgIGl0ZW1JZFxuICAgICAgXSk7XG4gICAgICB0cmVlLnJlYnVpbGRUcmVlKCk7XG4gICAgfSxcbiAgICBjb2xsYXBzZTogKHsgdHJlZSwgaXRlbSwgaXRlbUlkIH0pID0+IHtcbiAgICAgIGlmICghaXRlbS5pc0ZvbGRlcigpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyZWUuYXBwbHlTdWJTdGF0ZVVwZGF0ZShcbiAgICAgICAgXCJleHBhbmRlZEl0ZW1zXCIsXG4gICAgICAgIChleHBhbmRlZEl0ZW1zKSA9PiBleHBhbmRlZEl0ZW1zLmZpbHRlcigoaWQpID0+IGlkICE9PSBpdGVtSWQpXG4gICAgICApO1xuICAgICAgdHJlZS5yZWJ1aWxkVHJlZSgpO1xuICAgIH0sXG4gICAgZ2V0SXRlbURhdGE6ICh7IHRyZWUsIGl0ZW1JZCB9KSA9PiB0cmVlLnJldHJpZXZlSXRlbURhdGEoaXRlbUlkKSxcbiAgICBlcXVhbHM6ICh7IGl0ZW0gfSwgb3RoZXIpID0+IGl0ZW0uZ2V0SWQoKSA9PT0gKG90aGVyID09IG51bGwgPyB2b2lkIDAgOiBvdGhlci5nZXRJZCgpKSxcbiAgICBpc0V4cGFuZGVkOiAoeyB0cmVlLCBpdGVtSWQgfSkgPT4gdHJlZS5nZXRTdGF0ZSgpLmV4cGFuZGVkSXRlbXMuaW5jbHVkZXMoaXRlbUlkKSxcbiAgICBpc0Rlc2NlbmRlbnRPZjogKHsgaXRlbSB9LCBwYXJlbnRJZCkgPT4ge1xuICAgICAgY29uc3QgcGFyZW50ID0gaXRlbS5nZXRQYXJlbnQoKTtcbiAgICAgIHJldHVybiBCb29sZWFuKFxuICAgICAgICAocGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwYXJlbnQuZ2V0SWQoKSkgPT09IHBhcmVudElkIHx8IChwYXJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmVudC5pc0Rlc2NlbmRlbnRPZihwYXJlbnRJZCkpXG4gICAgICApO1xuICAgIH0sXG4gICAgaXNGb2N1c2VkOiAoeyB0cmVlLCBpdGVtLCBpdGVtSWQgfSkgPT4gdHJlZS5nZXRTdGF0ZSgpLmZvY3VzZWRJdGVtID09PSBpdGVtSWQgfHwgdHJlZS5nZXRTdGF0ZSgpLmZvY3VzZWRJdGVtID09PSBudWxsICYmIGl0ZW0uZ2V0SXRlbU1ldGEoKS5pbmRleCA9PT0gMCxcbiAgICBpc0ZvbGRlcjogKHsgdHJlZSwgaXRlbSB9KSA9PiBpdGVtLmdldEl0ZW1NZXRhKCkubGV2ZWwgPT09IC0xIHx8IHRyZWUuZ2V0Q29uZmlnKCkuaXNJdGVtRm9sZGVyKGl0ZW0pLFxuICAgIGdldEl0ZW1OYW1lOiAoeyB0cmVlLCBpdGVtIH0pID0+IHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHRyZWUuZ2V0Q29uZmlnKCk7XG4gICAgICByZXR1cm4gY29uZmlnLmdldEl0ZW1OYW1lKGl0ZW0pO1xuICAgIH0sXG4gICAgc2V0Rm9jdXNlZDogKHsgdHJlZSwgaXRlbUlkIH0pID0+IHtcbiAgICAgIHRyZWUuYXBwbHlTdWJTdGF0ZVVwZGF0ZShcImZvY3VzZWRJdGVtXCIsIGl0ZW1JZCk7XG4gICAgfSxcbiAgICBwcmltYXJ5QWN0aW9uOiAoeyB0cmVlLCBpdGVtIH0pID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICByZXR1cm4gKF9iID0gKF9hID0gdHJlZS5nZXRDb25maWcoKSkub25QcmltYXJ5QWN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgaXRlbSk7XG4gICAgfSxcbiAgICBnZXRQYXJlbnQ6ICh7IHRyZWUsIGl0ZW0gfSkgPT4gaXRlbS5nZXRJdGVtTWV0YSgpLnBhcmVudElkID8gdHJlZS5nZXRJdGVtSW5zdGFuY2UoaXRlbS5nZXRJdGVtTWV0YSgpLnBhcmVudElkKSA6IHZvaWQgMCxcbiAgICBnZXRJbmRleEluUGFyZW50OiAoeyBpdGVtIH0pID0+IGl0ZW0uZ2V0SXRlbU1ldGEoKS5wb3NJblNldCxcbiAgICBnZXRDaGlsZHJlbjogKHsgdHJlZSwgaXRlbUlkIH0pID0+IHRyZWUucmV0cmlldmVDaGlsZHJlbklkcyhpdGVtSWQpLm1hcCgoaWQpID0+IHRyZWUuZ2V0SXRlbUluc3RhbmNlKGlkKSksXG4gICAgZ2V0VHJlZTogKHsgdHJlZSB9KSA9PiB0cmVlLFxuICAgIGdldEl0ZW1BYm92ZTogKHsgdHJlZSwgaXRlbSB9KSA9PiB0cmVlLmdldEl0ZW1zKClbaXRlbS5nZXRJdGVtTWV0YSgpLmluZGV4IC0gMV0sXG4gICAgZ2V0SXRlbUJlbG93OiAoeyB0cmVlLCBpdGVtIH0pID0+IHRyZWUuZ2V0SXRlbXMoKVtpdGVtLmdldEl0ZW1NZXRhKCkuaW5kZXggKyAxXVxuICB9LFxuICBob3RrZXlzOiB7XG4gICAgZm9jdXNOZXh0SXRlbToge1xuICAgICAgaG90a2V5OiBcIkFycm93RG93blwiLFxuICAgICAgY2FuUmVwZWF0OiB0cnVlLFxuICAgICAgcHJldmVudERlZmF1bHQ6IHRydWUsXG4gICAgICBpc0VuYWJsZWQ6ICh0cmVlKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAhKChfYiA9IChfYSA9IHRyZWUuaXNTZWFyY2hPcGVuKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbCh0cmVlKSkgIT0gbnVsbCA/IF9iIDogZmFsc2UpICYmICF0cmVlLmdldFN0YXRlKCkuZG5kO1xuICAgICAgfSxcbiAgICAgIC8vIFRPRE8gd2hhdCBoYXBwZW5zIHdoZW4gdGhlIGZlYXR1cmUgZG9lc250IGV4aXN0PyBwcm94eSBtZXRob2Qgc3RpbGwgY2xhaW1zIHRvIGV4aXN0XG4gICAgICBoYW5kbGVyOiAoZSwgdHJlZSkgPT4ge1xuICAgICAgICB0cmVlLmZvY3VzTmV4dEl0ZW0oKTtcbiAgICAgICAgdHJlZS51cGRhdGVEb21Gb2N1cygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZm9jdXNQcmV2aW91c0l0ZW06IHtcbiAgICAgIGhvdGtleTogXCJBcnJvd1VwXCIsXG4gICAgICBjYW5SZXBlYXQ6IHRydWUsXG4gICAgICBwcmV2ZW50RGVmYXVsdDogdHJ1ZSxcbiAgICAgIGlzRW5hYmxlZDogKHRyZWUpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuICEoKF9iID0gKF9hID0gdHJlZS5pc1NlYXJjaE9wZW4pID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKHRyZWUpKSAhPSBudWxsID8gX2IgOiBmYWxzZSkgJiYgIXRyZWUuZ2V0U3RhdGUoKS5kbmQ7XG4gICAgICB9LFxuICAgICAgaGFuZGxlcjogKGUsIHRyZWUpID0+IHtcbiAgICAgICAgdHJlZS5mb2N1c1ByZXZpb3VzSXRlbSgpO1xuICAgICAgICB0cmVlLnVwZGF0ZURvbUZvY3VzKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBleHBhbmRPckRvd246IHtcbiAgICAgIGhvdGtleTogXCJBcnJvd1JpZ2h0XCIsXG4gICAgICBjYW5SZXBlYXQ6IHRydWUsXG4gICAgICBoYW5kbGVyOiAoZSwgdHJlZSkgPT4ge1xuICAgICAgICBjb25zdCBpdGVtID0gdHJlZS5nZXRGb2N1c2VkSXRlbSgpO1xuICAgICAgICBpZiAoaXRlbS5pc0V4cGFuZGVkKCkgfHwgIWl0ZW0uaXNGb2xkZXIoKSkge1xuICAgICAgICAgIHRyZWUuZm9jdXNOZXh0SXRlbSgpO1xuICAgICAgICAgIHRyZWUudXBkYXRlRG9tRm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtLmV4cGFuZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjb2xsYXBzZU9yVXA6IHtcbiAgICAgIGhvdGtleTogXCJBcnJvd0xlZnRcIixcbiAgICAgIGNhblJlcGVhdDogdHJ1ZSxcbiAgICAgIGhhbmRsZXI6IChlLCB0cmVlKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRyZWUuZ2V0Rm9jdXNlZEl0ZW0oKTtcbiAgICAgICAgaWYgKCghaXRlbS5pc0V4cGFuZGVkKCkgfHwgIWl0ZW0uaXNGb2xkZXIoKSkgJiYgaXRlbS5nZXRJdGVtTWV0YSgpLmxldmVsICE9PSAwKSB7XG4gICAgICAgICAgKF9hID0gaXRlbS5nZXRQYXJlbnQoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNldEZvY3VzZWQoKTtcbiAgICAgICAgICB0cmVlLnVwZGF0ZURvbUZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbS5jb2xsYXBzZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBmb2N1c0ZpcnN0SXRlbToge1xuICAgICAgaG90a2V5OiBcIkhvbWVcIixcbiAgICAgIGhhbmRsZXI6IChlLCB0cmVlKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdHJlZS5nZXRJdGVtcygpWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2V0Rm9jdXNlZCgpO1xuICAgICAgICB0cmVlLnVwZGF0ZURvbUZvY3VzKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBmb2N1c0xhc3RJdGVtOiB7XG4gICAgICBob3RrZXk6IFwiRW5kXCIsXG4gICAgICBoYW5kbGVyOiAoZSwgdHJlZSkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRyZWUuZ2V0SXRlbXMoKVt0cmVlLmdldEl0ZW1zKCkubGVuZ3RoIC0gMV0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5zZXRGb2N1c2VkKCk7XG4gICAgICAgIHRyZWUudXBkYXRlRG9tRm9jdXMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9jb3JlL2J1aWxkLXN0YXRpYy1pbnN0YW5jZS50c1xudmFyIGJ1aWxkU3RhdGljSW5zdGFuY2UgPSAoZmVhdHVyZXMsIGluc3RhbmNlVHlwZSwgYnVpbGRPcHRzKSA9PiB7XG4gIGNvbnN0IGluc3RhbmNlID0ge307XG4gIGNvbnN0IGZpbmFsaXplID0gKCkgPT4ge1xuICAgIGNvbnN0IG9wdHMgPSBidWlsZE9wdHMoaW5zdGFuY2UpO1xuICAgIGZlYXR1cmVMb29wOiBmb3IgKGxldCBpID0gMDsgaSA8IGZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkZWZpbml0aW9uID0gZmVhdHVyZXNbaV1baW5zdGFuY2VUeXBlXTtcbiAgICAgIGlmICghZGVmaW5pdGlvbikgY29udGludWUgZmVhdHVyZUxvb3A7XG4gICAgICBtZXRob2RMb29wOiBmb3IgKGNvbnN0IFtrZXksIG1ldGhvZF0gb2YgT2JqZWN0LmVudHJpZXMoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgaWYgKCFtZXRob2QpIGNvbnRpbnVlIG1ldGhvZExvb3A7XG4gICAgICAgIGNvbnN0IHByZXYgPSBpbnN0YW5jZVtrZXldO1xuICAgICAgICBpbnN0YW5jZVtrZXldID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICByZXR1cm4gbWV0aG9kKF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdHMpLCB7IHByZXYgfSksIC4uLmFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFtpbnN0YW5jZSwgZmluYWxpemVdO1xufTtcblxuLy8gc3JjL2NvcmUvY3JlYXRlLXRyZWUudHNcbnZhciB2ZXJpZnlGZWF0dXJlcyA9IChmZWF0dXJlcykgPT4ge1xuICB2YXIgX2E7XG4gIGNvbnN0IGxvYWRlZEZlYXR1cmVzID0gZmVhdHVyZXMgPT0gbnVsbCA/IHZvaWQgMCA6IGZlYXR1cmVzLm1hcCgoZmVhdHVyZSkgPT4gZmVhdHVyZS5rZXkpO1xuICBmb3IgKGNvbnN0IGZlYXR1cmUgb2YgZmVhdHVyZXMgIT0gbnVsbCA/IGZlYXR1cmVzIDogW10pIHtcbiAgICBjb25zdCBtaXNzaW5nRGVwZW5kZW5jeSA9IChfYSA9IGZlYXR1cmUuZGVwcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmZpbmQoXG4gICAgICAoZGVwKSA9PiAhKGxvYWRlZEZlYXR1cmVzID09IG51bGwgPyB2b2lkIDAgOiBsb2FkZWRGZWF0dXJlcy5pbmNsdWRlcyhkZXApKVxuICAgICk7XG4gICAgaWYgKG1pc3NpbmdEZXBlbmRlbmN5KSB7XG4gICAgICB0aHJvdyB0aHJvd0Vycm9yKGAke2ZlYXR1cmUua2V5fSBuZWVkcyAke21pc3NpbmdEZXBlbmRlbmN5fWApO1xuICAgIH1cbiAgfVxufTtcbnZhciBleGhhdXN0aXZlU29ydCA9IChhcnIsIGNvbXBhcmVGbikgPT4ge1xuICBjb25zdCBuID0gYXJyLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBuOyBqKyspIHtcbiAgICAgIGlmIChjb21wYXJlRm4oYXJyW2pdLCBhcnJbaV0pIDwgMCkge1xuICAgICAgICBbYXJyW2ldLCBhcnJbal1dID0gW2FycltqXSwgYXJyW2ldXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG52YXIgY29tcGFyZUZlYXR1cmVzID0gKG9yaWdpbmFsT3JkZXIpID0+IChmZWF0dXJlMSwgZmVhdHVyZTIpID0+IHtcbiAgdmFyIF9hLCBfYjtcbiAgaWYgKGZlYXR1cmUyLmtleSAmJiAoKF9hID0gZmVhdHVyZTEub3ZlcndyaXRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKGZlYXR1cmUyLmtleSkpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgaWYgKGZlYXR1cmUxLmtleSAmJiAoKF9iID0gZmVhdHVyZTIub3ZlcndyaXRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmluY2x1ZGVzKGZlYXR1cmUxLmtleSkpKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHJldHVybiBvcmlnaW5hbE9yZGVyLmluZGV4T2YoZmVhdHVyZTEpIC0gb3JpZ2luYWxPcmRlci5pbmRleE9mKGZlYXR1cmUyKTtcbn07XG52YXIgc29ydEZlYXR1cmVzID0gKGZlYXR1cmVzID0gW10pID0+IGV4aGF1c3RpdmVTb3J0KGZlYXR1cmVzLCBjb21wYXJlRmVhdHVyZXMoZmVhdHVyZXMpKTtcbnZhciBjcmVhdGVUcmVlID0gKGluaXRpYWxDb25maWcpID0+IHtcbiAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICBjb25zdCBidWlsZEluc3RhbmNlID0gKF9hID0gaW5pdGlhbENvbmZpZy5pbnN0YW5jZUJ1aWxkZXIpICE9IG51bGwgPyBfYSA6IGJ1aWxkU3RhdGljSW5zdGFuY2U7XG4gIGNvbnN0IGFkZGl0aW9uYWxGZWF0dXJlcyA9IFtcbiAgICB0cmVlRmVhdHVyZSxcbiAgICAuLi5zb3J0RmVhdHVyZXMoaW5pdGlhbENvbmZpZy5mZWF0dXJlcylcbiAgXTtcbiAgdmVyaWZ5RmVhdHVyZXMoYWRkaXRpb25hbEZlYXR1cmVzKTtcbiAgY29uc3QgZmVhdHVyZXMgPSBbLi4uYWRkaXRpb25hbEZlYXR1cmVzXTtcbiAgY29uc3QgW3RyZWVJbnN0YW5jZSwgZmluYWxpemVUcmVlXSA9IGJ1aWxkSW5zdGFuY2UoXG4gICAgZmVhdHVyZXMsXG4gICAgXCJ0cmVlSW5zdGFuY2VcIixcbiAgICAodHJlZSkgPT4gKHsgdHJlZSB9KVxuICApO1xuICBsZXQgc3RhdGUgPSBhZGRpdGlvbmFsRmVhdHVyZXMucmVkdWNlKFxuICAgIChhY2MsIGZlYXR1cmUpID0+IHtcbiAgICAgIHZhciBfYTIsIF9iMjtcbiAgICAgIHJldHVybiAoX2IyID0gKF9hMiA9IGZlYXR1cmUuZ2V0SW5pdGlhbFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNhbGwoZmVhdHVyZSwgYWNjLCB0cmVlSW5zdGFuY2UpKSAhPSBudWxsID8gX2IyIDogYWNjO1xuICAgIH0sXG4gICAgKF9jID0gKF9iID0gaW5pdGlhbENvbmZpZy5pbml0aWFsU3RhdGUpICE9IG51bGwgPyBfYiA6IGluaXRpYWxDb25maWcuc3RhdGUpICE9IG51bGwgPyBfYyA6IHt9XG4gICk7XG4gIGxldCBjb25maWcgPSBhZGRpdGlvbmFsRmVhdHVyZXMucmVkdWNlKFxuICAgIChhY2MsIGZlYXR1cmUpID0+IHtcbiAgICAgIHZhciBfYTIsIF9iMjtcbiAgICAgIHJldHVybiAoX2IyID0gKF9hMiA9IGZlYXR1cmUuZ2V0RGVmYXVsdENvbmZpZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jYWxsKGZlYXR1cmUsIGFjYywgdHJlZUluc3RhbmNlKSkgIT0gbnVsbCA/IF9iMiA6IGFjYztcbiAgICB9LFxuICAgIGluaXRpYWxDb25maWdcbiAgKTtcbiAgY29uc3Qgc3RhdGVIYW5kbGVyTmFtZXMgPSBhZGRpdGlvbmFsRmVhdHVyZXMucmVkdWNlKFxuICAgIChhY2MsIGZlYXR1cmUpID0+IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBhY2MpLCBmZWF0dXJlLnN0YXRlSGFuZGxlck5hbWVzKSxcbiAgICB7fVxuICApO1xuICBsZXQgdHJlZUVsZW1lbnQ7XG4gIGNvbnN0IHRyZWVEYXRhUmVmID0geyBjdXJyZW50OiB7fSB9O1xuICBjb25zdCBpdGVtSW5zdGFuY2VzTWFwID0ge307XG4gIGxldCBpdGVtSW5zdGFuY2VzID0gW107XG4gIGNvbnN0IGl0ZW1FbGVtZW50c01hcCA9IHt9O1xuICBjb25zdCBpdGVtRGF0YVJlZnMgPSB7fTtcbiAgbGV0IGl0ZW1NZXRhTWFwID0ge307XG4gIGNvbnN0IGhvdGtleVByZXNldHMgPSB7fTtcbiAgY29uc3QgcmVidWlsZEl0ZW1NZXRhID0gKCkgPT4ge1xuICAgIGl0ZW1JbnN0YW5jZXMgPSBbXTtcbiAgICBpdGVtTWV0YU1hcCA9IHt9O1xuICAgIGNvbnN0IFtyb290SW5zdGFuY2UsIGZpbmFsaXplUm9vdEluc3RhbmNlXSA9IGJ1aWxkSW5zdGFuY2UoXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIFwiaXRlbUluc3RhbmNlXCIsXG4gICAgICAoaXRlbSkgPT4gKHsgaXRlbSwgdHJlZTogdHJlZUluc3RhbmNlLCBpdGVtSWQ6IGNvbmZpZy5yb290SXRlbUlkIH0pXG4gICAgKTtcbiAgICBmaW5hbGl6ZVJvb3RJbnN0YW5jZSgpO1xuICAgIGl0ZW1JbnN0YW5jZXNNYXBbY29uZmlnLnJvb3RJdGVtSWRdID0gcm9vdEluc3RhbmNlO1xuICAgIGl0ZW1NZXRhTWFwW2NvbmZpZy5yb290SXRlbUlkXSA9IHtcbiAgICAgIGl0ZW1JZDogY29uZmlnLnJvb3RJdGVtSWQsXG4gICAgICBpbmRleDogLTEsXG4gICAgICBwYXJlbnRJZDogbnVsbCxcbiAgICAgIGxldmVsOiAtMSxcbiAgICAgIHBvc0luU2V0OiAwLFxuICAgICAgc2V0U2l6ZTogMVxuICAgIH07XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRyZWVJbnN0YW5jZS5nZXRJdGVtc01ldGEoKSkge1xuICAgICAgaXRlbU1ldGFNYXBbaXRlbS5pdGVtSWRdID0gaXRlbTtcbiAgICAgIGlmICghaXRlbUluc3RhbmNlc01hcFtpdGVtLml0ZW1JZF0pIHtcbiAgICAgICAgY29uc3QgW2luc3RhbmNlLCBmaW5hbGl6ZUluc3RhbmNlXSA9IGJ1aWxkSW5zdGFuY2UoXG4gICAgICAgICAgZmVhdHVyZXMsXG4gICAgICAgICAgXCJpdGVtSW5zdGFuY2VcIixcbiAgICAgICAgICAoaW5zdGFuY2UyKSA9PiAoe1xuICAgICAgICAgICAgaXRlbTogaW5zdGFuY2UyLFxuICAgICAgICAgICAgdHJlZTogdHJlZUluc3RhbmNlLFxuICAgICAgICAgICAgaXRlbUlkOiBpdGVtLml0ZW1JZFxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIGZpbmFsaXplSW5zdGFuY2UoKTtcbiAgICAgICAgaXRlbUluc3RhbmNlc01hcFtpdGVtLml0ZW1JZF0gPSBpbnN0YW5jZTtcbiAgICAgICAgaXRlbUluc3RhbmNlcy5wdXNoKGluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW1JbnN0YW5jZXMucHVzaChpdGVtSW5zdGFuY2VzTWFwW2l0ZW0uaXRlbUlkXSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBlYWNoRmVhdHVyZSA9IChmbikgPT4ge1xuICAgIGZvciAoY29uc3QgZmVhdHVyZSBvZiBhZGRpdGlvbmFsRmVhdHVyZXMpIHtcbiAgICAgIGZuKGZlYXR1cmUpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbWFpbkZlYXR1cmUgPSB7XG4gICAga2V5OiBcIm1haW5cIixcbiAgICB0cmVlSW5zdGFuY2U6IHtcbiAgICAgIGdldFN0YXRlOiAoKSA9PiBzdGF0ZSxcbiAgICAgIHNldFN0YXRlOiAoe30sIHVwZGF0ZXIpID0+IHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgKF9hMiA9IGNvbmZpZy5zZXRTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jYWxsKGNvbmZpZywgc3RhdGUpO1xuICAgICAgfSxcbiAgICAgIGFwcGx5U3ViU3RhdGVVcGRhdGU6ICh7fSwgc3RhdGVOYW1lLCB1cGRhdGVyKSA9PiB7XG4gICAgICAgIHN0YXRlW3N0YXRlTmFtZV0gPSB0eXBlb2YgdXBkYXRlciA9PT0gXCJmdW5jdGlvblwiID8gdXBkYXRlcihzdGF0ZVtzdGF0ZU5hbWVdKSA6IHVwZGF0ZXI7XG4gICAgICAgIGNvbnN0IGV4dGVybmFsU3RhdGVTZXR0ZXIgPSBjb25maWdbc3RhdGVIYW5kbGVyTmFtZXNbc3RhdGVOYW1lXV07XG4gICAgICAgIGV4dGVybmFsU3RhdGVTZXR0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGV4dGVybmFsU3RhdGVTZXR0ZXIoc3RhdGVbc3RhdGVOYW1lXSk7XG4gICAgICB9LFxuICAgICAgLy8gVE9ETyByZWJ1aWxkU3ViVHJlZTogKGl0ZW1JZDogc3RyaW5nKSA9PiB2b2lkO1xuICAgICAgcmVidWlsZFRyZWU6ICgpID0+IHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgcmVidWlsZEl0ZW1NZXRhKCk7XG4gICAgICAgIChfYTIgPSBjb25maWcuc2V0U3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY2FsbChjb25maWcsIHN0YXRlKTtcbiAgICAgIH0sXG4gICAgICBnZXRDb25maWc6ICgpID0+IGNvbmZpZyxcbiAgICAgIHNldENvbmZpZzogKF8sIHVwZGF0ZXIpID0+IHtcbiAgICAgICAgdmFyIF9hMiwgX2IyLCBfYzI7XG4gICAgICAgIGNvbnN0IG5ld0NvbmZpZyA9IHR5cGVvZiB1cGRhdGVyID09PSBcImZ1bmN0aW9uXCIgPyB1cGRhdGVyKGNvbmZpZykgOiB1cGRhdGVyO1xuICAgICAgICBjb25zdCBoYXNDaGFuZ2VkRXhwYW5kZWRJdGVtcyA9ICgoX2EyID0gbmV3Q29uZmlnLnN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmV4cGFuZGVkSXRlbXMpICYmICgoX2IyID0gbmV3Q29uZmlnLnN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLmV4cGFuZGVkSXRlbXMpICE9PSBzdGF0ZS5leHBhbmRlZEl0ZW1zO1xuICAgICAgICBjb25maWcgPSBuZXdDb25maWc7XG4gICAgICAgIGlmIChuZXdDb25maWcuc3RhdGUpIHtcbiAgICAgICAgICBzdGF0ZSA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBzdGF0ZSksIG5ld0NvbmZpZy5zdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0NoYW5nZWRFeHBhbmRlZEl0ZW1zKSB7XG4gICAgICAgICAgcmVidWlsZEl0ZW1NZXRhKCk7XG4gICAgICAgICAgKF9jMiA9IGNvbmZpZy5zZXRTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jMi5jYWxsKGNvbmZpZywgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ2V0SXRlbUluc3RhbmNlOiAoe30sIGl0ZW1JZCkgPT4ge1xuICAgICAgICBjb25zdCBleGlzdGluZ0luc3RhbmNlID0gaXRlbUluc3RhbmNlc01hcFtpdGVtSWRdO1xuICAgICAgICBpZiAoIWV4aXN0aW5nSW5zdGFuY2UpIHtcbiAgICAgICAgICBjb25zdCBbaW5zdGFuY2UsIGZpbmFsaXplSW5zdGFuY2VdID0gYnVpbGRJbnN0YW5jZShcbiAgICAgICAgICAgIGZlYXR1cmVzLFxuICAgICAgICAgICAgXCJpdGVtSW5zdGFuY2VcIixcbiAgICAgICAgICAgIChpbnN0YW5jZTIpID0+ICh7XG4gICAgICAgICAgICAgIGl0ZW06IGluc3RhbmNlMixcbiAgICAgICAgICAgICAgdHJlZTogdHJlZUluc3RhbmNlLFxuICAgICAgICAgICAgICBpdGVtSWRcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICBmaW5hbGl6ZUluc3RhbmNlKCk7XG4gICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleGlzdGluZ0luc3RhbmNlO1xuICAgICAgfSxcbiAgICAgIGdldEl0ZW1zOiAoKSA9PiBpdGVtSW5zdGFuY2VzLFxuICAgICAgcmVnaXN0ZXJFbGVtZW50OiAoe30sIGVsZW1lbnQpID0+IHtcbiAgICAgICAgaWYgKHRyZWVFbGVtZW50ID09PSBlbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmVlRWxlbWVudCAmJiAhZWxlbWVudCkge1xuICAgICAgICAgIGVhY2hGZWF0dXJlKFxuICAgICAgICAgICAgKGZlYXR1cmUpID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgICAgICAgcmV0dXJuIChfYTIgPSBmZWF0dXJlLm9uVHJlZVVubW91bnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY2FsbChmZWF0dXJlLCB0cmVlSW5zdGFuY2UsIHRyZWVFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKCF0cmVlRWxlbWVudCAmJiBlbGVtZW50KSB7XG4gICAgICAgICAgZWFjaEZlYXR1cmUoXG4gICAgICAgICAgICAoZmVhdHVyZSkgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2EyO1xuICAgICAgICAgICAgICByZXR1cm4gKF9hMiA9IGZlYXR1cmUub25UcmVlTW91bnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY2FsbChmZWF0dXJlLCB0cmVlSW5zdGFuY2UsIGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdHJlZUVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgfSxcbiAgICAgIGdldEVsZW1lbnQ6ICgpID0+IHRyZWVFbGVtZW50LFxuICAgICAgZ2V0RGF0YVJlZjogKCkgPT4gdHJlZURhdGFSZWYsXG4gICAgICBnZXRIb3RrZXlQcmVzZXRzOiAoKSA9PiBob3RrZXlQcmVzZXRzXG4gICAgfSxcbiAgICBpdGVtSW5zdGFuY2U6IHtcbiAgICAgIHJlZ2lzdGVyRWxlbWVudDogKHsgaXRlbUlkLCBpdGVtIH0sIGVsZW1lbnQpID0+IHtcbiAgICAgICAgaWYgKGl0ZW1FbGVtZW50c01hcFtpdGVtSWRdID09PSBlbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9sZEVsZW1lbnQgPSBpdGVtRWxlbWVudHNNYXBbaXRlbUlkXTtcbiAgICAgICAgaWYgKG9sZEVsZW1lbnQgJiYgIWVsZW1lbnQpIHtcbiAgICAgICAgICBlYWNoRmVhdHVyZShcbiAgICAgICAgICAgIChmZWF0dXJlKSA9PiB7XG4gICAgICAgICAgICAgIHZhciBfYTI7XG4gICAgICAgICAgICAgIHJldHVybiAoX2EyID0gZmVhdHVyZS5vbkl0ZW1Vbm1vdW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNhbGwoZmVhdHVyZSwgaXRlbSwgb2xkRWxlbWVudCwgdHJlZUluc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKCFvbGRFbGVtZW50ICYmIGVsZW1lbnQpIHtcbiAgICAgICAgICBlYWNoRmVhdHVyZShcbiAgICAgICAgICAgIChmZWF0dXJlKSA9PiB7XG4gICAgICAgICAgICAgIHZhciBfYTI7XG4gICAgICAgICAgICAgIHJldHVybiAoX2EyID0gZmVhdHVyZS5vbkl0ZW1Nb3VudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jYWxsKGZlYXR1cmUsIGl0ZW0sIGVsZW1lbnQsIHRyZWVJbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpdGVtRWxlbWVudHNNYXBbaXRlbUlkXSA9IGVsZW1lbnQ7XG4gICAgICB9LFxuICAgICAgZ2V0RWxlbWVudDogKHsgaXRlbUlkIH0pID0+IGl0ZW1FbGVtZW50c01hcFtpdGVtSWRdLFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJldHVybi1hc3NpZ25cbiAgICAgIGdldERhdGFSZWY6ICh7IGl0ZW1JZCB9KSA9PiB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIHJldHVybiAoX2EyID0gaXRlbURhdGFSZWZzW2l0ZW1JZF0pICE9IG51bGwgPyBfYTIgOiBpdGVtRGF0YVJlZnNbaXRlbUlkXSA9IHsgY3VycmVudDoge30gfTtcbiAgICAgIH0sXG4gICAgICBnZXRJdGVtTWV0YTogKHsgaXRlbUlkIH0pID0+IHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgcmV0dXJuIChfYTIgPSBpdGVtTWV0YU1hcFtpdGVtSWRdKSAhPSBudWxsID8gX2EyIDoge1xuICAgICAgICAgIGl0ZW1JZCxcbiAgICAgICAgICBwYXJlbnRJZDogbnVsbCxcbiAgICAgICAgICBsZXZlbDogLTEsXG4gICAgICAgICAgaW5kZXg6IC0xLFxuICAgICAgICAgIHBvc0luU2V0OiAwLFxuICAgICAgICAgIHNldFNpemU6IDFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGZlYXR1cmVzLnVuc2hpZnQobWFpbkZlYXR1cmUpO1xuICBmb3IgKGNvbnN0IGZlYXR1cmUgb2YgZmVhdHVyZXMpIHtcbiAgICBPYmplY3QuYXNzaWduKGhvdGtleVByZXNldHMsIChfZCA9IGZlYXR1cmUuaG90a2V5cykgIT0gbnVsbCA/IF9kIDoge30pO1xuICB9XG4gIGZpbmFsaXplVHJlZSgpO1xuICByZXR1cm4gdHJlZUluc3RhbmNlO1xufTtcblxuLy8gc3JjL2ZlYXR1cmVzL2RyYWctYW5kLWRyb3AvdHlwZXMudHNcbnZhciBEcmFnVGFyZ2V0UG9zaXRpb24gPSAvKiBAX19QVVJFX18gKi8gKChEcmFnVGFyZ2V0UG9zaXRpb24yKSA9PiB7XG4gIERyYWdUYXJnZXRQb3NpdGlvbjJbXCJUb3BcIl0gPSBcInRvcFwiO1xuICBEcmFnVGFyZ2V0UG9zaXRpb24yW1wiQm90dG9tXCJdID0gXCJib3R0b21cIjtcbiAgRHJhZ1RhcmdldFBvc2l0aW9uMltcIkl0ZW1cIl0gPSBcIml0ZW1cIjtcbiAgcmV0dXJuIERyYWdUYXJnZXRQb3NpdGlvbjI7XG59KShEcmFnVGFyZ2V0UG9zaXRpb24gfHwge30pO1xuXG4vLyBzcmMvZmVhdHVyZXMva2V5Ym9hcmQtZHJhZy1hbmQtZHJvcC90eXBlcy50c1xudmFyIEFzc2lzdGl2ZURuZFN0YXRlID0gLyogQF9fUFVSRV9fICovICgoQXNzaXN0aXZlRG5kU3RhdGUyKSA9PiB7XG4gIEFzc2lzdGl2ZURuZFN0YXRlMltBc3Npc3RpdmVEbmRTdGF0ZTJbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgQXNzaXN0aXZlRG5kU3RhdGUyW0Fzc2lzdGl2ZURuZFN0YXRlMltcIlN0YXJ0ZWRcIl0gPSAxXSA9IFwiU3RhcnRlZFwiO1xuICBBc3Npc3RpdmVEbmRTdGF0ZTJbQXNzaXN0aXZlRG5kU3RhdGUyW1wiRHJhZ2dpbmdcIl0gPSAyXSA9IFwiRHJhZ2dpbmdcIjtcbiAgQXNzaXN0aXZlRG5kU3RhdGUyW0Fzc2lzdGl2ZURuZFN0YXRlMltcIkNvbXBsZXRlZFwiXSA9IDNdID0gXCJDb21wbGV0ZWRcIjtcbiAgQXNzaXN0aXZlRG5kU3RhdGUyW0Fzc2lzdGl2ZURuZFN0YXRlMltcIkFib3J0ZWRcIl0gPSA0XSA9IFwiQWJvcnRlZFwiO1xuICByZXR1cm4gQXNzaXN0aXZlRG5kU3RhdGUyO1xufSkoQXNzaXN0aXZlRG5kU3RhdGUgfHwge30pO1xuXG4vLyBzcmMvZmVhdHVyZXMvY2hlY2tib3hlcy90eXBlcy50c1xudmFyIENoZWNrZWRTdGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKENoZWNrZWRTdGF0ZTIpID0+IHtcbiAgQ2hlY2tlZFN0YXRlMltcIkNoZWNrZWRcIl0gPSBcImNoZWNrZWRcIjtcbiAgQ2hlY2tlZFN0YXRlMltcIlVuY2hlY2tlZFwiXSA9IFwidW5jaGVja2VkXCI7XG4gIENoZWNrZWRTdGF0ZTJbXCJJbmRldGVybWluYXRlXCJdID0gXCJpbmRldGVybWluYXRlXCI7XG4gIHJldHVybiBDaGVja2VkU3RhdGUyO1xufSkoQ2hlY2tlZFN0YXRlIHx8IHt9KTtcblxuLy8gc3JjL2ZlYXR1cmVzL3NlbGVjdGlvbi9mZWF0dXJlLnRzXG52YXIgc2VsZWN0aW9uRmVhdHVyZSA9IHtcbiAga2V5OiBcInNlbGVjdGlvblwiLFxuICBnZXRJbml0aWFsU3RhdGU6IChpbml0aWFsU3RhdGUpID0+IF9fc3ByZWFkVmFsdWVzKHtcbiAgICBzZWxlY3RlZEl0ZW1zOiBbXVxuICB9LCBpbml0aWFsU3RhdGUpLFxuICBnZXREZWZhdWx0Q29uZmlnOiAoZGVmYXVsdENvbmZpZywgdHJlZSkgPT4gX19zcHJlYWRWYWx1ZXMoe1xuICAgIHNldFNlbGVjdGVkSXRlbXM6IG1ha2VTdGF0ZVVwZGF0ZXIoXCJzZWxlY3RlZEl0ZW1zXCIsIHRyZWUpXG4gIH0sIGRlZmF1bHRDb25maWcpLFxuICBzdGF0ZUhhbmRsZXJOYW1lczoge1xuICAgIHNlbGVjdGVkSXRlbXM6IFwic2V0U2VsZWN0ZWRJdGVtc1wiXG4gIH0sXG4gIHRyZWVJbnN0YW5jZToge1xuICAgIHNldFNlbGVjdGVkSXRlbXM6ICh7IHRyZWUgfSwgc2VsZWN0ZWRJdGVtcykgPT4ge1xuICAgICAgdHJlZS5hcHBseVN1YlN0YXRlVXBkYXRlKFwic2VsZWN0ZWRJdGVtc1wiLCBzZWxlY3RlZEl0ZW1zKTtcbiAgICB9LFxuICAgIGdldFNlbGVjdGVkSXRlbXM6ICh7IHRyZWUgfSkgPT4ge1xuICAgICAgcmV0dXJuIHRyZWUuZ2V0U3RhdGUoKS5zZWxlY3RlZEl0ZW1zLm1hcCh0cmVlLmdldEl0ZW1JbnN0YW5jZSk7XG4gICAgfVxuICB9LFxuICBpdGVtSW5zdGFuY2U6IHtcbiAgICBzZWxlY3Q6ICh7IHRyZWUsIGl0ZW1JZCB9KSA9PiB7XG4gICAgICBjb25zdCB7IHNlbGVjdGVkSXRlbXMgfSA9IHRyZWUuZ2V0U3RhdGUoKTtcbiAgICAgIHRyZWUuc2V0U2VsZWN0ZWRJdGVtcyhcbiAgICAgICAgc2VsZWN0ZWRJdGVtcy5pbmNsdWRlcyhpdGVtSWQpID8gc2VsZWN0ZWRJdGVtcyA6IFsuLi5zZWxlY3RlZEl0ZW1zLCBpdGVtSWRdXG4gICAgICApO1xuICAgIH0sXG4gICAgZGVzZWxlY3Q6ICh7IHRyZWUsIGl0ZW1JZCB9KSA9PiB7XG4gICAgICBjb25zdCB7IHNlbGVjdGVkSXRlbXMgfSA9IHRyZWUuZ2V0U3RhdGUoKTtcbiAgICAgIHRyZWUuc2V0U2VsZWN0ZWRJdGVtcyhzZWxlY3RlZEl0ZW1zLmZpbHRlcigoaWQpID0+IGlkICE9PSBpdGVtSWQpKTtcbiAgICB9LFxuICAgIGlzU2VsZWN0ZWQ6ICh7IHRyZWUsIGl0ZW1JZCB9KSA9PiB7XG4gICAgICBjb25zdCB7IHNlbGVjdGVkSXRlbXMgfSA9IHRyZWUuZ2V0U3RhdGUoKTtcbiAgICAgIHJldHVybiBzZWxlY3RlZEl0ZW1zLmluY2x1ZGVzKGl0ZW1JZCk7XG4gICAgfSxcbiAgICBzZWxlY3RVcFRvOiAoeyB0cmVlLCBpdGVtIH0sIGN0cmwpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4QSA9IGl0ZW0uZ2V0SXRlbU1ldGEoKS5pbmRleDtcbiAgICAgIGNvbnN0IGluZGV4QiA9IHRyZWUuZ2V0Rm9jdXNlZEl0ZW0oKS5nZXRJdGVtTWV0YSgpLmluZGV4O1xuICAgICAgY29uc3QgW2EsIGJdID0gaW5kZXhBIDwgaW5kZXhCID8gW2luZGV4QSwgaW5kZXhCXSA6IFtpbmRleEIsIGluZGV4QV07XG4gICAgICBjb25zdCBuZXdTZWxlY3RlZEl0ZW1zID0gdHJlZS5nZXRJdGVtcygpLnNsaWNlKGEsIGIgKyAxKS5tYXAoKHRyZWVJdGVtKSA9PiB0cmVlSXRlbS5nZXRJdGVtTWV0YSgpLml0ZW1JZCk7XG4gICAgICBpZiAoIWN0cmwpIHtcbiAgICAgICAgdHJlZS5zZXRTZWxlY3RlZEl0ZW1zKG5ld1NlbGVjdGVkSXRlbXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7IHNlbGVjdGVkSXRlbXMgfSA9IHRyZWUuZ2V0U3RhdGUoKTtcbiAgICAgIGNvbnN0IHVuaXF1ZVNlbGVjdGVkSXRlbXMgPSBbXG4gICAgICAgIC4uLi8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFsuLi5zZWxlY3RlZEl0ZW1zLCAuLi5uZXdTZWxlY3RlZEl0ZW1zXSlcbiAgICAgIF07XG4gICAgICB0cmVlLnNldFNlbGVjdGVkSXRlbXModW5pcXVlU2VsZWN0ZWRJdGVtcyk7XG4gICAgfSxcbiAgICB0b2dnbGVTZWxlY3Q6ICh7IGl0ZW0gfSkgPT4ge1xuICAgICAgaWYgKGl0ZW0uaXNTZWxlY3RlZCgpKSB7XG4gICAgICAgIGl0ZW0uZGVzZWxlY3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW0uc2VsZWN0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRQcm9wczogKHsgdHJlZSwgaXRlbSwgcHJldiB9KSA9PiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBwcmV2ID09IG51bGwgPyB2b2lkIDAgOiBwcmV2KCkpLCB7XG4gICAgICBcImFyaWEtc2VsZWN0ZWRcIjogaXRlbS5pc1NlbGVjdGVkKCkgPyBcInRydWVcIiA6IFwiZmFsc2VcIixcbiAgICAgIG9uQ2xpY2s6IChlKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgaXRlbS5zZWxlY3RVcFRvKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpO1xuICAgICAgICB9IGVsc2UgaWYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpIHtcbiAgICAgICAgICBpdGVtLnRvZ2dsZVNlbGVjdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyZWUuc2V0U2VsZWN0ZWRJdGVtcyhbaXRlbS5nZXRJdGVtTWV0YSgpLml0ZW1JZF0pO1xuICAgICAgICB9XG4gICAgICAgIChfYiA9IChfYSA9IHByZXYgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXYoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm9uQ2xpY2spID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBlKTtcbiAgICAgIH1cbiAgICB9KVxuICB9LFxuICBob3RrZXlzOiB7XG4gICAgLy8gc2V0U2VsZWN0ZWRJdGVtOiB7XG4gICAgLy8gICBob3RrZXk6IFwic3BhY2VcIixcbiAgICAvLyAgIGhhbmRsZXI6IChlLCB0cmVlKSA9PiB7XG4gICAgLy8gICAgIHRyZWUuc2V0U2VsZWN0ZWRJdGVtcyhbdHJlZS5nZXRGb2N1c2VkSXRlbSgpLmdldElkKCldKTtcbiAgICAvLyAgIH0sXG4gICAgLy8gfSxcbiAgICB0b2dnbGVTZWxlY3RlZEl0ZW06IHtcbiAgICAgIGhvdGtleTogXCJDb250cm9sK1NwYWNlXCIsXG4gICAgICBwcmV2ZW50RGVmYXVsdDogdHJ1ZSxcbiAgICAgIGhhbmRsZXI6IChfLCB0cmVlKSA9PiB7XG4gICAgICAgIHRyZWUuZ2V0Rm9jdXNlZEl0ZW0oKS50b2dnbGVTZWxlY3QoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNlbGVjdFVwd2FyZHM6IHtcbiAgICAgIGhvdGtleTogXCJTaGlmdCtBcnJvd1VwXCIsXG4gICAgICBoYW5kbGVyOiAoZSwgdHJlZSkgPT4ge1xuICAgICAgICBjb25zdCBmb2N1c2VkID0gdHJlZS5nZXRGb2N1c2VkSXRlbSgpO1xuICAgICAgICBjb25zdCBhYm92ZSA9IGZvY3VzZWQuZ2V0SXRlbUFib3ZlKCk7XG4gICAgICAgIGlmICghYWJvdmUpIHJldHVybjtcbiAgICAgICAgaWYgKGZvY3VzZWQuaXNTZWxlY3RlZCgpICYmIGFib3ZlLmlzU2VsZWN0ZWQoKSkge1xuICAgICAgICAgIGZvY3VzZWQuZGVzZWxlY3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhYm92ZS5zZWxlY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBhYm92ZS5zZXRGb2N1c2VkKCk7XG4gICAgICAgIHRyZWUudXBkYXRlRG9tRm9jdXMoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNlbGVjdERvd253YXJkczoge1xuICAgICAgaG90a2V5OiBcIlNoaWZ0K0Fycm93RG93blwiLFxuICAgICAgaGFuZGxlcjogKGUsIHRyZWUpID0+IHtcbiAgICAgICAgY29uc3QgZm9jdXNlZCA9IHRyZWUuZ2V0Rm9jdXNlZEl0ZW0oKTtcbiAgICAgICAgY29uc3QgYmVsb3cgPSBmb2N1c2VkLmdldEl0ZW1CZWxvdygpO1xuICAgICAgICBpZiAoIWJlbG93KSByZXR1cm47XG4gICAgICAgIGlmIChmb2N1c2VkLmlzU2VsZWN0ZWQoKSAmJiBiZWxvdy5pc1NlbGVjdGVkKCkpIHtcbiAgICAgICAgICBmb2N1c2VkLmRlc2VsZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmVsb3cuc2VsZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgYmVsb3cuc2V0Rm9jdXNlZCgpO1xuICAgICAgICB0cmVlLnVwZGF0ZURvbUZvY3VzKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZWxlY3RBbGw6IHtcbiAgICAgIGhvdGtleTogXCJDb250cm9sK0tleUFcIixcbiAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlLFxuICAgICAgaGFuZGxlcjogKGUsIHRyZWUpID0+IHtcbiAgICAgICAgdHJlZS5zZXRTZWxlY3RlZEl0ZW1zKHRyZWUuZ2V0SXRlbXMoKS5tYXAoKGl0ZW0pID0+IGl0ZW0uZ2V0SWQoKSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2ZlYXR1cmVzL2NoZWNrYm94ZXMvZmVhdHVyZS50c1xudmFyIGdldEFsbExvYWRlZERlc2NlbmRhbnRzID0gKHRyZWUsIGl0ZW1JZCwgaW5jbHVkZUZvbGRlcnMgPSBmYWxzZSkgPT4ge1xuICBpZiAoIXRyZWUuZ2V0Q29uZmlnKCkuaXNJdGVtRm9sZGVyKHRyZWUuZ2V0SXRlbUluc3RhbmNlKGl0ZW1JZCkpKSB7XG4gICAgcmV0dXJuIFtpdGVtSWRdO1xuICB9XG4gIGNvbnN0IGRlc2NlbmRhbnRzID0gdHJlZS5yZXRyaWV2ZUNoaWxkcmVuSWRzKGl0ZW1JZCkubWFwKChjaGlsZCkgPT4gZ2V0QWxsTG9hZGVkRGVzY2VuZGFudHModHJlZSwgY2hpbGQsIGluY2x1ZGVGb2xkZXJzKSkuZmxhdCgpO1xuICByZXR1cm4gaW5jbHVkZUZvbGRlcnMgPyBbaXRlbUlkLCAuLi5kZXNjZW5kYW50c10gOiBkZXNjZW5kYW50cztcbn07XG52YXIgY2hlY2tib3hlc0ZlYXR1cmUgPSB7XG4gIGtleTogXCJjaGVja2JveGVzXCIsXG4gIG92ZXJ3cml0ZXM6IFtcInNlbGVjdGlvblwiXSxcbiAgZ2V0SW5pdGlhbFN0YXRlOiAoaW5pdGlhbFN0YXRlKSA9PiBfX3NwcmVhZFZhbHVlcyh7XG4gICAgY2hlY2tlZEl0ZW1zOiBbXVxuICB9LCBpbml0aWFsU3RhdGUpLFxuICBnZXREZWZhdWx0Q29uZmlnOiAoZGVmYXVsdENvbmZpZywgdHJlZSkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IGhhc0FzeW5jTG9hZGVyID0gKF9hID0gZGVmYXVsdENvbmZpZy5mZWF0dXJlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNvbWUoXG4gICAgICAoZikgPT4gZi5rZXkgPT09IFwiYXN5bmMtZGF0YS1sb2FkZXJcIlxuICAgICk7XG4gICAgaWYgKGhhc0FzeW5jTG9hZGVyICYmIGRlZmF1bHRDb25maWcucHJvcGFnYXRlQ2hlY2tlZFN0YXRlKSB7XG4gICAgICB0aHJvd0Vycm9yKGBwcm9wYWdhdGVDaGVja2VkU3RhdGUgbm90IHN1cHBvcnRlZCB3aXRoIGFzeW5jIHRyZWVzYCk7XG4gICAgfVxuICAgIGNvbnN0IHByb3BhZ2F0ZUNoZWNrZWRTdGF0ZSA9IChfYiA9IGRlZmF1bHRDb25maWcucHJvcGFnYXRlQ2hlY2tlZFN0YXRlKSAhPSBudWxsID8gX2IgOiAhaGFzQXN5bmNMb2FkZXI7XG4gICAgY29uc3QgY2FuQ2hlY2tGb2xkZXJzID0gKF9jID0gZGVmYXVsdENvbmZpZy5jYW5DaGVja0ZvbGRlcnMpICE9IG51bGwgPyBfYyA6ICFwcm9wYWdhdGVDaGVja2VkU3RhdGU7XG4gICAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIHNldENoZWNrZWRJdGVtczogbWFrZVN0YXRlVXBkYXRlcihcImNoZWNrZWRJdGVtc1wiLCB0cmVlKSxcbiAgICAgIHByb3BhZ2F0ZUNoZWNrZWRTdGF0ZSxcbiAgICAgIGNhbkNoZWNrRm9sZGVyc1xuICAgIH0sIGRlZmF1bHRDb25maWcpO1xuICB9LFxuICBzdGF0ZUhhbmRsZXJOYW1lczoge1xuICAgIGNoZWNrZWRJdGVtczogXCJzZXRDaGVja2VkSXRlbXNcIlxuICB9LFxuICB0cmVlSW5zdGFuY2U6IHtcbiAgICBzZXRDaGVja2VkSXRlbXM6ICh7IHRyZWUgfSwgY2hlY2tlZEl0ZW1zKSA9PiB7XG4gICAgICB0cmVlLmFwcGx5U3ViU3RhdGVVcGRhdGUoXCJjaGVja2VkSXRlbXNcIiwgY2hlY2tlZEl0ZW1zKTtcbiAgICB9XG4gIH0sXG4gIGl0ZW1JbnN0YW5jZToge1xuICAgIGdldENoZWNrYm94UHJvcHM6ICh7IGl0ZW0gfSkgPT4ge1xuICAgICAgY29uc3QgY2hlY2tlZFN0YXRlID0gaXRlbS5nZXRDaGVja2VkU3RhdGUoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9uQ2hhbmdlOiBpdGVtLnRvZ2dsZUNoZWNrZWRTdGF0ZSxcbiAgICAgICAgY2hlY2tlZDogY2hlY2tlZFN0YXRlID09PSBcImNoZWNrZWRcIiAvKiBDaGVja2VkICovLFxuICAgICAgICByZWY6IChyKSA9PiB7XG4gICAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgIHIuaW5kZXRlcm1pbmF0ZSA9IGNoZWNrZWRTdGF0ZSA9PT0gXCJpbmRldGVybWluYXRlXCIgLyogSW5kZXRlcm1pbmF0ZSAqLztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICB0b2dnbGVDaGVja2VkU3RhdGU6ICh7IGl0ZW0gfSkgPT4ge1xuICAgICAgaWYgKGl0ZW0uZ2V0Q2hlY2tlZFN0YXRlKCkgPT09IFwiY2hlY2tlZFwiIC8qIENoZWNrZWQgKi8pIHtcbiAgICAgICAgaXRlbS5zZXRVbmNoZWNrZWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW0uc2V0Q2hlY2tlZCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0Q2hlY2tlZFN0YXRlOiAoeyBpdGVtLCB0cmVlIH0pID0+IHtcbiAgICAgIGNvbnN0IHsgY2hlY2tlZEl0ZW1zIH0gPSB0cmVlLmdldFN0YXRlKCk7XG4gICAgICBjb25zdCB7IHByb3BhZ2F0ZUNoZWNrZWRTdGF0ZSB9ID0gdHJlZS5nZXRDb25maWcoKTtcbiAgICAgIGNvbnN0IGl0ZW1JZCA9IGl0ZW0uZ2V0SWQoKTtcbiAgICAgIGlmIChjaGVja2VkSXRlbXMuaW5jbHVkZXMoaXRlbUlkKSkge1xuICAgICAgICByZXR1cm4gXCJjaGVja2VkXCIgLyogQ2hlY2tlZCAqLztcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtLmlzRm9sZGVyKCkgJiYgcHJvcGFnYXRlQ2hlY2tlZFN0YXRlKSB7XG4gICAgICAgIGNvbnN0IGRlc2NlbmRhbnRzID0gZ2V0QWxsTG9hZGVkRGVzY2VuZGFudHModHJlZSwgaXRlbUlkKTtcbiAgICAgICAgaWYgKGRlc2NlbmRhbnRzLmV2ZXJ5KChkKSA9PiBjaGVja2VkSXRlbXMuaW5jbHVkZXMoZCkpKSB7XG4gICAgICAgICAgcmV0dXJuIFwiY2hlY2tlZFwiIC8qIENoZWNrZWQgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlc2NlbmRhbnRzLnNvbWUoKGQpID0+IGNoZWNrZWRJdGVtcy5pbmNsdWRlcyhkKSkpIHtcbiAgICAgICAgICByZXR1cm4gXCJpbmRldGVybWluYXRlXCIgLyogSW5kZXRlcm1pbmF0ZSAqLztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFwidW5jaGVja2VkXCIgLyogVW5jaGVja2VkICovO1xuICAgIH0sXG4gICAgc2V0Q2hlY2tlZDogKHsgaXRlbSwgdHJlZSwgaXRlbUlkIH0pID0+IHtcbiAgICAgIGNvbnN0IHsgcHJvcGFnYXRlQ2hlY2tlZFN0YXRlLCBjYW5DaGVja0ZvbGRlcnMgfSA9IHRyZWUuZ2V0Q29uZmlnKCk7XG4gICAgICBpZiAoaXRlbS5pc0ZvbGRlcigpICYmIHByb3BhZ2F0ZUNoZWNrZWRTdGF0ZSkge1xuICAgICAgICB0cmVlLmFwcGx5U3ViU3RhdGVVcGRhdGUoXCJjaGVja2VkSXRlbXNcIiwgKGl0ZW1zKSA9PiBbXG4gICAgICAgICAgLi4uaXRlbXMsXG4gICAgICAgICAgLi4uZ2V0QWxsTG9hZGVkRGVzY2VuZGFudHModHJlZSwgaXRlbUlkLCBjYW5DaGVja0ZvbGRlcnMpXG4gICAgICAgIF0pO1xuICAgICAgfSBlbHNlIGlmICghaXRlbS5pc0ZvbGRlcigpIHx8IGNhbkNoZWNrRm9sZGVycykge1xuICAgICAgICB0cmVlLmFwcGx5U3ViU3RhdGVVcGRhdGUoXCJjaGVja2VkSXRlbXNcIiwgKGl0ZW1zKSA9PiBbLi4uaXRlbXMsIGl0ZW1JZF0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0VW5jaGVja2VkOiAoeyBpdGVtLCB0cmVlLCBpdGVtSWQgfSkgPT4ge1xuICAgICAgY29uc3QgeyBwcm9wYWdhdGVDaGVja2VkU3RhdGUsIGNhbkNoZWNrRm9sZGVycyB9ID0gdHJlZS5nZXRDb25maWcoKTtcbiAgICAgIGlmIChpdGVtLmlzRm9sZGVyKCkgJiYgcHJvcGFnYXRlQ2hlY2tlZFN0YXRlKSB7XG4gICAgICAgIGNvbnN0IGRlc2NlbmRhbnRzID0gZ2V0QWxsTG9hZGVkRGVzY2VuZGFudHMoXG4gICAgICAgICAgdHJlZSxcbiAgICAgICAgICBpdGVtSWQsXG4gICAgICAgICAgY2FuQ2hlY2tGb2xkZXJzXG4gICAgICAgICk7XG4gICAgICAgIHRyZWUuYXBwbHlTdWJTdGF0ZVVwZGF0ZShcbiAgICAgICAgICBcImNoZWNrZWRJdGVtc1wiLFxuICAgICAgICAgIChpdGVtcykgPT4gaXRlbXMuZmlsdGVyKChpZCkgPT4gIWRlc2NlbmRhbnRzLmluY2x1ZGVzKGlkKSAmJiBpZCAhPT0gaXRlbUlkKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJlZS5hcHBseVN1YlN0YXRlVXBkYXRlKFxuICAgICAgICAgIFwiY2hlY2tlZEl0ZW1zXCIsXG4gICAgICAgICAgKGl0ZW1zKSA9PiBpdGVtcy5maWx0ZXIoKGlkKSA9PiBpZCAhPT0gaXRlbUlkKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2ZlYXR1cmVzL2hvdGtleXMtY29yZS9mZWF0dXJlLnRzXG52YXIgc3BlY2lhbEtleXMgPSB7XG4gIC8vIFRPRE86YnJlYWtpbmcgZGVwcmVjYXRlIGF1dG8tbG93ZXJjYXNlXG4gIGxldHRlcjogL15LZXlbQS1aXSQvLFxuICBsZXR0ZXJvcm51bWJlcjogL14oS2V5W0EtWl18RGlnaXRbMC05XSkkLyxcbiAgcGx1czogL14oTnVtcGFkQWRkfFBsdXMpJC8sXG4gIG1pbnVzOiAvXihOdW1wYWRTdWJ0cmFjdHxNaW51cykkLyxcbiAgY29udHJvbDogL14oQ29udHJvbExlZnR8Q29udHJvbFJpZ2h0KSQvLFxuICBzaGlmdDogL14oU2hpZnRMZWZ0fFNoaWZ0UmlnaHQpJC9cbn07XG52YXIgdGVzdEhvdGtleU1hdGNoID0gKHByZXNzZWRLZXlzLCB0cmVlLCBob3RrZXkpID0+IHtcbiAgY29uc3Qgc3VwcG9zZWRLZXlzID0gaG90a2V5LmhvdGtleS50b0xvd2VyQ2FzZSgpLnNwbGl0KFwiK1wiKTtcbiAgY29uc3QgZG9LZXlzTWF0Y2ggPSBzdXBwb3NlZEtleXMuZXZlcnkoKGtleSkgPT4ge1xuICAgIGlmIChrZXkgaW4gc3BlY2lhbEtleXMpIHtcbiAgICAgIHJldHVybiBbLi4ucHJlc3NlZEtleXNdLnNvbWUoXG4gICAgICAgIChwcmVzc2VkS2V5KSA9PiBzcGVjaWFsS2V5c1trZXldLnRlc3QocHJlc3NlZEtleSlcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHByZXNzZWRLZXlzTG93ZXJDYXNlID0gWy4uLnByZXNzZWRLZXlzXS5tYXAoKGspID0+IGsudG9Mb3dlckNhc2UoKSk7XG4gICAgaWYgKHByZXNzZWRLZXlzTG93ZXJDYXNlLmluY2x1ZGVzKGtleS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChwcmVzc2VkS2V5c0xvd2VyQ2FzZS5pbmNsdWRlcyhga2V5JHtrZXkudG9Mb3dlckNhc2UoKX1gKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG4gIGNvbnN0IGlzRW5hYmxlZCA9ICFob3RrZXkuaXNFbmFibGVkIHx8IGhvdGtleS5pc0VuYWJsZWQodHJlZSk7XG4gIGNvbnN0IGVxdWFsQ291bnRzID0gcHJlc3NlZEtleXMuc2l6ZSA9PT0gc3VwcG9zZWRLZXlzLmxlbmd0aDtcbiAgcmV0dXJuIGRvS2V5c01hdGNoICYmIGlzRW5hYmxlZCAmJiBlcXVhbENvdW50cztcbn07XG52YXIgZmluZEhvdGtleU1hdGNoID0gKHByZXNzZWRLZXlzLCB0cmVlLCBjb25maWcxLCBjb25maWcyKSA9PiB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIChfYSA9IE9iamVjdC5lbnRyaWVzKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBjb25maWcxKSwgY29uZmlnMikpLmZpbmQoXG4gICAgKFssIGhvdGtleV0pID0+IHRlc3RIb3RrZXlNYXRjaChwcmVzc2VkS2V5cywgdHJlZSwgaG90a2V5KVxuICApKSA9PSBudWxsID8gdm9pZCAwIDogX2FbMF07XG59O1xudmFyIGhvdGtleXNDb3JlRmVhdHVyZSA9IHtcbiAga2V5OiBcImhvdGtleXMtY29yZVwiLFxuICBvblRyZWVNb3VudDogKHRyZWUsIGVsZW1lbnQpID0+IHtcbiAgICBjb25zdCBkYXRhID0gdHJlZS5nZXREYXRhUmVmKCk7XG4gICAgY29uc3Qga2V5ZG93biA9IChlKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3QgeyBpZ25vcmVIb3RrZXlzT25JbnB1dHMsIG9uVHJlZUhvdGtleSwgaG90a2V5cyB9ID0gdHJlZS5nZXRDb25maWcoKTtcbiAgICAgIGlmIChlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQgJiYgaWdub3JlSG90a2V5c09uSW5wdXRzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIChfYiA9IChfYSA9IGRhdGEuY3VycmVudCkucHJlc3NlZEtleXMpICE9IG51bGwgPyBfYiA6IF9hLnByZXNzZWRLZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIGNvbnN0IG5ld01hdGNoID0gIWRhdGEuY3VycmVudC5wcmVzc2VkS2V5cy5oYXMoZS5jb2RlKTtcbiAgICAgIGRhdGEuY3VycmVudC5wcmVzc2VkS2V5cy5hZGQoZS5jb2RlKTtcbiAgICAgIGNvbnN0IGhvdGtleU5hbWUgPSBmaW5kSG90a2V5TWF0Y2goXG4gICAgICAgIGRhdGEuY3VycmVudC5wcmVzc2VkS2V5cyxcbiAgICAgICAgdHJlZSxcbiAgICAgICAgdHJlZS5nZXRIb3RrZXlQcmVzZXRzKCksXG4gICAgICAgIGhvdGtleXNcbiAgICAgICk7XG4gICAgICBpZiAoZS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgICAgIGRhdGEuY3VycmVudC5wcmVzc2VkS2V5cy5kZWxldGUoZS5jb2RlKTtcbiAgICAgIH1cbiAgICAgIGlmICghaG90a2V5TmFtZSkgcmV0dXJuO1xuICAgICAgY29uc3QgaG90a2V5Q29uZmlnID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHRyZWUuZ2V0SG90a2V5UHJlc2V0cygpW2hvdGtleU5hbWVdKSwgaG90a2V5cyA9PSBudWxsID8gdm9pZCAwIDogaG90a2V5c1tob3RrZXlOYW1lXSk7XG4gICAgICBpZiAoIWhvdGtleUNvbmZpZykgcmV0dXJuO1xuICAgICAgaWYgKCFob3RrZXlDb25maWcuYWxsb3dXaGVuSW5wdXRGb2N1c2VkICYmIGUudGFyZ2V0IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKCFob3RrZXlDb25maWcuY2FuUmVwZWF0ICYmICFuZXdNYXRjaCkgcmV0dXJuO1xuICAgICAgaWYgKGhvdGtleUNvbmZpZy5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaG90a2V5Q29uZmlnLmhhbmRsZXIoZSwgdHJlZSk7XG4gICAgICBvblRyZWVIb3RrZXkgPT0gbnVsbCA/IHZvaWQgMCA6IG9uVHJlZUhvdGtleShob3RrZXlOYW1lLCBlKTtcbiAgICB9O1xuICAgIGNvbnN0IGtleXVwID0gKGUpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICAoX2IgPSAoX2EgPSBkYXRhLmN1cnJlbnQpLnByZXNzZWRLZXlzKSAhPSBudWxsID8gX2IgOiBfYS5wcmVzc2VkS2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICBkYXRhLmN1cnJlbnQucHJlc3NlZEtleXMuZGVsZXRlKGUuY29kZSk7XG4gICAgfTtcbiAgICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICAgIGRhdGEuY3VycmVudC5wcmVzc2VkS2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgfTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGtleWRvd24pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBrZXl1cCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCByZXNldCk7XG4gICAgZGF0YS5jdXJyZW50LmtleWRvd25IYW5kbGVyID0ga2V5ZG93bjtcbiAgICBkYXRhLmN1cnJlbnQua2V5dXBIYW5kbGVyID0ga2V5dXA7XG4gICAgZGF0YS5jdXJyZW50LnJlc2V0SGFuZGxlciA9IHJlc2V0O1xuICB9LFxuICBvblRyZWVVbm1vdW50OiAodHJlZSwgZWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IGRhdGEgPSB0cmVlLmdldERhdGFSZWYoKTtcbiAgICBpZiAoZGF0YS5jdXJyZW50LmtleXVwSGFuZGxlcikge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIGRhdGEuY3VycmVudC5rZXl1cEhhbmRsZXIpO1xuICAgICAgZGVsZXRlIGRhdGEuY3VycmVudC5rZXl1cEhhbmRsZXI7XG4gICAgfVxuICAgIGlmIChkYXRhLmN1cnJlbnQua2V5ZG93bkhhbmRsZXIpIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZGF0YS5jdXJyZW50LmtleWRvd25IYW5kbGVyKTtcbiAgICAgIGRlbGV0ZSBkYXRhLmN1cnJlbnQua2V5ZG93bkhhbmRsZXI7XG4gICAgfVxuICAgIGlmIChkYXRhLmN1cnJlbnQucmVzZXRIYW5kbGVyKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIGRhdGEuY3VycmVudC5yZXNldEhhbmRsZXIpO1xuICAgICAgZGVsZXRlIGRhdGEuY3VycmVudC5yZXNldEhhbmRsZXI7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZmVhdHVyZXMvYXN5bmMtZGF0YS1sb2FkZXIvZmVhdHVyZS50c1xudmFyIGdldERhdGFSZWYgPSAodHJlZSkgPT4ge1xuICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gIGNvbnN0IGRhdGFSZWYgPSB0cmVlLmdldERhdGFSZWYoKTtcbiAgKF9iID0gKF9hID0gZGF0YVJlZi5jdXJyZW50KS5pdGVtRGF0YSkgIT0gbnVsbCA/IF9iIDogX2EuaXRlbURhdGEgPSB7fTtcbiAgKF9kID0gKF9jID0gZGF0YVJlZi5jdXJyZW50KS5jaGlsZHJlbklkcykgIT0gbnVsbCA/IF9kIDogX2MuY2hpbGRyZW5JZHMgPSB7fTtcbiAgcmV0dXJuIGRhdGFSZWY7XG59O1xudmFyIGxvYWRJdGVtRGF0YSA9ICh0cmVlLCBpdGVtSWQpID0+IF9fYXN5bmMobnVsbCwgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBjb25maWcgPSB0cmVlLmdldENvbmZpZygpO1xuICBjb25zdCBkYXRhUmVmID0gZ2V0RGF0YVJlZih0cmVlKTtcbiAgY29uc3QgaXRlbSA9IHlpZWxkIGNvbmZpZy5kYXRhTG9hZGVyLmdldEl0ZW0oaXRlbUlkKTtcbiAgZGF0YVJlZi5jdXJyZW50Lml0ZW1EYXRhW2l0ZW1JZF0gPSBpdGVtO1xuICAoX2EgPSBjb25maWcub25Mb2FkZWRJdGVtKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChjb25maWcsIGl0ZW1JZCwgaXRlbSk7XG4gIHRyZWUuYXBwbHlTdWJTdGF0ZVVwZGF0ZShcbiAgICBcImxvYWRpbmdJdGVtRGF0YVwiLFxuICAgIChsb2FkaW5nSXRlbURhdGEpID0+IGxvYWRpbmdJdGVtRGF0YS5maWx0ZXIoKGlkKSA9PiBpZCAhPT0gaXRlbUlkKVxuICApO1xuICByZXR1cm4gaXRlbTtcbn0pO1xudmFyIGxvYWRDaGlsZHJlbklkcyA9ICh0cmVlLCBpdGVtSWQpID0+IF9fYXN5bmMobnVsbCwgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgY29uZmlnID0gdHJlZS5nZXRDb25maWcoKTtcbiAgY29uc3QgZGF0YVJlZiA9IGdldERhdGFSZWYodHJlZSk7XG4gIGxldCBjaGlsZHJlbklkcztcbiAgaWYgKFwiZ2V0Q2hpbGRyZW5XaXRoRGF0YVwiIGluIGNvbmZpZy5kYXRhTG9hZGVyKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB5aWVsZCBjb25maWcuZGF0YUxvYWRlci5nZXRDaGlsZHJlbldpdGhEYXRhKGl0ZW1JZCk7XG4gICAgY2hpbGRyZW5JZHMgPSBjaGlsZHJlbi5tYXAoKGMpID0+IGMuaWQpO1xuICAgIGRhdGFSZWYuY3VycmVudC5jaGlsZHJlbklkc1tpdGVtSWRdID0gY2hpbGRyZW5JZHM7XG4gICAgY2hpbGRyZW4uZm9yRWFjaCgoeyBpZCwgZGF0YSB9KSA9PiB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgZGF0YVJlZi5jdXJyZW50Lml0ZW1EYXRhW2lkXSA9IGRhdGE7XG4gICAgICAoX2EyID0gY29uZmlnLm9uTG9hZGVkSXRlbSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jYWxsKGNvbmZpZywgaWQsIGRhdGEpO1xuICAgIH0pO1xuICAgIChfYSA9IGNvbmZpZy5vbkxvYWRlZENoaWxkcmVuKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChjb25maWcsIGl0ZW1JZCwgY2hpbGRyZW5JZHMpO1xuICAgIHRyZWUucmVidWlsZFRyZWUoKTtcbiAgICB0cmVlLmFwcGx5U3ViU3RhdGVVcGRhdGUoXG4gICAgICBcImxvYWRpbmdJdGVtRGF0YVwiLFxuICAgICAgKGxvYWRpbmdJdGVtRGF0YSkgPT4gbG9hZGluZ0l0ZW1EYXRhLmZpbHRlcigoaWQpID0+ICFjaGlsZHJlbklkcy5pbmNsdWRlcyhpZCkpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBjaGlsZHJlbklkcyA9IHlpZWxkIGNvbmZpZy5kYXRhTG9hZGVyLmdldENoaWxkcmVuKGl0ZW1JZCk7XG4gICAgZGF0YVJlZi5jdXJyZW50LmNoaWxkcmVuSWRzW2l0ZW1JZF0gPSBjaGlsZHJlbklkcztcbiAgICAoX2IgPSBjb25maWcub25Mb2FkZWRDaGlsZHJlbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoY29uZmlnLCBpdGVtSWQsIGNoaWxkcmVuSWRzKTtcbiAgICB0cmVlLnJlYnVpbGRUcmVlKCk7XG4gIH1cbiAgdHJlZS5hcHBseVN1YlN0YXRlVXBkYXRlKFxuICAgIFwibG9hZGluZ0l0ZW1DaGlsZHJlbnNcIixcbiAgICAobG9hZGluZ0l0ZW1DaGlsZHJlbnMpID0+IGxvYWRpbmdJdGVtQ2hpbGRyZW5zLmZpbHRlcigoaWQpID0+IGlkICE9PSBpdGVtSWQpXG4gICk7XG4gIHJldHVybiBjaGlsZHJlbklkcztcbn0pO1xudmFyIGFzeW5jRGF0YUxvYWRlckZlYXR1cmUgPSB7XG4gIGtleTogXCJhc3luYy1kYXRhLWxvYWRlclwiLFxuICBnZXRJbml0aWFsU3RhdGU6IChpbml0aWFsU3RhdGUpID0+IF9fc3ByZWFkVmFsdWVzKHtcbiAgICBsb2FkaW5nSXRlbURhdGE6IFtdLFxuICAgIGxvYWRpbmdJdGVtQ2hpbGRyZW5zOiBbXVxuICB9LCBpbml0aWFsU3RhdGUpLFxuICBnZXREZWZhdWx0Q29uZmlnOiAoZGVmYXVsdENvbmZpZywgdHJlZSkgPT4gX19zcHJlYWRWYWx1ZXMoe1xuICAgIHNldExvYWRpbmdJdGVtRGF0YTogbWFrZVN0YXRlVXBkYXRlcihcImxvYWRpbmdJdGVtRGF0YVwiLCB0cmVlKSxcbiAgICBzZXRMb2FkaW5nSXRlbUNoaWxkcmVuczogbWFrZVN0YXRlVXBkYXRlcihcImxvYWRpbmdJdGVtQ2hpbGRyZW5zXCIsIHRyZWUpXG4gIH0sIGRlZmF1bHRDb25maWcpLFxuICBzdGF0ZUhhbmRsZXJOYW1lczoge1xuICAgIGxvYWRpbmdJdGVtRGF0YTogXCJzZXRMb2FkaW5nSXRlbURhdGFcIixcbiAgICBsb2FkaW5nSXRlbUNoaWxkcmVuczogXCJzZXRMb2FkaW5nSXRlbUNoaWxkcmVuc1wiXG4gIH0sXG4gIHRyZWVJbnN0YW5jZToge1xuICAgIHdhaXRGb3JJdGVtRGF0YUxvYWRlZDogKHsgdHJlZSB9LCBpdGVtSWQpID0+IHRyZWUubG9hZEl0ZW1EYXRhKGl0ZW1JZCksXG4gICAgd2FpdEZvckl0ZW1DaGlsZHJlbkxvYWRlZDogKHsgdHJlZSB9LCBpdGVtSWQpID0+IHRyZWUubG9hZENoaWxkcmVuSWRzKGl0ZW1JZCksXG4gICAgbG9hZEl0ZW1EYXRhOiAoXzAsIF8xKSA9PiBfX2FzeW5jKG51bGwsIFtfMCwgXzFdLCBmdW5jdGlvbiogKHsgdHJlZSB9LCBpdGVtSWQpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiAoX2EgPSBnZXREYXRhUmVmKHRyZWUpLmN1cnJlbnQuaXRlbURhdGFbaXRlbUlkXSkgIT0gbnVsbCA/IF9hIDogeWllbGQgbG9hZEl0ZW1EYXRhKHRyZWUsIGl0ZW1JZCk7XG4gICAgfSksXG4gICAgbG9hZENoaWxkcmVuSWRzOiAoXzAsIF8xKSA9PiBfX2FzeW5jKG51bGwsIFtfMCwgXzFdLCBmdW5jdGlvbiogKHsgdHJlZSB9LCBpdGVtSWQpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiAoX2EgPSBnZXREYXRhUmVmKHRyZWUpLmN1cnJlbnQuY2hpbGRyZW5JZHNbaXRlbUlkXSkgIT0gbnVsbCA/IF9hIDogeWllbGQgbG9hZENoaWxkcmVuSWRzKHRyZWUsIGl0ZW1JZCk7XG4gICAgfSksXG4gICAgcmV0cmlldmVJdGVtRGF0YTogKHsgdHJlZSB9LCBpdGVtSWQsIHNraXBGZXRjaCA9IGZhbHNlKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3QgY29uZmlnID0gdHJlZS5nZXRDb25maWcoKTtcbiAgICAgIGNvbnN0IGRhdGFSZWYgPSBnZXREYXRhUmVmKHRyZWUpO1xuICAgICAgaWYgKGRhdGFSZWYuY3VycmVudC5pdGVtRGF0YVtpdGVtSWRdKSB7XG4gICAgICAgIHJldHVybiBkYXRhUmVmLmN1cnJlbnQuaXRlbURhdGFbaXRlbUlkXTtcbiAgICAgIH1cbiAgICAgIGlmICghdHJlZS5nZXRTdGF0ZSgpLmxvYWRpbmdJdGVtRGF0YS5pbmNsdWRlcyhpdGVtSWQpICYmICFza2lwRmV0Y2gpIHtcbiAgICAgICAgdHJlZS5hcHBseVN1YlN0YXRlVXBkYXRlKFwibG9hZGluZ0l0ZW1EYXRhXCIsIChsb2FkaW5nSXRlbURhdGEpID0+IFtcbiAgICAgICAgICAuLi5sb2FkaW5nSXRlbURhdGEsXG4gICAgICAgICAgaXRlbUlkXG4gICAgICAgIF0pO1xuICAgICAgICBsb2FkSXRlbURhdGEodHJlZSwgaXRlbUlkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoX2IgPSAoX2EgPSBjb25maWcuY3JlYXRlTG9hZGluZ0l0ZW1EYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChjb25maWcpKSAhPSBudWxsID8gX2IgOiBudWxsO1xuICAgIH0sXG4gICAgcmV0cmlldmVDaGlsZHJlbklkczogKHsgdHJlZSB9LCBpdGVtSWQsIHNraXBGZXRjaCA9IGZhbHNlKSA9PiB7XG4gICAgICBjb25zdCBkYXRhUmVmID0gZ2V0RGF0YVJlZih0cmVlKTtcbiAgICAgIGlmIChkYXRhUmVmLmN1cnJlbnQuY2hpbGRyZW5JZHNbaXRlbUlkXSkge1xuICAgICAgICByZXR1cm4gZGF0YVJlZi5jdXJyZW50LmNoaWxkcmVuSWRzW2l0ZW1JZF07XG4gICAgICB9XG4gICAgICBpZiAodHJlZS5nZXRTdGF0ZSgpLmxvYWRpbmdJdGVtQ2hpbGRyZW5zLmluY2x1ZGVzKGl0ZW1JZCkgfHwgc2tpcEZldGNoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHRyZWUuYXBwbHlTdWJTdGF0ZVVwZGF0ZShcbiAgICAgICAgXCJsb2FkaW5nSXRlbUNoaWxkcmVuc1wiLFxuICAgICAgICAobG9hZGluZ0l0ZW1DaGlsZHJlbnMpID0+IFsuLi5sb2FkaW5nSXRlbUNoaWxkcmVucywgaXRlbUlkXVxuICAgICAgKTtcbiAgICAgIGxvYWRDaGlsZHJlbklkcyh0cmVlLCBpdGVtSWQpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfSxcbiAgaXRlbUluc3RhbmNlOiB7XG4gICAgaXNMb2FkaW5nOiAoeyB0cmVlLCBpdGVtIH0pID0+IHRyZWUuZ2V0U3RhdGUoKS5sb2FkaW5nSXRlbURhdGEuaW5jbHVkZXMoaXRlbS5nZXRJdGVtTWV0YSgpLml0ZW1JZCkgfHwgdHJlZS5nZXRTdGF0ZSgpLmxvYWRpbmdJdGVtQ2hpbGRyZW5zLmluY2x1ZGVzKGl0ZW0uZ2V0SXRlbU1ldGEoKS5pdGVtSWQpLFxuICAgIGludmFsaWRhdGVJdGVtRGF0YTogKF8wLCBfMSkgPT4gX19hc3luYyhudWxsLCBbXzAsIF8xXSwgZnVuY3Rpb24qICh7IHRyZWUsIGl0ZW1JZCB9LCBvcHRpbWlzdGljKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoIW9wdGltaXN0aWMpIHtcbiAgICAgICAgKF9hID0gZ2V0RGF0YVJlZih0cmVlKS5jdXJyZW50Lml0ZW1EYXRhKSA9PSBudWxsID8gdHJ1ZSA6IGRlbGV0ZSBfYVtpdGVtSWRdO1xuICAgICAgICB0cmVlLmFwcGx5U3ViU3RhdGVVcGRhdGUoXCJsb2FkaW5nSXRlbURhdGFcIiwgKGxvYWRpbmdJdGVtRGF0YSkgPT4gW1xuICAgICAgICAgIC4uLmxvYWRpbmdJdGVtRGF0YSxcbiAgICAgICAgICBpdGVtSWRcbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgICB5aWVsZCBsb2FkSXRlbURhdGEodHJlZSwgaXRlbUlkKTtcbiAgICB9KSxcbiAgICBpbnZhbGlkYXRlQ2hpbGRyZW5JZHM6IChfMCwgXzEpID0+IF9fYXN5bmMobnVsbCwgW18wLCBfMV0sIGZ1bmN0aW9uKiAoeyB0cmVlLCBpdGVtSWQgfSwgb3B0aW1pc3RpYykge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKCFvcHRpbWlzdGljKSB7XG4gICAgICAgIChfYSA9IGdldERhdGFSZWYodHJlZSkuY3VycmVudC5jaGlsZHJlbklkcykgPT0gbnVsbCA/IHRydWUgOiBkZWxldGUgX2FbaXRlbUlkXTtcbiAgICAgICAgdHJlZS5hcHBseVN1YlN0YXRlVXBkYXRlKFxuICAgICAgICAgIFwibG9hZGluZ0l0ZW1DaGlsZHJlbnNcIixcbiAgICAgICAgICAobG9hZGluZ0l0ZW1DaGlsZHJlbnMpID0+IFsuLi5sb2FkaW5nSXRlbUNoaWxkcmVucywgaXRlbUlkXVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgeWllbGQgbG9hZENoaWxkcmVuSWRzKHRyZWUsIGl0ZW1JZCk7XG4gICAgfSksXG4gICAgdXBkYXRlQ2FjaGVkQ2hpbGRyZW5JZHM6ICh7IHRyZWUsIGl0ZW1JZCB9LCBjaGlsZHJlbklkcykgPT4ge1xuICAgICAgY29uc3QgZGF0YVJlZiA9IHRyZWUuZ2V0RGF0YVJlZigpO1xuICAgICAgZGF0YVJlZi5jdXJyZW50LmNoaWxkcmVuSWRzW2l0ZW1JZF0gPSBjaGlsZHJlbklkcztcbiAgICAgIHRyZWUucmVidWlsZFRyZWUoKTtcbiAgICB9LFxuICAgIHVwZGF0ZUNhY2hlZERhdGE6ICh7IHRyZWUsIGl0ZW1JZCB9LCBkYXRhKSA9PiB7XG4gICAgICBjb25zdCBkYXRhUmVmID0gdHJlZS5nZXREYXRhUmVmKCk7XG4gICAgICBkYXRhUmVmLmN1cnJlbnQuaXRlbURhdGFbaXRlbUlkXSA9IGRhdGE7XG4gICAgICB0cmVlLnJlYnVpbGRUcmVlKCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZmVhdHVyZXMvc3luYy1kYXRhLWxvYWRlci9mZWF0dXJlLnRzXG52YXIgdW5kZWZFcnJvck1lc3NhZ2UgPSBcInN5bmMgZGF0YUxvYWRlciByZXR1cm5lZCB1bmRlZmluZWRcIjtcbnZhciBwcm9taXNlRXJyb3JNZXNzYWdlID0gXCJzeW5jIGRhdGFMb2FkZXIgcmV0dXJuZWQgcHJvbWlzZVwiO1xudmFyIHVucHJvbWlzZSA9IChkYXRhKSA9PiB7XG4gIGlmICghZGF0YSkge1xuICAgIHRocm93IHRocm93RXJyb3IodW5kZWZFcnJvck1lc3NhZ2UpO1xuICB9XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIiAmJiBcInRoZW5cIiBpbiBkYXRhKSB7XG4gICAgdGhyb3cgdGhyb3dFcnJvcihwcm9taXNlRXJyb3JNZXNzYWdlKTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn07XG52YXIgc3luY0RhdGFMb2FkZXJGZWF0dXJlID0ge1xuICBrZXk6IFwic3luYy1kYXRhLWxvYWRlclwiLFxuICBnZXRJbml0aWFsU3RhdGU6IChpbml0aWFsU3RhdGUpID0+IF9fc3ByZWFkVmFsdWVzKHtcbiAgICBsb2FkaW5nSXRlbURhdGE6IFtdLFxuICAgIGxvYWRpbmdJdGVtQ2hpbGRyZW5zOiBbXVxuICB9LCBpbml0aWFsU3RhdGUpLFxuICBnZXREZWZhdWx0Q29uZmlnOiAoZGVmYXVsdENvbmZpZywgdHJlZSkgPT4gX19zcHJlYWRWYWx1ZXMoe1xuICAgIHNldExvYWRpbmdJdGVtRGF0YTogbWFrZVN0YXRlVXBkYXRlcihcImxvYWRpbmdJdGVtRGF0YVwiLCB0cmVlKSxcbiAgICBzZXRMb2FkaW5nSXRlbUNoaWxkcmVuczogbWFrZVN0YXRlVXBkYXRlcihcImxvYWRpbmdJdGVtQ2hpbGRyZW5zXCIsIHRyZWUpXG4gIH0sIGRlZmF1bHRDb25maWcpLFxuICBzdGF0ZUhhbmRsZXJOYW1lczoge1xuICAgIGxvYWRpbmdJdGVtRGF0YTogXCJzZXRMb2FkaW5nSXRlbURhdGFcIixcbiAgICBsb2FkaW5nSXRlbUNoaWxkcmVuczogXCJzZXRMb2FkaW5nSXRlbUNoaWxkcmVuc1wiXG4gIH0sXG4gIHRyZWVJbnN0YW5jZToge1xuICAgIHdhaXRGb3JJdGVtRGF0YUxvYWRlZDogKCkgPT4gX19hc3luYyhudWxsLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIH0pLFxuICAgIHdhaXRGb3JJdGVtQ2hpbGRyZW5Mb2FkZWQ6ICgpID0+IF9fYXN5bmMobnVsbCwgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICB9KSxcbiAgICByZXRyaWV2ZUl0ZW1EYXRhOiAoeyB0cmVlIH0sIGl0ZW1JZCkgPT4ge1xuICAgICAgcmV0dXJuIHVucHJvbWlzZSh0cmVlLmdldENvbmZpZygpLmRhdGFMb2FkZXIuZ2V0SXRlbShpdGVtSWQpKTtcbiAgICB9LFxuICAgIHJldHJpZXZlQ2hpbGRyZW5JZHM6ICh7IHRyZWUgfSwgaXRlbUlkKSA9PiB7XG4gICAgICBjb25zdCB7IGRhdGFMb2FkZXIgfSA9IHRyZWUuZ2V0Q29uZmlnKCk7XG4gICAgICBpZiAoXCJnZXRDaGlsZHJlblwiIGluIGRhdGFMb2FkZXIpIHtcbiAgICAgICAgcmV0dXJuIHVucHJvbWlzZShkYXRhTG9hZGVyLmdldENoaWxkcmVuKGl0ZW1JZCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVucHJvbWlzZShkYXRhTG9hZGVyLmdldENoaWxkcmVuV2l0aERhdGEoaXRlbUlkKSkubWFwKFxuICAgICAgICAoYykgPT4gYy5kYXRhXG4gICAgICApO1xuICAgIH0sXG4gICAgbG9hZEl0ZW1EYXRhOiAoeyB0cmVlIH0sIGl0ZW1JZCkgPT4gdHJlZS5yZXRyaWV2ZUl0ZW1EYXRhKGl0ZW1JZCksXG4gICAgbG9hZENoaWxkcmVuSWRzOiAoeyB0cmVlIH0sIGl0ZW1JZCkgPT4gdHJlZS5yZXRyaWV2ZUNoaWxkcmVuSWRzKGl0ZW1JZClcbiAgfSxcbiAgaXRlbUluc3RhbmNlOiB7XG4gICAgaXNMb2FkaW5nOiAoKSA9PiBmYWxzZVxuICB9XG59O1xuXG4vLyBzcmMvZmVhdHVyZXMvZHJhZy1hbmQtZHJvcC91dGlscy50c1xudmFyIGlzT3JkZXJlZERyYWdUYXJnZXQgPSAoZHJhZ1RhcmdldCkgPT4gXCJjaGlsZEluZGV4XCIgaW4gZHJhZ1RhcmdldDtcbnZhciBjYW5Ecm9wID0gKGRhdGFUcmFuc2ZlciwgdGFyZ2V0LCB0cmVlKSA9PiB7XG4gIHZhciBfYSwgX2IsIF9jO1xuICBjb25zdCBkcmFnZ2VkSXRlbXMgPSAoX2EgPSB0cmVlLmdldFN0YXRlKCkuZG5kKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZHJhZ2dlZEl0ZW1zO1xuICBjb25zdCBjb25maWcgPSB0cmVlLmdldENvbmZpZygpO1xuICBpZiAoZHJhZ2dlZEl0ZW1zICYmICEoKF9jID0gKF9iID0gY29uZmlnLmNhbkRyb3ApID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKGNvbmZpZywgZHJhZ2dlZEl0ZW1zLCB0YXJnZXQpKSAhPSBudWxsID8gX2MgOiB0cnVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZHJhZ2dlZEl0ZW1zICYmIGRyYWdnZWRJdGVtcy5zb21lKFxuICAgIChkcmFnZ2VkSXRlbSkgPT4gdGFyZ2V0Lml0ZW0uZ2V0SWQoKSA9PT0gZHJhZ2dlZEl0ZW0uZ2V0SWQoKSB8fCB0YXJnZXQuaXRlbS5pc0Rlc2NlbmRlbnRPZihkcmFnZ2VkSXRlbS5nZXRJZCgpKVxuICApKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghZHJhZ2dlZEl0ZW1zICYmIGRhdGFUcmFuc2ZlciAmJiBjb25maWcuY2FuRHJvcEZvcmVpZ25EcmFnT2JqZWN0ICYmICFjb25maWcuY2FuRHJvcEZvcmVpZ25EcmFnT2JqZWN0KGRhdGFUcmFuc2ZlciwgdGFyZ2V0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgZ2V0SXRlbURyb3BDYXRlZ29yeSA9IChpdGVtKSA9PiB7XG4gIGlmIChpdGVtLmlzRXhwYW5kZWQoKSkge1xuICAgIHJldHVybiAxIC8qIEV4cGFuZGVkRm9sZGVyICovO1xuICB9XG4gIGNvbnN0IHBhcmVudCA9IGl0ZW0uZ2V0UGFyZW50KCk7XG4gIGlmIChwYXJlbnQgJiYgaXRlbS5nZXRJbmRleEluUGFyZW50KCkgPT09IGl0ZW0uZ2V0SXRlbU1ldGEoKS5zZXRTaXplIC0gMSkge1xuICAgIHJldHVybiAyIC8qIExhc3RJbkdyb3VwICovO1xuICB9XG4gIHJldHVybiAwIC8qIEl0ZW0gKi87XG59O1xudmFyIGdldEluc2VydGlvbkluZGV4ID0gKGNoaWxkcmVuLCBjaGlsZEluZGV4LCBkcmFnZ2VkSXRlbXMpID0+IHtcbiAgdmFyIF9hO1xuICBjb25zdCBudW1iZXJPZkRyYWdJdGVtc0JlZm9yZVRhcmdldCA9IChfYSA9IGNoaWxkcmVuLnNsaWNlKDAsIGNoaWxkSW5kZXgpLnJlZHVjZShcbiAgICAoY291bnRlciwgY2hpbGQpID0+IGNoaWxkICYmIChkcmFnZ2VkSXRlbXMgPT0gbnVsbCA/IHZvaWQgMCA6IGRyYWdnZWRJdGVtcy5zb21lKChpKSA9PiBpLmdldElkKCkgPT09IGNoaWxkLmdldElkKCkpKSA/ICsrY291bnRlciA6IGNvdW50ZXIsXG4gICAgMFxuICApKSAhPSBudWxsID8gX2EgOiAwO1xuICByZXR1cm4gY2hpbGRJbmRleCAtIG51bWJlck9mRHJhZ0l0ZW1zQmVmb3JlVGFyZ2V0O1xufTtcbnZhciBnZXRUYXJnZXRQbGFjZW1lbnQgPSAoZSwgaXRlbSwgdHJlZSwgY2FuTWFrZUNoaWxkKSA9PiB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gIGNvbnN0IGNvbmZpZyA9IHRyZWUuZ2V0Q29uZmlnKCk7XG4gIGlmICghY29uZmlnLmNhblJlb3JkZXIpIHtcbiAgICByZXR1cm4gY2FuTWFrZUNoaWxkID8geyB0eXBlOiAyIC8qIE1ha2VDaGlsZCAqLyB9IDogeyB0eXBlOiAxIC8qIFJlb3JkZXJCZWxvdyAqLyB9O1xuICB9XG4gIGNvbnN0IGJiID0gKF9hID0gaXRlbS5nZXRFbGVtZW50KCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgdG9wUGVyY2VudCA9IGJiID8gKGUuY2xpZW50WSAtIGJiLnRvcCkgLyBiYi5oZWlnaHQgOiAwLjU7XG4gIGNvbnN0IGxlZnRQaXhlbHMgPSBiYiA/IGUuY2xpZW50WCAtIGJiLmxlZnQgOiAwO1xuICBjb25zdCB0YXJnZXREcm9wQ2F0ZWdvcnkgPSBnZXRJdGVtRHJvcENhdGVnb3J5KGl0ZW0pO1xuICBjb25zdCByZW9yZGVyQXJlYVBlcmNlbnRhZ2UgPSAhY2FuTWFrZUNoaWxkID8gMC41IDogKF9iID0gY29uZmlnLnJlb3JkZXJBcmVhUGVyY2VudGFnZSkgIT0gbnVsbCA/IF9iIDogMC4zO1xuICBjb25zdCBpbmRlbnQgPSAoX2MgPSBjb25maWcuaW5kZW50KSAhPSBudWxsID8gX2MgOiAyMDtcbiAgY29uc3QgbWFrZUNoaWxkVHlwZSA9IGNhbk1ha2VDaGlsZCA/IDIgLyogTWFrZUNoaWxkICovIDogMSAvKiBSZW9yZGVyQmVsb3cgKi87XG4gIGlmICh0YXJnZXREcm9wQ2F0ZWdvcnkgPT09IDEgLyogRXhwYW5kZWRGb2xkZXIgKi8pIHtcbiAgICBpZiAodG9wUGVyY2VudCA8IHJlb3JkZXJBcmVhUGVyY2VudGFnZSkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogMCAvKiBSZW9yZGVyQWJvdmUgKi8gfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogbWFrZUNoaWxkVHlwZSB9O1xuICB9XG4gIGlmICh0YXJnZXREcm9wQ2F0ZWdvcnkgPT09IDIgLyogTGFzdEluR3JvdXAgKi8pIHtcbiAgICBpZiAobGVmdFBpeGVscyA8IGl0ZW0uZ2V0SXRlbU1ldGEoKS5sZXZlbCAqIGluZGVudCkge1xuICAgICAgaWYgKHRvcFBlcmNlbnQgPCAwLjUpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogMCAvKiBSZW9yZGVyQWJvdmUgKi8gfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1pbkxldmVsID0gKF9lID0gKF9kID0gaXRlbS5nZXRJdGVtQmVsb3coKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmdldEl0ZW1NZXRhKCkubGV2ZWwpICE9IG51bGwgPyBfZSA6IDA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAzIC8qIFJlcGFyZW50ICovLFxuICAgICAgICByZXBhcmVudExldmVsOiBNYXRoLm1heChtaW5MZXZlbCwgTWF0aC5mbG9vcihsZWZ0UGl4ZWxzIC8gaW5kZW50KSlcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGlmICh0b3BQZXJjZW50IDwgcmVvcmRlckFyZWFQZXJjZW50YWdlKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogMCAvKiBSZW9yZGVyQWJvdmUgKi8gfTtcbiAgfVxuICBpZiAodG9wUGVyY2VudCA+IDEgLSByZW9yZGVyQXJlYVBlcmNlbnRhZ2UpIHtcbiAgICByZXR1cm4geyB0eXBlOiAxIC8qIFJlb3JkZXJCZWxvdyAqLyB9O1xuICB9XG4gIHJldHVybiB7IHR5cGU6IG1ha2VDaGlsZFR5cGUgfTtcbn07XG52YXIgZ2V0RHJhZ0NvZGUgPSAoaXRlbSwgcGxhY2VtZW50KSA9PiB7XG4gIHJldHVybiBbXG4gICAgaXRlbS5nZXRJZCgpLFxuICAgIHBsYWNlbWVudC50eXBlLFxuICAgIHBsYWNlbWVudC50eXBlID09PSAzIC8qIFJlcGFyZW50ICovID8gcGxhY2VtZW50LnJlcGFyZW50TGV2ZWwgOiAwXG4gIF0uam9pbihcIl9fXCIpO1xufTtcbnZhciBnZXROdGhQYXJlbnQgPSAoaXRlbSwgbikgPT4ge1xuICBpZiAobiA9PT0gaXRlbS5nZXRJdGVtTWV0YSgpLmxldmVsKSB7XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cbiAgcmV0dXJuIGdldE50aFBhcmVudChpdGVtLmdldFBhcmVudCgpLCBuKTtcbn07XG52YXIgZ2V0UmVwYXJlbnRUYXJnZXQgPSAoaXRlbSwgcmVwYXJlbnRMZXZlbCwgZHJhZ2dlZEl0ZW1zKSA9PiB7XG4gIGNvbnN0IGl0ZW1NZXRhID0gaXRlbS5nZXRJdGVtTWV0YSgpO1xuICBjb25zdCByZXBhcmVudGVkVGFyZ2V0ID0gZ2V0TnRoUGFyZW50KGl0ZW0sIHJlcGFyZW50TGV2ZWwgLSAxKTtcbiAgY29uc3QgdGFyZ2V0SXRlbUFib3ZlID0gZ2V0TnRoUGFyZW50KGl0ZW0sIHJlcGFyZW50TGV2ZWwpO1xuICBjb25zdCB0YXJnZXRJbmRleCA9IHRhcmdldEl0ZW1BYm92ZS5nZXRJbmRleEluUGFyZW50KCkgKyAxO1xuICByZXR1cm4ge1xuICAgIGl0ZW06IHJlcGFyZW50ZWRUYXJnZXQsXG4gICAgY2hpbGRJbmRleDogdGFyZ2V0SW5kZXgsXG4gICAgaW5zZXJ0aW9uSW5kZXg6IGdldEluc2VydGlvbkluZGV4KFxuICAgICAgcmVwYXJlbnRlZFRhcmdldC5nZXRDaGlsZHJlbigpLFxuICAgICAgdGFyZ2V0SW5kZXgsXG4gICAgICBkcmFnZ2VkSXRlbXNcbiAgICApLFxuICAgIGRyYWdMaW5lSW5kZXg6IGl0ZW1NZXRhLmluZGV4ICsgMSxcbiAgICBkcmFnTGluZUxldmVsOiByZXBhcmVudExldmVsXG4gIH07XG59O1xudmFyIGdldERyYWdUYXJnZXQgPSAoZSwgaXRlbSwgdHJlZSwgY2FuUmVvcmRlciA9IHRyZWUuZ2V0Q29uZmlnKCkuY2FuUmVvcmRlcikgPT4ge1xuICB2YXIgX2E7XG4gIGNvbnN0IGRyYWdnZWRJdGVtcyA9IChfYSA9IHRyZWUuZ2V0U3RhdGUoKS5kbmQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5kcmFnZ2VkSXRlbXM7XG4gIGNvbnN0IGl0ZW1NZXRhID0gaXRlbS5nZXRJdGVtTWV0YSgpO1xuICBjb25zdCBwYXJlbnQgPSBpdGVtLmdldFBhcmVudCgpO1xuICBjb25zdCBpdGVtVGFyZ2V0ID0geyBpdGVtIH07XG4gIGNvbnN0IHBhcmVudFRhcmdldCA9IHBhcmVudCA/IHsgaXRlbTogcGFyZW50IH0gOiBudWxsO1xuICBjb25zdCBjYW5CZWNvbWVTaWJsaW5nID0gcGFyZW50VGFyZ2V0ICYmIGNhbkRyb3AoZS5kYXRhVHJhbnNmZXIsIHBhcmVudFRhcmdldCwgdHJlZSk7XG4gIGNvbnN0IGNhbk1ha2VDaGlsZCA9IGNhbkRyb3AoZS5kYXRhVHJhbnNmZXIsIGl0ZW1UYXJnZXQsIHRyZWUpO1xuICBjb25zdCBwbGFjZW1lbnQgPSBnZXRUYXJnZXRQbGFjZW1lbnQoZSwgaXRlbSwgdHJlZSwgY2FuTWFrZUNoaWxkKTtcbiAgaWYgKCFjYW5SZW9yZGVyICYmIHBhcmVudCAmJiBjYW5CZWNvbWVTaWJsaW5nICYmIHBsYWNlbWVudC50eXBlICE9PSAyIC8qIE1ha2VDaGlsZCAqLykge1xuICAgIGlmIChkcmFnZ2VkSXRlbXMgPT0gbnVsbCA/IHZvaWQgMCA6IGRyYWdnZWRJdGVtcy5zb21lKChpdGVtMikgPT4gaXRlbTIuaXNEZXNjZW5kZW50T2YocGFyZW50LmdldElkKCkpKSkge1xuICAgICAgcmV0dXJuIGl0ZW1UYXJnZXQ7XG4gICAgfVxuICAgIHJldHVybiBwYXJlbnRUYXJnZXQ7XG4gIH1cbiAgaWYgKCFjYW5SZW9yZGVyICYmIHBhcmVudCAmJiAhY2FuQmVjb21lU2libGluZykge1xuICAgIHJldHVybiBnZXREcmFnVGFyZ2V0KGUsIHBhcmVudCwgdHJlZSwgZmFsc2UpO1xuICB9XG4gIGlmICghcGFyZW50KSB7XG4gICAgcmV0dXJuIGl0ZW1UYXJnZXQ7XG4gIH1cbiAgaWYgKHBsYWNlbWVudC50eXBlID09PSAyIC8qIE1ha2VDaGlsZCAqLykge1xuICAgIHJldHVybiBpdGVtVGFyZ2V0O1xuICB9XG4gIGlmICghY2FuQmVjb21lU2libGluZykge1xuICAgIHJldHVybiBnZXREcmFnVGFyZ2V0KGUsIHBhcmVudCwgdHJlZSwgZmFsc2UpO1xuICB9XG4gIGlmIChwbGFjZW1lbnQudHlwZSA9PT0gMyAvKiBSZXBhcmVudCAqLykge1xuICAgIHJldHVybiBnZXRSZXBhcmVudFRhcmdldChpdGVtLCBwbGFjZW1lbnQucmVwYXJlbnRMZXZlbCwgZHJhZ2dlZEl0ZW1zKTtcbiAgfVxuICBjb25zdCBtYXliZUFkZE9uZUZvckJlbG93ID0gcGxhY2VtZW50LnR5cGUgPT09IDAgLyogUmVvcmRlckFib3ZlICovID8gMCA6IDE7XG4gIGNvbnN0IGNoaWxkSW5kZXggPSBpdGVtLmdldEluZGV4SW5QYXJlbnQoKSArIG1heWJlQWRkT25lRm9yQmVsb3c7XG4gIHJldHVybiB7XG4gICAgaXRlbTogcGFyZW50LFxuICAgIGRyYWdMaW5lSW5kZXg6IGl0ZW1NZXRhLmluZGV4ICsgbWF5YmVBZGRPbmVGb3JCZWxvdyxcbiAgICBkcmFnTGluZUxldmVsOiBpdGVtTWV0YS5sZXZlbCxcbiAgICBjaGlsZEluZGV4LFxuICAgIC8vIFRPRE8gcGVyZm9ybWFuY2UgY291bGQgYmUgaW1wcm92ZWQgYnkgY29tcHV0aW5nIHRoaXMgb25seSB3aGVuIGRyYWdjb2RlIGNoYW5nZWRcbiAgICBpbnNlcnRpb25JbmRleDogZ2V0SW5zZXJ0aW9uSW5kZXgoXG4gICAgICBwYXJlbnQuZ2V0Q2hpbGRyZW4oKSxcbiAgICAgIGNoaWxkSW5kZXgsXG4gICAgICBkcmFnZ2VkSXRlbXNcbiAgICApXG4gIH07XG59O1xuXG4vLyBzcmMvZmVhdHVyZXMvZHJhZy1hbmQtZHJvcC9mZWF0dXJlLnRzXG52YXIgaGFuZGxlQXV0b09wZW5Gb2xkZXIgPSAoZGF0YVJlZiwgdHJlZSwgaXRlbSwgcGxhY2VtZW50KSA9PiB7XG4gIGNvbnN0IHsgb3Blbk9uRHJvcERlbGF5IH0gPSB0cmVlLmdldENvbmZpZygpO1xuICBjb25zdCBkcmFnQ29kZSA9IGRhdGFSZWYuY3VycmVudC5sYXN0RHJhZ0NvZGU7XG4gIGlmICghb3Blbk9uRHJvcERlbGF5IHx8ICFpdGVtLmlzRm9sZGVyKCkgfHwgaXRlbS5pc0V4cGFuZGVkKCkgfHwgcGxhY2VtZW50LnR5cGUgIT09IDIgLyogTWFrZUNoaWxkICovKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNsZWFyVGltZW91dChkYXRhUmVmLmN1cnJlbnQuYXV0b0V4cGFuZFRpbWVvdXQpO1xuICBkYXRhUmVmLmN1cnJlbnQuYXV0b0V4cGFuZFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBpZiAoZHJhZ0NvZGUgIT09IGRhdGFSZWYuY3VycmVudC5sYXN0RHJhZ0NvZGUgfHwgIWRhdGFSZWYuY3VycmVudC5sYXN0QWxsb3dEcm9wKVxuICAgICAgcmV0dXJuO1xuICAgIGl0ZW0uZXhwYW5kKCk7XG4gIH0sIG9wZW5PbkRyb3BEZWxheSk7XG59O1xudmFyIGRlZmF1bHRDYW5Ecm9wRm9yZWlnbkRyYWdPYmplY3QgPSAoKSA9PiBmYWxzZTtcbnZhciBkcmFnQW5kRHJvcEZlYXR1cmUgPSB7XG4gIGtleTogXCJkcmFnLWFuZC1kcm9wXCIsXG4gIGdldERlZmF1bHRDb25maWc6IChkZWZhdWx0Q29uZmlnLCB0cmVlKSA9PiBfX3NwcmVhZFZhbHVlcyh7XG4gICAgY2FuRHJvcDogKF8sIHRhcmdldCkgPT4gdGFyZ2V0Lml0ZW0uaXNGb2xkZXIoKSxcbiAgICBjYW5Ecm9wRm9yZWlnbkRyYWdPYmplY3Q6IGRlZmF1bHRDYW5Ecm9wRm9yZWlnbkRyYWdPYmplY3QsXG4gICAgY2FuRHJhZ0ZvcmVpZ25EcmFnT2JqZWN0T3ZlcjogZGVmYXVsdENvbmZpZy5jYW5Ecm9wRm9yZWlnbkRyYWdPYmplY3QgIT09IGRlZmF1bHRDYW5Ecm9wRm9yZWlnbkRyYWdPYmplY3QgPyAoZGF0YVRyYW5zZmVyKSA9PiBkYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCAhPT0gXCJub25lXCIgOiAoKSA9PiBmYWxzZSxcbiAgICBzZXREbmRTdGF0ZTogbWFrZVN0YXRlVXBkYXRlcihcImRuZFwiLCB0cmVlKSxcbiAgICBjYW5SZW9yZGVyOiB0cnVlLFxuICAgIG9wZW5PbkRyb3BEZWxheTogODAwXG4gIH0sIGRlZmF1bHRDb25maWcpLFxuICBzdGF0ZUhhbmRsZXJOYW1lczoge1xuICAgIGRuZDogXCJzZXREbmRTdGF0ZVwiXG4gIH0sXG4gIG9uVHJlZU1vdW50OiAodHJlZSkgPT4ge1xuICAgIGNvbnN0IGxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgdHJlZS5hcHBseVN1YlN0YXRlVXBkYXRlKFwiZG5kXCIsIG51bGwpO1xuICAgIH07XG4gICAgdHJlZS5nZXREYXRhUmVmKCkuY3VycmVudC53aW5kb3dEcmFnRW5kTGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdlbmRcIiwgbGlzdGVuZXIpO1xuICB9LFxuICBvblRyZWVVbm1vdW50OiAodHJlZSkgPT4ge1xuICAgIGNvbnN0IHsgd2luZG93RHJhZ0VuZExpc3RlbmVyIH0gPSB0cmVlLmdldERhdGFSZWYoKS5jdXJyZW50O1xuICAgIGlmICghd2luZG93RHJhZ0VuZExpc3RlbmVyKSByZXR1cm47XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkcmFnZW5kXCIsIHdpbmRvd0RyYWdFbmRMaXN0ZW5lcik7XG4gIH0sXG4gIHRyZWVJbnN0YW5jZToge1xuICAgIGdldERyYWdUYXJnZXQ6ICh7IHRyZWUgfSkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0cmVlLmdldFN0YXRlKCkuZG5kKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZHJhZ1RhcmdldCkgIT0gbnVsbCA/IF9iIDogbnVsbDtcbiAgICB9LFxuICAgIGdldERyYWdMaW5lRGF0YTogKHsgdHJlZSB9KSA9PiB7XG4gICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRyZWUuZ2V0RHJhZ1RhcmdldCgpO1xuICAgICAgY29uc3QgaW5kZW50ID0gKChfYSA9IHRhcmdldCA9PSBudWxsID8gdm9pZCAwIDogdGFyZ2V0Lml0ZW0uZ2V0SXRlbU1ldGEoKS5sZXZlbCkgIT0gbnVsbCA/IF9hIDogMCkgKyAxO1xuICAgICAgY29uc3QgdHJlZUJiID0gKF9iID0gdHJlZS5nZXRFbGVtZW50KCkpID09IG51bGwgPyB2b2lkIDAgOiBfYi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGlmICghdGFyZ2V0IHx8ICF0cmVlQmIgfHwgIWlzT3JkZXJlZERyYWdUYXJnZXQodGFyZ2V0KSkgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCBsZWZ0T2Zmc2V0ID0gdGFyZ2V0LmRyYWdMaW5lTGV2ZWwgKiAoKF9jID0gdHJlZS5nZXRDb25maWcoKS5pbmRlbnQpICE9IG51bGwgPyBfYyA6IDEpO1xuICAgICAgY29uc3QgdGFyZ2V0SXRlbSA9IHRyZWUuZ2V0SXRlbXMoKVt0YXJnZXQuZHJhZ0xpbmVJbmRleF07XG4gICAgICBpZiAoIXRhcmdldEl0ZW0pIHtcbiAgICAgICAgY29uc3QgYmIyID0gKF9lID0gKF9kID0gdHJlZS5nZXRJdGVtcygpW3RhcmdldC5kcmFnTGluZUluZGV4IC0gMV0pID09IG51bGwgPyB2b2lkIDAgOiBfZC5nZXRFbGVtZW50KCkpID09IG51bGwgPyB2b2lkIDAgOiBfZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKGJiMikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbmRlbnQsXG4gICAgICAgICAgICB0b3A6IGJiMi5ib3R0b20gLSB0cmVlQmIudG9wLFxuICAgICAgICAgICAgbGVmdDogYmIyLmxlZnQgKyBsZWZ0T2Zmc2V0IC0gdHJlZUJiLmxlZnQsXG4gICAgICAgICAgICB3aWR0aDogYmIyLndpZHRoIC0gbGVmdE9mZnNldFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGJiID0gKF9mID0gdGFyZ2V0SXRlbSA9PSBudWxsID8gdm9pZCAwIDogdGFyZ2V0SXRlbS5nZXRFbGVtZW50KCkpID09IG51bGwgPyB2b2lkIDAgOiBfZi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGlmIChiYikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGluZGVudCxcbiAgICAgICAgICB0b3A6IGJiLnRvcCAtIHRyZWVCYi50b3AsXG4gICAgICAgICAgbGVmdDogYmIubGVmdCArIGxlZnRPZmZzZXQgLSB0cmVlQmIubGVmdCxcbiAgICAgICAgICB3aWR0aDogYmIud2lkdGggLSBsZWZ0T2Zmc2V0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGdldERyYWdMaW5lU3R5bGU6ICh7IHRyZWUgfSwgdG9wT2Zmc2V0ID0gLTEsIGxlZnRPZmZzZXQgPSAtOCkgPT4ge1xuICAgICAgY29uc3QgZHJhZ0xpbmUgPSB0cmVlLmdldERyYWdMaW5lRGF0YSgpO1xuICAgICAgcmV0dXJuIGRyYWdMaW5lID8ge1xuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICB0b3A6IGAke2RyYWdMaW5lLnRvcCArIHRvcE9mZnNldH1weGAsXG4gICAgICAgIGxlZnQ6IGAke2RyYWdMaW5lLmxlZnQgKyBsZWZ0T2Zmc2V0fXB4YCxcbiAgICAgICAgd2lkdGg6IGAke2RyYWdMaW5lLndpZHRoIC0gbGVmdE9mZnNldH1weGAsXG4gICAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiXG4gICAgICAgIC8vIGltcG9ydGFudCB0byBwcmV2ZW50IGNhcHR1cmluZyBkcmFnIGV2ZW50c1xuICAgICAgfSA6IHsgZGlzcGxheTogXCJub25lXCIgfTtcbiAgICB9LFxuICAgIGdldENvbnRhaW5lclByb3BzOiAoeyBwcmV2LCB0cmVlIH0sIHRyZWVMYWJlbCkgPT4ge1xuICAgICAgY29uc3QgcHJldlByb3BzID0gcHJldiA9PSBudWxsID8gdm9pZCAwIDogcHJldih0cmVlTGFiZWwpO1xuICAgICAgcmV0dXJuIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHByZXZQcm9wcyksIHtcbiAgICAgICAgb25EcmFnT3ZlcjogKGUpID0+IHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRHJvcDogKGUpID0+IF9fYXN5bmMobnVsbCwgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICBjb25zdCBkYXRhUmVmID0gdHJlZS5nZXREYXRhUmVmKCk7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0geyBpdGVtOiB0cmVlLmdldFJvb3RJdGVtKCkgfTtcbiAgICAgICAgICBpZiAoIWNhbkRyb3AoZS5kYXRhVHJhbnNmZXIsIHRhcmdldCwgdHJlZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHRyZWUuZ2V0Q29uZmlnKCk7XG4gICAgICAgICAgY29uc3QgZHJhZ2dlZEl0ZW1zID0gKF9hID0gdHJlZS5nZXRTdGF0ZSgpLmRuZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRyYWdnZWRJdGVtcztcbiAgICAgICAgICBkYXRhUmVmLmN1cnJlbnQubGFzdERyYWdDb2RlID0gdm9pZCAwO1xuICAgICAgICAgIGlmIChkcmFnZ2VkSXRlbXMpIHtcbiAgICAgICAgICAgIHlpZWxkIChfYiA9IGNvbmZpZy5vbkRyb3ApID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKGNvbmZpZywgZHJhZ2dlZEl0ZW1zLCB0YXJnZXQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgICAgIHlpZWxkIChfYyA9IGNvbmZpZy5vbkRyb3BGb3JlaWduRHJhZ09iamVjdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmNhbGwoY29uZmlnLCBlLmRhdGFUcmFuc2ZlciwgdGFyZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBzdHlsZTogX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgcHJldlByb3BzID09IG51bGwgPyB2b2lkIDAgOiBwcmV2UHJvcHMuc3R5bGUpLCB7XG4gICAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIlxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBpdGVtSW5zdGFuY2U6IHtcbiAgICBnZXRQcm9wczogKHsgdHJlZSwgaXRlbSwgcHJldiB9KSA9PiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBwcmV2ID09IG51bGwgPyB2b2lkIDAgOiBwcmV2KCkpLCB7XG4gICAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgICBvbkRyYWdFbnRlcjogKGUpID0+IGUucHJldmVudERlZmF1bHQoKSxcbiAgICAgIG9uRHJhZ1N0YXJ0OiAoZSkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkSXRlbXMgPSB0cmVlLmdldFNlbGVjdGVkSXRlbXMgPyB0cmVlLmdldFNlbGVjdGVkSXRlbXMoKSA6IFt0cmVlLmdldEZvY3VzZWRJdGVtKCldO1xuICAgICAgICBjb25zdCBpdGVtcyA9IHNlbGVjdGVkSXRlbXMuaW5jbHVkZXMoaXRlbSkgPyBzZWxlY3RlZEl0ZW1zIDogW2l0ZW1dO1xuICAgICAgICBjb25zdCBjb25maWcgPSB0cmVlLmdldENvbmZpZygpO1xuICAgICAgICBpZiAoIXNlbGVjdGVkSXRlbXMuaW5jbHVkZXMoaXRlbSkpIHtcbiAgICAgICAgICAoX2EgPSB0cmVlLnNldFNlbGVjdGVkSXRlbXMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKHRyZWUsIFtpdGVtLmdldEl0ZW1NZXRhKCkuaXRlbUlkXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoKF9jID0gKF9iID0gY29uZmlnLmNhbkRyYWcpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKGNvbmZpZywgaXRlbXMpKSAhPSBudWxsID8gX2MgOiB0cnVlKSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5zZXREcmFnSW1hZ2UpIHtcbiAgICAgICAgICBjb25zdCB7IGltZ0VsZW1lbnQsIHhPZmZzZXQsIHlPZmZzZXQgfSA9IGNvbmZpZy5zZXREcmFnSW1hZ2UoaXRlbXMpO1xuICAgICAgICAgIChfZCA9IGUuZGF0YVRyYW5zZmVyKSA9PSBudWxsID8gdm9pZCAwIDogX2Quc2V0RHJhZ0ltYWdlKGltZ0VsZW1lbnQsIHhPZmZzZXQgIT0gbnVsbCA/IHhPZmZzZXQgOiAwLCB5T2Zmc2V0ICE9IG51bGwgPyB5T2Zmc2V0IDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5jcmVhdGVGb3JlaWduRHJhZ09iamVjdCAmJiBlLmRhdGFUcmFuc2Zlcikge1xuICAgICAgICAgIGNvbnN0IHsgZm9ybWF0LCBkYXRhLCBkcm9wRWZmZWN0LCBlZmZlY3RBbGxvd2VkIH0gPSBjb25maWcuY3JlYXRlRm9yZWlnbkRyYWdPYmplY3QoaXRlbXMpO1xuICAgICAgICAgIGUuZGF0YVRyYW5zZmVyLnNldERhdGEoZm9ybWF0LCBkYXRhKTtcbiAgICAgICAgICBpZiAoZHJvcEVmZmVjdCkgZS5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IGRyb3BFZmZlY3Q7XG4gICAgICAgICAgaWYgKGVmZmVjdEFsbG93ZWQpIGUuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSBlZmZlY3RBbGxvd2VkO1xuICAgICAgICB9XG4gICAgICAgIHRyZWUuYXBwbHlTdWJTdGF0ZVVwZGF0ZShcImRuZFwiLCB7XG4gICAgICAgICAgZHJhZ2dlZEl0ZW1zOiBpdGVtcyxcbiAgICAgICAgICBkcmFnZ2luZ092ZXJJdGVtOiB0cmVlLmdldEZvY3VzZWRJdGVtKClcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgb25EcmFnT3ZlcjogKGUpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGNvbnN0IGRhdGFSZWYgPSB0cmVlLmdldERhdGFSZWYoKTtcbiAgICAgICAgY29uc3QgcGxhY2VtZW50ID0gZ2V0VGFyZ2V0UGxhY2VtZW50KGUsIGl0ZW0sIHRyZWUsIHRydWUpO1xuICAgICAgICBjb25zdCBuZXh0RHJhZ0NvZGUgPSBnZXREcmFnQ29kZShpdGVtLCBwbGFjZW1lbnQpO1xuICAgICAgICBpZiAobmV4dERyYWdDb2RlID09PSBkYXRhUmVmLmN1cnJlbnQubGFzdERyYWdDb2RlKSB7XG4gICAgICAgICAgaWYgKGRhdGFSZWYuY3VycmVudC5sYXN0QWxsb3dEcm9wKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkYXRhUmVmLmN1cnJlbnQubGFzdERyYWdDb2RlID0gbmV4dERyYWdDb2RlO1xuICAgICAgICBkYXRhUmVmLmN1cnJlbnQubGFzdERyYWdFbnRlciA9IERhdGUubm93KCk7XG4gICAgICAgIGhhbmRsZUF1dG9PcGVuRm9sZGVyKGRhdGFSZWYsIHRyZWUsIGl0ZW0sIHBsYWNlbWVudCk7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldERyYWdUYXJnZXQoZSwgaXRlbSwgdHJlZSk7XG4gICAgICAgIGlmICghKChfYSA9IHRyZWUuZ2V0U3RhdGUoKS5kbmQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5kcmFnZ2VkSXRlbXMpICYmICghZS5kYXRhVHJhbnNmZXIgfHwgISgoX2MgPSAoX2IgPSB0cmVlLmdldENvbmZpZygpKS5jYW5EcmFnRm9yZWlnbkRyYWdPYmplY3RPdmVyKSA9PSBudWxsID8gdm9pZCAwIDogX2MuY2FsbChfYiwgZS5kYXRhVHJhbnNmZXIsIHRhcmdldCkpKSkge1xuICAgICAgICAgIGRhdGFSZWYuY3VycmVudC5sYXN0QWxsb3dEcm9wID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2FuRHJvcChlLmRhdGFUcmFuc2ZlciwgdGFyZ2V0LCB0cmVlKSkge1xuICAgICAgICAgIGRhdGFSZWYuY3VycmVudC5sYXN0QWxsb3dEcm9wID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyZWUuYXBwbHlTdWJTdGF0ZVVwZGF0ZShcImRuZFwiLCAoc3RhdGUpID0+IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHN0YXRlKSwge1xuICAgICAgICAgIGRyYWdUYXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICBkcmFnZ2luZ092ZXJJdGVtOiBpdGVtXG4gICAgICAgIH0pKTtcbiAgICAgICAgZGF0YVJlZi5jdXJyZW50Lmxhc3RBbGxvd0Ryb3AgPSB0cnVlO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9LFxuICAgICAgb25EcmFnTGVhdmU6ICgpID0+IHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIGNvbnN0IGRhdGFSZWYgPSB0cmVlLmdldERhdGFSZWYoKTtcbiAgICAgICAgICBpZiAoKChfYSA9IGRhdGFSZWYuY3VycmVudC5sYXN0RHJhZ0VudGVyKSAhPSBudWxsID8gX2EgOiAwKSArIDEwMCA+PSBEYXRlLm5vdygpKSByZXR1cm47XG4gICAgICAgICAgZGF0YVJlZi5jdXJyZW50Lmxhc3REcmFnQ29kZSA9IFwibm8tZHJhZ1wiO1xuICAgICAgICAgIHRyZWUuYXBwbHlTdWJTdGF0ZVVwZGF0ZShcImRuZFwiLCAoc3RhdGUpID0+IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHN0YXRlKSwge1xuICAgICAgICAgICAgZHJhZ2dpbmdPdmVySXRlbTogdm9pZCAwLFxuICAgICAgICAgICAgZHJhZ1RhcmdldDogdm9pZCAwXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9LCAxMDApO1xuICAgICAgfSxcbiAgICAgIG9uRHJhZ0VuZDogKGUpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgeyBvbkNvbXBsZXRlRm9yZWlnbkRyb3AsIGNhbkRyYWdGb3JlaWduRHJhZ09iamVjdE92ZXIgfSA9IHRyZWUuZ2V0Q29uZmlnKCk7XG4gICAgICAgIGNvbnN0IGRyYWdnZWRJdGVtcyA9IChfYSA9IHRyZWUuZ2V0U3RhdGUoKS5kbmQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5kcmFnZ2VkSXRlbXM7XG4gICAgICAgIGlmICgoKF9iID0gZS5kYXRhVHJhbnNmZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYi5kcm9wRWZmZWN0KSA9PT0gXCJub25lXCIgfHwgIWRyYWdnZWRJdGVtcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXREcmFnVGFyZ2V0KGUsIGl0ZW0sIHRyZWUpO1xuICAgICAgICBpZiAoY2FuRHJhZ0ZvcmVpZ25EcmFnT2JqZWN0T3ZlciAmJiBlLmRhdGFUcmFuc2ZlciAmJiAhY2FuRHJhZ0ZvcmVpZ25EcmFnT2JqZWN0T3ZlcihlLmRhdGFUcmFuc2ZlciwgdGFyZ2V0KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvbkNvbXBsZXRlRm9yZWlnbkRyb3AgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQ29tcGxldGVGb3JlaWduRHJvcChkcmFnZ2VkSXRlbXMpO1xuICAgICAgfSxcbiAgICAgIG9uRHJvcDogKGUpID0+IF9fYXN5bmMobnVsbCwgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGNvbnN0IGRhdGFSZWYgPSB0cmVlLmdldERhdGFSZWYoKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0RHJhZ1RhcmdldChlLCBpdGVtLCB0cmVlKTtcbiAgICAgICAgY29uc3QgZHJhZ2dlZEl0ZW1zID0gKF9hID0gdHJlZS5nZXRTdGF0ZSgpLmRuZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRyYWdnZWRJdGVtcztcbiAgICAgICAgY29uc3QgaXNWYWxpZERyb3AgPSBjYW5Ecm9wKGUuZGF0YVRyYW5zZmVyLCB0YXJnZXQsIHRyZWUpO1xuICAgICAgICB0cmVlLmFwcGx5U3ViU3RhdGVVcGRhdGUoXCJkbmRcIiwge1xuICAgICAgICAgIGRyYWdnZWRJdGVtczogdm9pZCAwLFxuICAgICAgICAgIGRyYWdnaW5nT3Zlckl0ZW06IHZvaWQgMCxcbiAgICAgICAgICBkcmFnVGFyZ2V0OiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaXNWYWxpZERyb3ApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjb25zdCBjb25maWcgPSB0cmVlLmdldENvbmZpZygpO1xuICAgICAgICBkYXRhUmVmLmN1cnJlbnQubGFzdERyYWdDb2RlID0gdm9pZCAwO1xuICAgICAgICBpZiAoZHJhZ2dlZEl0ZW1zKSB7XG4gICAgICAgICAgeWllbGQgKF9iID0gY29uZmlnLm9uRHJvcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoY29uZmlnLCBkcmFnZ2VkSXRlbXMsIHRhcmdldCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgICB5aWVsZCAoX2MgPSBjb25maWcub25Ecm9wRm9yZWlnbkRyYWdPYmplY3QpID09IG51bGwgPyB2b2lkIDAgOiBfYy5jYWxsKGNvbmZpZywgZS5kYXRhVHJhbnNmZXIsIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSksXG4gICAgaXNEcmFnVGFyZ2V0OiAoeyB0cmVlLCBpdGVtIH0pID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRyZWUuZ2V0RHJhZ1RhcmdldCgpO1xuICAgICAgcmV0dXJuIHRhcmdldCA/IHRhcmdldC5pdGVtLmdldElkKCkgPT09IGl0ZW0uZ2V0SWQoKSA6IGZhbHNlO1xuICAgIH0sXG4gICAgaXNEcmFnVGFyZ2V0QWJvdmU6ICh7IHRyZWUsIGl0ZW0gfSkgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdHJlZS5nZXREcmFnVGFyZ2V0KCk7XG4gICAgICBpZiAoIXRhcmdldCB8fCAhaXNPcmRlcmVkRHJhZ1RhcmdldCh0YXJnZXQpIHx8IHRhcmdldC5pdGVtICE9PSBpdGVtLmdldFBhcmVudCgpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdGFyZ2V0LmNoaWxkSW5kZXggPT09IGl0ZW0uZ2V0SXRlbU1ldGEoKS5wb3NJblNldDtcbiAgICB9LFxuICAgIGlzRHJhZ1RhcmdldEJlbG93OiAoeyB0cmVlLCBpdGVtIH0pID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRyZWUuZ2V0RHJhZ1RhcmdldCgpO1xuICAgICAgaWYgKCF0YXJnZXQgfHwgIWlzT3JkZXJlZERyYWdUYXJnZXQodGFyZ2V0KSB8fCB0YXJnZXQuaXRlbSAhPT0gaXRlbS5nZXRQYXJlbnQoKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRhcmdldC5jaGlsZEluZGV4IC0gMSA9PT0gaXRlbS5nZXRJdGVtTWV0YSgpLnBvc0luU2V0O1xuICAgIH0sXG4gICAgaXNEcmFnZ2luZ092ZXI6ICh7IHRyZWUsIGl0ZW0gfSkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIHJldHVybiAoKF9iID0gKF9hID0gdHJlZS5nZXRTdGF0ZSgpLmRuZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRyYWdnaW5nT3Zlckl0ZW0pID09IG51bGwgPyB2b2lkIDAgOiBfYi5nZXRJZCgpKSA9PT0gaXRlbS5nZXRJZCgpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2ZlYXR1cmVzL2tleWJvYXJkLWRyYWctYW5kLWRyb3AvZmVhdHVyZS50c1xudmFyIGdldE5leHREcmFnVGFyZ2V0ID0gKHRyZWUsIGlzVXAsIGRyYWdUYXJnZXQpID0+IHtcbiAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICBjb25zdCBkaXJlY3Rpb24gPSBpc1VwID8gMCA6IDE7XG4gIGNvbnN0IGRyYWdnZWRJdGVtcyA9IChfYSA9IHRyZWUuZ2V0U3RhdGUoKS5kbmQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5kcmFnZ2VkSXRlbXM7XG4gIGlmIChpc09yZGVyZWREcmFnVGFyZ2V0KGRyYWdUYXJnZXQpKSB7XG4gICAgY29uc3QgcGFyZW50ID0gZHJhZ1RhcmdldC5pdGVtLmdldFBhcmVudCgpO1xuICAgIGNvbnN0IHRhcmdldGVkSXRlbSA9IHRyZWUuZ2V0SXRlbXMoKVtkcmFnVGFyZ2V0LmRyYWdMaW5lSW5kZXggLSAxXTtcbiAgICBjb25zdCB0YXJnZXRDYXRlZ29yeSA9IHRhcmdldGVkSXRlbSA/IGdldEl0ZW1Ecm9wQ2F0ZWdvcnkodGFyZ2V0ZWRJdGVtKSA6IDAgLyogSXRlbSAqLztcbiAgICBjb25zdCBtYXhMZXZlbCA9IChfYiA9IHRhcmdldGVkSXRlbSA9PSBudWxsID8gdm9pZCAwIDogdGFyZ2V0ZWRJdGVtLmdldEl0ZW1NZXRhKCkubGV2ZWwpICE9IG51bGwgPyBfYiA6IDA7XG4gICAgY29uc3QgbWluTGV2ZWwgPSAoX2QgPSAoX2MgPSB0YXJnZXRlZEl0ZW0gPT0gbnVsbCA/IHZvaWQgMCA6IHRhcmdldGVkSXRlbS5nZXRJdGVtQmVsb3coKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmdldEl0ZW1NZXRhKCkubGV2ZWwpICE9IG51bGwgPyBfZCA6IDA7XG4gICAgaWYgKHRhcmdldENhdGVnb3J5ID09PSAyIC8qIExhc3RJbkdyb3VwICovKSB7XG4gICAgICBpZiAoaXNVcCAmJiBkcmFnVGFyZ2V0LmRyYWdMaW5lTGV2ZWwgPCBtYXhMZXZlbCkge1xuICAgICAgICByZXR1cm4gZ2V0UmVwYXJlbnRUYXJnZXQoXG4gICAgICAgICAgdGFyZ2V0ZWRJdGVtLFxuICAgICAgICAgIGRyYWdUYXJnZXQuZHJhZ0xpbmVMZXZlbCArIDEsXG4gICAgICAgICAgZHJhZ2dlZEl0ZW1zXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzVXAgJiYgZHJhZ1RhcmdldC5kcmFnTGluZUxldmVsID4gbWluTGV2ZWwgJiYgcGFyZW50KSB7XG4gICAgICAgIHJldHVybiBnZXRSZXBhcmVudFRhcmdldChcbiAgICAgICAgICB0YXJnZXRlZEl0ZW0sXG4gICAgICAgICAgZHJhZ1RhcmdldC5kcmFnTGluZUxldmVsIC0gMSxcbiAgICAgICAgICBkcmFnZ2VkSXRlbXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbmV3SW5kZXggPSBkcmFnVGFyZ2V0LmRyYWdMaW5lSW5kZXggLSAxICsgZGlyZWN0aW9uO1xuICAgIGNvbnN0IGl0ZW0gPSB0cmVlLmdldEl0ZW1zKClbbmV3SW5kZXhdO1xuICAgIHJldHVybiBpdGVtID8geyBpdGVtIH0gOiB2b2lkIDA7XG4gIH1cbiAgY29uc3QgdGFyZ2V0aW5nRXhwYW5kZWRGb2xkZXIgPSBnZXRJdGVtRHJvcENhdGVnb3J5KGRyYWdUYXJnZXQuaXRlbSkgPT09IDEgLyogRXhwYW5kZWRGb2xkZXIgKi87XG4gIGlmICh0YXJnZXRpbmdFeHBhbmRlZEZvbGRlciAmJiAhaXNVcCkge1xuICAgIHJldHVybiB7XG4gICAgICBpdGVtOiBkcmFnVGFyZ2V0Lml0ZW0sXG4gICAgICBjaGlsZEluZGV4OiAwLFxuICAgICAgaW5zZXJ0aW9uSW5kZXg6IGdldEluc2VydGlvbkluZGV4KFxuICAgICAgICBkcmFnVGFyZ2V0Lml0ZW0uZ2V0Q2hpbGRyZW4oKSxcbiAgICAgICAgMCxcbiAgICAgICAgZHJhZ2dlZEl0ZW1zXG4gICAgICApLFxuICAgICAgZHJhZ0xpbmVJbmRleDogZHJhZ1RhcmdldC5pdGVtLmdldEl0ZW1NZXRhKCkuaW5kZXggKyBkaXJlY3Rpb24sXG4gICAgICBkcmFnTGluZUxldmVsOiBkcmFnVGFyZ2V0Lml0ZW0uZ2V0SXRlbU1ldGEoKS5sZXZlbCArIDFcbiAgICB9O1xuICB9XG4gIGNvbnN0IGNoaWxkSW5kZXggPSBkcmFnVGFyZ2V0Lml0ZW0uZ2V0SW5kZXhJblBhcmVudCgpICsgZGlyZWN0aW9uO1xuICByZXR1cm4ge1xuICAgIGl0ZW06IGRyYWdUYXJnZXQuaXRlbS5nZXRQYXJlbnQoKSxcbiAgICBjaGlsZEluZGV4LFxuICAgIGluc2VydGlvbkluZGV4OiBnZXRJbnNlcnRpb25JbmRleChcbiAgICAgIGRyYWdUYXJnZXQuaXRlbS5nZXRQYXJlbnQoKS5nZXRDaGlsZHJlbigpLFxuICAgICAgY2hpbGRJbmRleCxcbiAgICAgIGRyYWdnZWRJdGVtc1xuICAgICksXG4gICAgZHJhZ0xpbmVJbmRleDogZHJhZ1RhcmdldC5pdGVtLmdldEl0ZW1NZXRhKCkuaW5kZXggKyBkaXJlY3Rpb24sXG4gICAgZHJhZ0xpbmVMZXZlbDogZHJhZ1RhcmdldC5pdGVtLmdldEl0ZW1NZXRhKCkubGV2ZWxcbiAgfTtcbn07XG52YXIgZ2V0TmV4dFZhbGlkRHJhZ1RhcmdldCA9ICh0cmVlLCBpc1VwLCBwcmV2aW91c1RhcmdldCA9ICgoX2EpID0+IChfYSA9IHRyZWUuZ2V0U3RhdGUoKS5kbmQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5kcmFnVGFyZ2V0KSgpKSA9PiB7XG4gIHZhciBfYTI7XG4gIGlmICghcHJldmlvdXNUYXJnZXQpIHJldHVybiB2b2lkIDA7XG4gIGNvbnN0IG5leHRUYXJnZXQgPSBnZXROZXh0RHJhZ1RhcmdldCh0cmVlLCBpc1VwLCBwcmV2aW91c1RhcmdldCk7XG4gIGNvbnN0IGRhdGFUcmFuc2ZlciA9IChfYTIgPSB0cmVlLmdldERhdGFSZWYoKS5jdXJyZW50LmtEbmREYXRhVHJhbnNmZXIpICE9IG51bGwgPyBfYTIgOiBudWxsO1xuICBpZiAoIW5leHRUYXJnZXQpIHJldHVybiB2b2lkIDA7XG4gIGlmIChjYW5Ecm9wKGRhdGFUcmFuc2ZlciwgbmV4dFRhcmdldCwgdHJlZSkpIHtcbiAgICByZXR1cm4gbmV4dFRhcmdldDtcbiAgfVxuICByZXR1cm4gZ2V0TmV4dFZhbGlkRHJhZ1RhcmdldCh0cmVlLCBpc1VwLCBuZXh0VGFyZ2V0KTtcbn07XG52YXIgdXBkYXRlU2Nyb2xsID0gKHRyZWUpID0+IHtcbiAgY29uc3Qgc3RhdGUgPSB0cmVlLmdldFN0YXRlKCkuZG5kO1xuICBpZiAoIShzdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZHJhZ1RhcmdldCkgfHwgaXNPcmRlcmVkRHJhZ1RhcmdldChzdGF0ZS5kcmFnVGFyZ2V0KSkgcmV0dXJuO1xuICBzdGF0ZS5kcmFnVGFyZ2V0Lml0ZW0uc2Nyb2xsVG8oeyBibG9jazogXCJuZWFyZXN0XCIsIGlubGluZTogXCJuZWFyZXN0XCIgfSk7XG59O1xudmFyIGluaXRpYXRlRHJhZyA9ICh0cmVlLCBkcmFnZ2VkSXRlbXMsIGRhdGFUcmFuc2ZlcikgPT4ge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCBmb2N1c2VkSXRlbSA9IHRyZWUuZ2V0Rm9jdXNlZEl0ZW0oKTtcbiAgY29uc3QgeyBjYW5EcmFnIH0gPSB0cmVlLmdldENvbmZpZygpO1xuICBpZiAoZHJhZ2dlZEl0ZW1zICYmIGNhbkRyYWcgJiYgIWNhbkRyYWcoZHJhZ2dlZEl0ZW1zKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZHJhZ2dlZEl0ZW1zKSB7XG4gICAgdHJlZS5hcHBseVN1YlN0YXRlVXBkYXRlKFwiZG5kXCIsIHsgZHJhZ2dlZEl0ZW1zIH0pO1xuICAgIChfYiA9IChfYSA9IHRyZWUuZ2V0Q29uZmlnKCkpLm9uU3RhcnRLZXlib2FyZERyYWcpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBkcmFnZ2VkSXRlbXMpO1xuICB9IGVsc2UgaWYgKGRhdGFUcmFuc2Zlcikge1xuICAgIHRyZWUuZ2V0RGF0YVJlZigpLmN1cnJlbnQua0RuZERhdGFUcmFuc2ZlciA9IGRhdGFUcmFuc2ZlcjtcbiAgfVxuICBjb25zdCBkcmFnVGFyZ2V0ID0gZ2V0TmV4dFZhbGlkRHJhZ1RhcmdldCh0cmVlLCBmYWxzZSwge1xuICAgIGl0ZW06IGZvY3VzZWRJdGVtXG4gIH0pO1xuICBpZiAoIWRyYWdUYXJnZXQpIHJldHVybjtcbiAgdHJlZS5hcHBseVN1YlN0YXRlVXBkYXRlKFwiZG5kXCIsIHtcbiAgICBkcmFnZ2VkSXRlbXMsXG4gICAgZHJhZ1RhcmdldFxuICB9KTtcbiAgdHJlZS5hcHBseVN1YlN0YXRlVXBkYXRlKFwiYXNzaXN0aXZlRG5kU3RhdGVcIiwgMSAvKiBTdGFydGVkICovKTtcbiAgdXBkYXRlU2Nyb2xsKHRyZWUpO1xufTtcbnZhciBtb3ZlRHJhZ1Bvc2l0aW9uID0gKHRyZWUsIGlzVXApID0+IHtcbiAgdmFyIF9hO1xuICBjb25zdCBkcmFnVGFyZ2V0ID0gZ2V0TmV4dFZhbGlkRHJhZ1RhcmdldCh0cmVlLCBpc1VwKTtcbiAgaWYgKCFkcmFnVGFyZ2V0KSByZXR1cm47XG4gIHRyZWUuYXBwbHlTdWJTdGF0ZVVwZGF0ZShcImRuZFwiLCB7XG4gICAgZHJhZ2dlZEl0ZW1zOiAoX2EgPSB0cmVlLmdldFN0YXRlKCkuZG5kKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZHJhZ2dlZEl0ZW1zLFxuICAgIGRyYWdUYXJnZXRcbiAgfSk7XG4gIHRyZWUuYXBwbHlTdWJTdGF0ZVVwZGF0ZShcImFzc2lzdGl2ZURuZFN0YXRlXCIsIDIgLyogRHJhZ2dpbmcgKi8pO1xuICBpZiAoIWlzT3JkZXJlZERyYWdUYXJnZXQoZHJhZ1RhcmdldCkpIHtcbiAgICBkcmFnVGFyZ2V0Lml0ZW0uc2V0Rm9jdXNlZCgpO1xuICB9XG4gIHVwZGF0ZVNjcm9sbCh0cmVlKTtcbn07XG52YXIga2V5Ym9hcmREcmFnQW5kRHJvcEZlYXR1cmUgPSB7XG4gIGtleTogXCJrZXlib2FyZC1kcmFnLWFuZC1kcm9wXCIsXG4gIGRlcHM6IFtcImRyYWctYW5kLWRyb3BcIl0sXG4gIGdldERlZmF1bHRDb25maWc6IChkZWZhdWx0Q29uZmlnLCB0cmVlKSA9PiBfX3NwcmVhZFZhbHVlcyh7XG4gICAgc2V0QXNzaXN0aXZlRG5kU3RhdGU6IG1ha2VTdGF0ZVVwZGF0ZXIoXCJhc3Npc3RpdmVEbmRTdGF0ZVwiLCB0cmVlKVxuICB9LCBkZWZhdWx0Q29uZmlnKSxcbiAgc3RhdGVIYW5kbGVyTmFtZXM6IHtcbiAgICBhc3Npc3RpdmVEbmRTdGF0ZTogXCJzZXRBc3Npc3RpdmVEbmRTdGF0ZVwiXG4gIH0sXG4gIHRyZWVJbnN0YW5jZToge1xuICAgIHN0YXJ0S2V5Ym9hcmREcmFnOiAoeyB0cmVlIH0sIGRyYWdnZWRJdGVtcykgPT4ge1xuICAgICAgaW5pdGlhdGVEcmFnKHRyZWUsIGRyYWdnZWRJdGVtcywgdm9pZCAwKTtcbiAgICB9LFxuICAgIHN0YXJ0S2V5Ym9hcmREcmFnT25Gb3JlaWduT2JqZWN0OiAoeyB0cmVlIH0sIGRhdGFUcmFuc2ZlcikgPT4ge1xuICAgICAgaW5pdGlhdGVEcmFnKHRyZWUsIHZvaWQgMCwgZGF0YVRyYW5zZmVyKTtcbiAgICB9LFxuICAgIHN0b3BLZXlib2FyZERyYWc6ICh7IHRyZWUgfSkgPT4ge1xuICAgICAgdHJlZS5nZXREYXRhUmVmKCkuY3VycmVudC5rRG5kRGF0YVRyYW5zZmVyID0gdm9pZCAwO1xuICAgICAgdHJlZS5hcHBseVN1YlN0YXRlVXBkYXRlKFwiZG5kXCIsIG51bGwpO1xuICAgICAgdHJlZS5hcHBseVN1YlN0YXRlVXBkYXRlKFwiYXNzaXN0aXZlRG5kU3RhdGVcIiwgMCAvKiBOb25lICovKTtcbiAgICB9XG4gIH0sXG4gIGhvdGtleXM6IHtcbiAgICBzdGFydERyYWc6IHtcbiAgICAgIGhvdGtleTogXCJDb250cm9sK1NoaWZ0K0tleURcIixcbiAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlLFxuICAgICAgaXNFbmFibGVkOiAodHJlZSkgPT4gIXRyZWUuZ2V0U3RhdGUoKS5kbmQsXG4gICAgICBoYW5kbGVyOiAoXywgdHJlZSkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBzZWxlY3RlZEl0ZW1zID0gKF9iID0gKF9hID0gdHJlZS5nZXRTZWxlY3RlZEl0ZW1zKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbCh0cmVlKSkgIT0gbnVsbCA/IF9iIDogW1xuICAgICAgICAgIHRyZWUuZ2V0Rm9jdXNlZEl0ZW0oKVxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBmb2N1c2VkSXRlbSA9IHRyZWUuZ2V0Rm9jdXNlZEl0ZW0oKTtcbiAgICAgICAgdHJlZS5zdGFydEtleWJvYXJkRHJhZyhcbiAgICAgICAgICBzZWxlY3RlZEl0ZW1zLmluY2x1ZGVzKGZvY3VzZWRJdGVtKSA/IHNlbGVjdGVkSXRlbXMgOiBzZWxlY3RlZEl0ZW1zLmNvbmNhdChmb2N1c2VkSXRlbSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRyYWdVcDoge1xuICAgICAgaG90a2V5OiBcIkFycm93VXBcIixcbiAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlLFxuICAgICAgaXNFbmFibGVkOiAodHJlZSkgPT4gISF0cmVlLmdldFN0YXRlKCkuZG5kLFxuICAgICAgaGFuZGxlcjogKF8sIHRyZWUpID0+IHtcbiAgICAgICAgbW92ZURyYWdQb3NpdGlvbih0cmVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRyYWdEb3duOiB7XG4gICAgICBob3RrZXk6IFwiQXJyb3dEb3duXCIsXG4gICAgICBwcmV2ZW50RGVmYXVsdDogdHJ1ZSxcbiAgICAgIGlzRW5hYmxlZDogKHRyZWUpID0+ICEhdHJlZS5nZXRTdGF0ZSgpLmRuZCxcbiAgICAgIGhhbmRsZXI6IChfLCB0cmVlKSA9PiB7XG4gICAgICAgIG1vdmVEcmFnUG9zaXRpb24odHJlZSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2FuY2VsRHJhZzoge1xuICAgICAgaG90a2V5OiBcIkVzY2FwZVwiLFxuICAgICAgaXNFbmFibGVkOiAodHJlZSkgPT4gISF0cmVlLmdldFN0YXRlKCkuZG5kLFxuICAgICAgaGFuZGxlcjogKF8sIHRyZWUpID0+IHtcbiAgICAgICAgdHJlZS5zdG9wS2V5Ym9hcmREcmFnKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjb21wbGV0ZURyYWc6IHtcbiAgICAgIGhvdGtleTogXCJFbnRlclwiLFxuICAgICAgcHJldmVudERlZmF1bHQ6IHRydWUsXG4gICAgICBpc0VuYWJsZWQ6ICh0cmVlKSA9PiAhIXRyZWUuZ2V0U3RhdGUoKS5kbmQsXG4gICAgICBoYW5kbGVyOiAoZSwgdHJlZSkgPT4gX19hc3luYyhudWxsLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGNvbnN0IGRhdGFSZWYgPSB0cmVlLmdldERhdGFSZWYoKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdHJlZS5nZXREcmFnVGFyZ2V0KCk7XG4gICAgICAgIGNvbnN0IGRhdGFUcmFuc2ZlciA9IChfYSA9IGRhdGFSZWYuY3VycmVudC5rRG5kRGF0YVRyYW5zZmVyKSAhPSBudWxsID8gX2EgOiBudWxsO1xuICAgICAgICBpZiAoIXRhcmdldCB8fCAhY2FuRHJvcChkYXRhVHJhbnNmZXIsIHRhcmdldCwgdHJlZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uZmlnID0gdHJlZS5nZXRDb25maWcoKTtcbiAgICAgICAgY29uc3QgZHJhZ2dlZEl0ZW1zID0gKF9iID0gdHJlZS5nZXRTdGF0ZSgpLmRuZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmRyYWdnZWRJdGVtcztcbiAgICAgICAgZGF0YVJlZi5jdXJyZW50Lmxhc3REcmFnQ29kZSA9IHZvaWQgMDtcbiAgICAgICAgdHJlZS5hcHBseVN1YlN0YXRlVXBkYXRlKFwiZG5kXCIsIG51bGwpO1xuICAgICAgICBpZiAoZHJhZ2dlZEl0ZW1zKSB7XG4gICAgICAgICAgeWllbGQgKF9jID0gY29uZmlnLm9uRHJvcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmNhbGwoY29uZmlnLCBkcmFnZ2VkSXRlbXMsIHRhcmdldCk7XG4gICAgICAgICAgdHJlZS5nZXRJdGVtSW5zdGFuY2UoZHJhZ2dlZEl0ZW1zWzBdLmdldElkKCkpLnNldEZvY3VzZWQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgICB5aWVsZCAoX2QgPSBjb25maWcub25Ecm9wRm9yZWlnbkRyYWdPYmplY3QpID09IG51bGwgPyB2b2lkIDAgOiBfZC5jYWxsKGNvbmZpZywgZGF0YVRyYW5zZmVyLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIHRyZWUuYXBwbHlTdWJTdGF0ZVVwZGF0ZShcbiAgICAgICAgICBcImFzc2lzdGl2ZURuZFN0YXRlXCIsXG4gICAgICAgICAgMyAvKiBDb21wbGV0ZWQgKi9cbiAgICAgICAgKTtcbiAgICAgIH0pXG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZmVhdHVyZXMvc2VhcmNoL2ZlYXR1cmUudHNcbnZhciBzZWFyY2hGZWF0dXJlID0ge1xuICBrZXk6IFwic2VhcmNoXCIsXG4gIGdldEluaXRpYWxTdGF0ZTogKGluaXRpYWxTdGF0ZSkgPT4gX19zcHJlYWRWYWx1ZXMoe1xuICAgIHNlYXJjaDogbnVsbFxuICB9LCBpbml0aWFsU3RhdGUpLFxuICBnZXREZWZhdWx0Q29uZmlnOiAoZGVmYXVsdENvbmZpZywgdHJlZSkgPT4gX19zcHJlYWRWYWx1ZXMoe1xuICAgIHNldFNlYXJjaDogbWFrZVN0YXRlVXBkYXRlcihcInNlYXJjaFwiLCB0cmVlKSxcbiAgICBpc1NlYXJjaE1hdGNoaW5nSXRlbTogKHNlYXJjaCwgaXRlbSkgPT4gc2VhcmNoLmxlbmd0aCA+IDAgJiYgaXRlbS5nZXRJdGVtTmFtZSgpLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoc2VhcmNoLnRvTG93ZXJDYXNlKCkpXG4gIH0sIGRlZmF1bHRDb25maWcpLFxuICBzdGF0ZUhhbmRsZXJOYW1lczoge1xuICAgIHNlYXJjaDogXCJzZXRTZWFyY2hcIlxuICB9LFxuICB0cmVlSW5zdGFuY2U6IHtcbiAgICBzZXRTZWFyY2g6ICh7IHRyZWUgfSwgc2VhcmNoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICB0cmVlLmFwcGx5U3ViU3RhdGVVcGRhdGUoXCJzZWFyY2hcIiwgc2VhcmNoKTtcbiAgICAgIChfYSA9IHRyZWUuZ2V0SXRlbXMoKS5maW5kKFxuICAgICAgICAoaXRlbSkgPT4ge1xuICAgICAgICAgIHZhciBfYTIsIF9iO1xuICAgICAgICAgIHJldHVybiAoX2IgPSAoX2EyID0gdHJlZS5nZXRDb25maWcoKSkuaXNTZWFyY2hNYXRjaGluZ0l0ZW0pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hMiwgdHJlZS5nZXRTZWFyY2hWYWx1ZSgpLCBpdGVtKTtcbiAgICAgICAgfVxuICAgICAgKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNldEZvY3VzZWQoKTtcbiAgICB9LFxuICAgIG9wZW5TZWFyY2g6ICh7IHRyZWUgfSwgaW5pdGlhbFZhbHVlID0gXCJcIikgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIHRyZWUuc2V0U2VhcmNoKGluaXRpYWxWYWx1ZSk7XG4gICAgICAoX2IgPSAoX2EgPSB0cmVlLmdldENvbmZpZygpKS5vbk9wZW5TZWFyY2gpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICAoX2EyID0gdHJlZS5nZXREYXRhUmVmKCkuY3VycmVudC5zZWFyY2hJbnB1dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5mb2N1cygpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBjbG9zZVNlYXJjaDogKHsgdHJlZSB9KSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgdHJlZS5zZXRTZWFyY2gobnVsbCk7XG4gICAgICAoX2IgPSAoX2EgPSB0cmVlLmdldENvbmZpZygpKS5vbkNsb3NlU2VhcmNoKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICB0cmVlLnVwZGF0ZURvbUZvY3VzKCk7XG4gICAgfSxcbiAgICBpc1NlYXJjaE9wZW46ICh7IHRyZWUgfSkgPT4gdHJlZS5nZXRTdGF0ZSgpLnNlYXJjaCAhPT0gbnVsbCxcbiAgICBnZXRTZWFyY2hWYWx1ZTogKHsgdHJlZSB9KSA9PiB0cmVlLmdldFN0YXRlKCkuc2VhcmNoIHx8IFwiXCIsXG4gICAgcmVnaXN0ZXJTZWFyY2hJbnB1dEVsZW1lbnQ6ICh7IHRyZWUgfSwgZWxlbWVudCkgPT4ge1xuICAgICAgY29uc3QgZGF0YVJlZiA9IHRyZWUuZ2V0RGF0YVJlZigpO1xuICAgICAgZGF0YVJlZi5jdXJyZW50LnNlYXJjaElucHV0ID0gZWxlbWVudDtcbiAgICAgIGlmIChlbGVtZW50ICYmIGRhdGFSZWYuY3VycmVudC5rZXlkb3duSGFuZGxlcikge1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGRhdGFSZWYuY3VycmVudC5rZXlkb3duSGFuZGxlcik7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRTZWFyY2hJbnB1dEVsZW1lbnQ6ICh7IHRyZWUgfSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIChfYSA9IHRyZWUuZ2V0RGF0YVJlZigpLmN1cnJlbnQuc2VhcmNoSW5wdXQpICE9IG51bGwgPyBfYSA6IG51bGw7XG4gICAgfSxcbiAgICAvLyBUT0RPIG1lbW9pemUgd2l0aCBwcm9wTWVtb2l6YXRpb25GZWF0dXJlXG4gICAgZ2V0U2VhcmNoSW5wdXRFbGVtZW50UHJvcHM6ICh7IHRyZWUgfSkgPT4gKHtcbiAgICAgIHZhbHVlOiB0cmVlLmdldFNlYXJjaFZhbHVlKCksXG4gICAgICBvbkNoYW5nZTogKGUpID0+IHRyZWUuc2V0U2VhcmNoKGUudGFyZ2V0LnZhbHVlKSxcbiAgICAgIG9uQmx1cjogKCkgPT4gdHJlZS5jbG9zZVNlYXJjaCgpLFxuICAgICAgcmVmOiB0cmVlLnJlZ2lzdGVyU2VhcmNoSW5wdXRFbGVtZW50XG4gICAgfSksXG4gICAgZ2V0U2VhcmNoTWF0Y2hpbmdJdGVtczogbWVtbyhcbiAgICAgICh7IHRyZWUgfSkgPT4gW1xuICAgICAgICB0cmVlLmdldFNlYXJjaFZhbHVlKCksXG4gICAgICAgIHRyZWUuZ2V0SXRlbXMoKSxcbiAgICAgICAgdHJlZS5nZXRDb25maWcoKS5pc1NlYXJjaE1hdGNoaW5nSXRlbVxuICAgICAgXSxcbiAgICAgIChzZWFyY2gsIGl0ZW1zLCBpc1NlYXJjaE1hdGNoaW5nSXRlbSkgPT4gaXRlbXMuZmlsdGVyKChpdGVtKSA9PiBzZWFyY2ggJiYgKGlzU2VhcmNoTWF0Y2hpbmdJdGVtID09IG51bGwgPyB2b2lkIDAgOiBpc1NlYXJjaE1hdGNoaW5nSXRlbShzZWFyY2gsIGl0ZW0pKSlcbiAgICApXG4gIH0sXG4gIGl0ZW1JbnN0YW5jZToge1xuICAgIGlzTWF0Y2hpbmdTZWFyY2g6ICh7IHRyZWUsIGl0ZW0gfSkgPT4gdHJlZS5nZXRTZWFyY2hNYXRjaGluZ0l0ZW1zKCkuc29tZSgoaSkgPT4gaS5nZXRJZCgpID09PSBpdGVtLmdldElkKCkpXG4gIH0sXG4gIGhvdGtleXM6IHtcbiAgICBvcGVuU2VhcmNoOiB7XG4gICAgICBob3RrZXk6IFwiTGV0dGVyT3JOdW1iZXJcIixcbiAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlLFxuICAgICAgLy8gVE9ETyBtYWtlIHRydWUgZGVmYXVsdFxuICAgICAgaXNFbmFibGVkOiAodHJlZSkgPT4gIXRyZWUuaXNTZWFyY2hPcGVuKCksXG4gICAgICBoYW5kbGVyOiAoZSwgdHJlZSkgPT4ge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB0cmVlLm9wZW5TZWFyY2goZS5rZXkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2xvc2VTZWFyY2g6IHtcbiAgICAgIC8vIFRPRE8gYWxsb3cgbXVsdGlwbGUsIGkuZS4gRW50ZXJcbiAgICAgIGhvdGtleTogXCJFc2NhcGVcIixcbiAgICAgIGFsbG93V2hlbklucHV0Rm9jdXNlZDogdHJ1ZSxcbiAgICAgIGlzRW5hYmxlZDogKHRyZWUpID0+IHRyZWUuaXNTZWFyY2hPcGVuKCksXG4gICAgICBoYW5kbGVyOiAoZSwgdHJlZSkgPT4ge1xuICAgICAgICB0cmVlLmNsb3NlU2VhcmNoKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzdWJtaXRTZWFyY2g6IHtcbiAgICAgIGhvdGtleTogXCJFbnRlclwiLFxuICAgICAgYWxsb3dXaGVuSW5wdXRGb2N1c2VkOiB0cnVlLFxuICAgICAgaXNFbmFibGVkOiAodHJlZSkgPT4gdHJlZS5pc1NlYXJjaE9wZW4oKSxcbiAgICAgIGhhbmRsZXI6IChlLCB0cmVlKSA9PiB7XG4gICAgICAgIHRyZWUuY2xvc2VTZWFyY2goKTtcbiAgICAgICAgdHJlZS5zZXRTZWxlY3RlZEl0ZW1zKFt0cmVlLmdldEZvY3VzZWRJdGVtKCkuZ2V0SWQoKV0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgbmV4dFNlYXJjaEl0ZW06IHtcbiAgICAgIGhvdGtleTogXCJBcnJvd0Rvd25cIixcbiAgICAgIGFsbG93V2hlbklucHV0Rm9jdXNlZDogdHJ1ZSxcbiAgICAgIGNhblJlcGVhdDogdHJ1ZSxcbiAgICAgIGlzRW5hYmxlZDogKHRyZWUpID0+IHRyZWUuaXNTZWFyY2hPcGVuKCksXG4gICAgICBoYW5kbGVyOiAoZSwgdHJlZSkgPT4ge1xuICAgICAgICBjb25zdCBmb2N1c0l0ZW0gPSB0cmVlLmdldFNlYXJjaE1hdGNoaW5nSXRlbXMoKS5maW5kKFxuICAgICAgICAgIChpdGVtKSA9PiBpdGVtLmdldEl0ZW1NZXRhKCkuaW5kZXggPiB0cmVlLmdldEZvY3VzZWRJdGVtKCkuZ2V0SXRlbU1ldGEoKS5pbmRleFxuICAgICAgICApO1xuICAgICAgICBmb2N1c0l0ZW0gPT0gbnVsbCA/IHZvaWQgMCA6IGZvY3VzSXRlbS5zZXRGb2N1c2VkKCk7XG4gICAgICAgIGZvY3VzSXRlbSA9PSBudWxsID8gdm9pZCAwIDogZm9jdXNJdGVtLnNjcm9sbFRvKHsgYmxvY2s6IFwibmVhcmVzdFwiLCBpbmxpbmU6IFwibmVhcmVzdFwiIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgcHJldmlvdXNTZWFyY2hJdGVtOiB7XG4gICAgICBob3RrZXk6IFwiQXJyb3dVcFwiLFxuICAgICAgYWxsb3dXaGVuSW5wdXRGb2N1c2VkOiB0cnVlLFxuICAgICAgY2FuUmVwZWF0OiB0cnVlLFxuICAgICAgaXNFbmFibGVkOiAodHJlZSkgPT4gdHJlZS5pc1NlYXJjaE9wZW4oKSxcbiAgICAgIGhhbmRsZXI6IChlLCB0cmVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGZvY3VzSXRlbSA9IFsuLi50cmVlLmdldFNlYXJjaE1hdGNoaW5nSXRlbXMoKV0ucmV2ZXJzZSgpLmZpbmQoXG4gICAgICAgICAgKGl0ZW0pID0+IGl0ZW0uZ2V0SXRlbU1ldGEoKS5pbmRleCA8IHRyZWUuZ2V0Rm9jdXNlZEl0ZW0oKS5nZXRJdGVtTWV0YSgpLmluZGV4XG4gICAgICAgICk7XG4gICAgICAgIGZvY3VzSXRlbSA9PSBudWxsID8gdm9pZCAwIDogZm9jdXNJdGVtLnNldEZvY3VzZWQoKTtcbiAgICAgICAgZm9jdXNJdGVtID09IG51bGwgPyB2b2lkIDAgOiBmb2N1c0l0ZW0uc2Nyb2xsVG8oeyBibG9jazogXCJuZWFyZXN0XCIsIGlubGluZTogXCJuZWFyZXN0XCIgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZmVhdHVyZXMvcmVuYW1pbmcvZmVhdHVyZS50c1xudmFyIHJlbmFtaW5nRmVhdHVyZSA9IHtcbiAga2V5OiBcInJlbmFtaW5nXCIsXG4gIG92ZXJ3cml0ZXM6IFtcImRyYWctYW5kLWRyb3BcIl0sXG4gIGdldERlZmF1bHRDb25maWc6IChkZWZhdWx0Q29uZmlnLCB0cmVlKSA9PiBfX3NwcmVhZFZhbHVlcyh7XG4gICAgc2V0UmVuYW1pbmdJdGVtOiBtYWtlU3RhdGVVcGRhdGVyKFwicmVuYW1pbmdJdGVtXCIsIHRyZWUpLFxuICAgIHNldFJlbmFtaW5nVmFsdWU6IG1ha2VTdGF0ZVVwZGF0ZXIoXCJyZW5hbWluZ1ZhbHVlXCIsIHRyZWUpLFxuICAgIGNhblJlbmFtZTogKCkgPT4gdHJ1ZVxuICB9LCBkZWZhdWx0Q29uZmlnKSxcbiAgc3RhdGVIYW5kbGVyTmFtZXM6IHtcbiAgICByZW5hbWluZ0l0ZW06IFwic2V0UmVuYW1pbmdJdGVtXCIsXG4gICAgcmVuYW1pbmdWYWx1ZTogXCJzZXRSZW5hbWluZ1ZhbHVlXCJcbiAgfSxcbiAgdHJlZUluc3RhbmNlOiB7XG4gICAgZ2V0UmVuYW1pbmdJdGVtOiAoeyB0cmVlIH0pID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1JZCA9IHRyZWUuZ2V0U3RhdGUoKS5yZW5hbWluZ0l0ZW07XG4gICAgICByZXR1cm4gaXRlbUlkID8gdHJlZS5nZXRJdGVtSW5zdGFuY2UoaXRlbUlkKSA6IG51bGw7XG4gICAgfSxcbiAgICBnZXRSZW5hbWluZ1ZhbHVlOiAoeyB0cmVlIH0pID0+IHRyZWUuZ2V0U3RhdGUoKS5yZW5hbWluZ1ZhbHVlIHx8IFwiXCIsXG4gICAgYWJvcnRSZW5hbWluZzogKHsgdHJlZSB9KSA9PiB7XG4gICAgICB0cmVlLmFwcGx5U3ViU3RhdGVVcGRhdGUoXCJyZW5hbWluZ0l0ZW1cIiwgbnVsbCk7XG4gICAgICB0cmVlLnVwZGF0ZURvbUZvY3VzKCk7XG4gICAgfSxcbiAgICBjb21wbGV0ZVJlbmFtaW5nOiAoeyB0cmVlIH0pID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHRyZWUuZ2V0Q29uZmlnKCk7XG4gICAgICBjb25zdCBpdGVtID0gdHJlZS5nZXRSZW5hbWluZ0l0ZW0oKTtcbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIChfYSA9IGNvbmZpZy5vblJlbmFtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoY29uZmlnLCBpdGVtLCB0cmVlLmdldFN0YXRlKCkucmVuYW1pbmdWYWx1ZSB8fCBcIlwiKTtcbiAgICAgIH1cbiAgICAgIHRyZWUuYXBwbHlTdWJTdGF0ZVVwZGF0ZShcInJlbmFtaW5nSXRlbVwiLCBudWxsKTtcbiAgICAgIHRyZWUudXBkYXRlRG9tRm9jdXMoKTtcbiAgICB9LFxuICAgIGlzUmVuYW1pbmdJdGVtOiAoeyB0cmVlIH0pID0+ICEhdHJlZS5nZXRTdGF0ZSgpLnJlbmFtaW5nSXRlbVxuICB9LFxuICBpdGVtSW5zdGFuY2U6IHtcbiAgICBzdGFydFJlbmFtaW5nOiAoeyB0cmVlLCBpdGVtLCBpdGVtSWQgfSkgPT4ge1xuICAgICAgaWYgKCFpdGVtLmNhblJlbmFtZSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyZWUuYXBwbHlTdWJTdGF0ZVVwZGF0ZShcInJlbmFtaW5nSXRlbVwiLCBpdGVtSWQpO1xuICAgICAgdHJlZS5hcHBseVN1YlN0YXRlVXBkYXRlKFwicmVuYW1pbmdWYWx1ZVwiLCBpdGVtLmdldEl0ZW1OYW1lKCkpO1xuICAgIH0sXG4gICAgZ2V0UmVuYW1lSW5wdXRQcm9wczogKHsgdHJlZSB9KSA9PiAoe1xuICAgICAgcmVmOiAocikgPT4gciA9PSBudWxsID8gdm9pZCAwIDogci5mb2N1cygpLFxuICAgICAgb25CbHVyOiAoKSA9PiB0cmVlLmFib3J0UmVuYW1pbmcoKSxcbiAgICAgIHZhbHVlOiB0cmVlLmdldFJlbmFtaW5nVmFsdWUoKSxcbiAgICAgIG9uQ2hhbmdlOiAoZSkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRyZWUuYXBwbHlTdWJTdGF0ZVVwZGF0ZShcInJlbmFtaW5nVmFsdWVcIiwgKF9hID0gZS50YXJnZXQpID09IG51bGwgPyB2b2lkIDAgOiBfYS52YWx1ZSk7XG4gICAgICB9XG4gICAgfSksXG4gICAgY2FuUmVuYW1lOiAoeyB0cmVlLCBpdGVtIH0pID0+IHtcbiAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgcmV0dXJuIChfYyA9IChfYiA9IChfYSA9IHRyZWUuZ2V0Q29uZmlnKCkpLmNhblJlbmFtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGl0ZW0pKSAhPSBudWxsID8gX2MgOiB0cnVlO1xuICAgIH0sXG4gICAgaXNSZW5hbWluZzogKHsgdHJlZSwgaXRlbSB9KSA9PiBpdGVtLmdldElkKCkgPT09IHRyZWUuZ2V0U3RhdGUoKS5yZW5hbWluZ0l0ZW0sXG4gICAgZ2V0UHJvcHM6ICh7IHByZXYsIGl0ZW0gfSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgaXNSZW5hbWluZyA9IGl0ZW0uaXNSZW5hbWluZygpO1xuICAgICAgY29uc3QgcHJldlByb3BzID0gKF9hID0gcHJldiA9PSBudWxsID8gdm9pZCAwIDogcHJldigpKSAhPSBudWxsID8gX2EgOiB7fTtcbiAgICAgIHJldHVybiBpc1JlbmFtaW5nID8gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgcHJldlByb3BzKSwge1xuICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxuICAgICAgICBvbkRyYWdTdGFydDogKCkgPT4ge1xuICAgICAgICB9XG4gICAgICB9KSA6IHByZXZQcm9wcztcbiAgICB9XG4gIH0sXG4gIGhvdGtleXM6IHtcbiAgICByZW5hbWVJdGVtOiB7XG4gICAgICBob3RrZXk6IFwiRjJcIixcbiAgICAgIGhhbmRsZXI6IChlLCB0cmVlKSA9PiB7XG4gICAgICAgIHRyZWUuZ2V0Rm9jdXNlZEl0ZW0oKS5zdGFydFJlbmFtaW5nKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBhYm9ydFJlbmFtaW5nOiB7XG4gICAgICBob3RrZXk6IFwiRXNjYXBlXCIsXG4gICAgICBhbGxvd1doZW5JbnB1dEZvY3VzZWQ6IHRydWUsXG4gICAgICBpc0VuYWJsZWQ6ICh0cmVlKSA9PiB0cmVlLmlzUmVuYW1pbmdJdGVtKCksXG4gICAgICBoYW5kbGVyOiAoZSwgdHJlZSkgPT4ge1xuICAgICAgICB0cmVlLmFib3J0UmVuYW1pbmcoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbXBsZXRlUmVuYW1pbmc6IHtcbiAgICAgIGhvdGtleTogXCJFbnRlclwiLFxuICAgICAgYWxsb3dXaGVuSW5wdXRGb2N1c2VkOiB0cnVlLFxuICAgICAgaXNFbmFibGVkOiAodHJlZSkgPT4gdHJlZS5pc1JlbmFtaW5nSXRlbSgpLFxuICAgICAgaGFuZGxlcjogKGUsIHRyZWUpID0+IHtcbiAgICAgICAgdHJlZS5jb21wbGV0ZVJlbmFtaW5nKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZmVhdHVyZXMvZXhwYW5kLWFsbC9mZWF0dXJlLnRzXG52YXIgZXhwYW5kQWxsRmVhdHVyZSA9IHtcbiAga2V5OiBcImV4cGFuZC1hbGxcIixcbiAgdHJlZUluc3RhbmNlOiB7XG4gICAgZXhwYW5kQWxsOiAoXzAsIF8xKSA9PiBfX2FzeW5jKG51bGwsIFtfMCwgXzFdLCBmdW5jdGlvbiogKHsgdHJlZSB9LCBjYW5jZWxUb2tlbikge1xuICAgICAgeWllbGQgUHJvbWlzZS5hbGwoXG4gICAgICAgIHRyZWUuZ2V0SXRlbXMoKS5tYXAoKGl0ZW0pID0+IGl0ZW0uZXhwYW5kQWxsKGNhbmNlbFRva2VuKSlcbiAgICAgICk7XG4gICAgfSksXG4gICAgY29sbGFwc2VBbGw6ICh7IHRyZWUgfSkgPT4ge1xuICAgICAgdHJlZS5hcHBseVN1YlN0YXRlVXBkYXRlKFwiZXhwYW5kZWRJdGVtc1wiLCBbXSk7XG4gICAgICB0cmVlLnJlYnVpbGRUcmVlKCk7XG4gICAgfVxuICB9LFxuICBpdGVtSW5zdGFuY2U6IHtcbiAgICBleHBhbmRBbGw6IChfMCwgXzEpID0+IF9fYXN5bmMobnVsbCwgW18wLCBfMV0sIGZ1bmN0aW9uKiAoeyB0cmVlLCBpdGVtIH0sIGNhbmNlbFRva2VuKSB7XG4gICAgICBpZiAoY2FuY2VsVG9rZW4gPT0gbnVsbCA/IHZvaWQgMCA6IGNhbmNlbFRva2VuLmN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFpdGVtLmlzRm9sZGVyKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaXRlbS5leHBhbmQoKTtcbiAgICAgIHlpZWxkIHRyZWUud2FpdEZvckl0ZW1DaGlsZHJlbkxvYWRlZChpdGVtLmdldElkKCkpO1xuICAgICAgeWllbGQgUHJvbWlzZS5hbGwoXG4gICAgICAgIGl0ZW0uZ2V0Q2hpbGRyZW4oKS5tYXAoKGNoaWxkKSA9PiBfX2FzeW5jKG51bGwsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgeWllbGQgdHJlZS53YWl0Rm9ySXRlbUNoaWxkcmVuTG9hZGVkKGl0ZW0uZ2V0SWQoKSk7XG4gICAgICAgICAgeWllbGQgY2hpbGQgPT0gbnVsbCA/IHZvaWQgMCA6IGNoaWxkLmV4cGFuZEFsbChjYW5jZWxUb2tlbik7XG4gICAgICAgIH0pKVxuICAgICAgKTtcbiAgICB9KSxcbiAgICBjb2xsYXBzZUFsbDogKHsgaXRlbSB9KSA9PiB7XG4gICAgICBpZiAoIWl0ZW0uaXNFeHBhbmRlZCgpKSByZXR1cm47XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGl0ZW0uZ2V0Q2hpbGRyZW4oKSkge1xuICAgICAgICBjaGlsZCA9PSBudWxsID8gdm9pZCAwIDogY2hpbGQuY29sbGFwc2VBbGwoKTtcbiAgICAgIH1cbiAgICAgIGl0ZW0uY29sbGFwc2UoKTtcbiAgICB9XG4gIH0sXG4gIGhvdGtleXM6IHtcbiAgICBleHBhbmRTZWxlY3RlZDoge1xuICAgICAgaG90a2V5OiBcIkNvbnRyb2wrU2hpZnQrUGx1c1wiLFxuICAgICAgaGFuZGxlcjogKF8sIHRyZWUpID0+IF9fYXN5bmMobnVsbCwgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgY2FuY2VsVG9rZW4gPSB7IGN1cnJlbnQ6IGZhbHNlIH07XG4gICAgICAgIGNvbnN0IGNhbmNlbEhhbmRsZXIgPSAoZSkgPT4ge1xuICAgICAgICAgIGlmIChlLmNvZGUgPT09IFwiRXNjYXBlXCIpIHtcbiAgICAgICAgICAgIGNhbmNlbFRva2VuLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgY2FuY2VsSGFuZGxlcik7XG4gICAgICAgIHlpZWxkIFByb21pc2UuYWxsKFxuICAgICAgICAgIHRyZWUuZ2V0U2VsZWN0ZWRJdGVtcygpLm1hcCgoaXRlbSkgPT4gaXRlbS5leHBhbmRBbGwoY2FuY2VsVG9rZW4pKVxuICAgICAgICApO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBjYW5jZWxIYW5kbGVyKTtcbiAgICAgIH0pXG4gICAgfSxcbiAgICBjb2xsYXBzZVNlbGVjdGVkOiB7XG4gICAgICBob3RrZXk6IFwiQ29udHJvbCtTaGlmdCtNaW51c1wiLFxuICAgICAgaGFuZGxlcjogKF8sIHRyZWUpID0+IHtcbiAgICAgICAgdHJlZS5nZXRTZWxlY3RlZEl0ZW1zKCkuZm9yRWFjaCgoaXRlbSkgPT4gaXRlbS5jb2xsYXBzZUFsbCgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9mZWF0dXJlcy9wcm9wLW1lbW9pemF0aW9uL2ZlYXR1cmUudHNcbnZhciBtZW1vaXplID0gKHByb3BzLCBtZW1vaXplZFByb3BzKSA9PiB7XG4gIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wc1trZXldID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGlmIChtZW1vaXplZFByb3BzICYmIGtleSBpbiBtZW1vaXplZFByb3BzKSB7XG4gICAgICAgIHByb3BzW2tleV0gPSBtZW1vaXplZFByb3BzW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZW1vaXplZFByb3BzW2tleV0gPSBwcm9wc1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvcHM7XG59O1xudmFyIHByb3BNZW1vaXphdGlvbkZlYXR1cmUgPSB7XG4gIGtleTogXCJwcm9wLW1lbW9pemF0aW9uXCIsXG4gIG92ZXJ3cml0ZXM6IFtcbiAgICBcIm1haW5cIixcbiAgICBcImFzeW5jLWRhdGEtbG9hZGVyXCIsXG4gICAgXCJzeW5jLWRhdGEtbG9hZGVyXCIsXG4gICAgXCJkcmFnLWFuZC1kcm9wXCIsXG4gICAgXCJleHBhbmQtYWxsXCIsXG4gICAgXCJob3RrZXlzLWNvcmVcIixcbiAgICBcInJlbmFtaW5nXCIsXG4gICAgXCJzZWFyY2hcIixcbiAgICBcInNlbGVjdGlvblwiXG4gIF0sXG4gIHRyZWVJbnN0YW5jZToge1xuICAgIGdldENvbnRhaW5lclByb3BzOiAoeyB0cmVlLCBwcmV2IH0sIHRyZWVMYWJlbCkgPT4ge1xuICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgIGNvbnN0IGRhdGFSZWYgPSB0cmVlLmdldERhdGFSZWYoKTtcbiAgICAgIGNvbnN0IHByb3BzID0gKF9hID0gcHJldiA9PSBudWxsID8gdm9pZCAwIDogcHJldih0cmVlTGFiZWwpKSAhPSBudWxsID8gX2EgOiB7fTtcbiAgICAgIChfYyA9IChfYiA9IGRhdGFSZWYuY3VycmVudCkubWVtbykgIT0gbnVsbCA/IF9jIDogX2IubWVtbyA9IHt9O1xuICAgICAgKF9lID0gKF9kID0gZGF0YVJlZi5jdXJyZW50Lm1lbW8pLnRyZWUpICE9IG51bGwgPyBfZSA6IF9kLnRyZWUgPSB7fTtcbiAgICAgIHJldHVybiBtZW1vaXplKHByb3BzLCBkYXRhUmVmLmN1cnJlbnQubWVtby50cmVlKTtcbiAgICB9LFxuICAgIGdldFNlYXJjaElucHV0RWxlbWVudFByb3BzOiAoeyB0cmVlLCBwcmV2IH0pID0+IHtcbiAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICBjb25zdCBkYXRhUmVmID0gdHJlZS5nZXREYXRhUmVmKCk7XG4gICAgICBjb25zdCBwcm9wcyA9IChfYSA9IHByZXYgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXYoKSkgIT0gbnVsbCA/IF9hIDoge307XG4gICAgICAoX2MgPSAoX2IgPSBkYXRhUmVmLmN1cnJlbnQpLm1lbW8pICE9IG51bGwgPyBfYyA6IF9iLm1lbW8gPSB7fTtcbiAgICAgIChfZSA9IChfZCA9IGRhdGFSZWYuY3VycmVudC5tZW1vKS5zZWFyY2gpICE9IG51bGwgPyBfZSA6IF9kLnNlYXJjaCA9IHt9O1xuICAgICAgcmV0dXJuIG1lbW9pemUocHJvcHMsIGRhdGFSZWYuY3VycmVudC5tZW1vLnNlYXJjaCk7XG4gICAgfVxuICB9LFxuICBpdGVtSW5zdGFuY2U6IHtcbiAgICBnZXRQcm9wczogKHsgaXRlbSwgcHJldiB9KSA9PiB7XG4gICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgY29uc3QgZGF0YVJlZiA9IGl0ZW0uZ2V0RGF0YVJlZigpO1xuICAgICAgY29uc3QgcHJvcHMgPSAoX2EgPSBwcmV2ID09IG51bGwgPyB2b2lkIDAgOiBwcmV2KCkpICE9IG51bGwgPyBfYSA6IHt9O1xuICAgICAgKF9jID0gKF9iID0gZGF0YVJlZi5jdXJyZW50KS5tZW1vKSAhPSBudWxsID8gX2MgOiBfYi5tZW1vID0ge307XG4gICAgICAoX2UgPSAoX2QgPSBkYXRhUmVmLmN1cnJlbnQubWVtbykuaXRlbSkgIT0gbnVsbCA/IF9lIDogX2QuaXRlbSA9IHt9O1xuICAgICAgcmV0dXJuIG1lbW9pemUocHJvcHMsIGRhdGFSZWYuY3VycmVudC5tZW1vLml0ZW0pO1xuICAgIH0sXG4gICAgZ2V0UmVuYW1lSW5wdXRQcm9wczogKHsgaXRlbSwgcHJldiB9KSA9PiB7XG4gICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgY29uc3QgZGF0YVJlZiA9IGl0ZW0uZ2V0RGF0YVJlZigpO1xuICAgICAgY29uc3QgcHJvcHMgPSAoX2EgPSBwcmV2ID09IG51bGwgPyB2b2lkIDAgOiBwcmV2KCkpICE9IG51bGwgPyBfYSA6IHt9O1xuICAgICAgKF9jID0gKF9iID0gZGF0YVJlZi5jdXJyZW50KS5tZW1vKSAhPSBudWxsID8gX2MgOiBfYi5tZW1vID0ge307XG4gICAgICAoX2UgPSAoX2QgPSBkYXRhUmVmLmN1cnJlbnQubWVtbykucmVuYW1lKSAhPSBudWxsID8gX2UgOiBfZC5yZW5hbWUgPSB7fTtcbiAgICAgIHJldHVybiBtZW1vaXplKHByb3BzLCBkYXRhUmVmLmN1cnJlbnQubWVtby5yZW5hbWUpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3V0aWxpdGllcy9yZW1vdmUtaXRlbXMtZnJvbS1wYXJlbnRzLnRzXG52YXIgcmVtb3ZlSXRlbXNGcm9tUGFyZW50cyA9IChtb3ZlZEl0ZW1zLCBvbkNoYW5nZUNoaWxkcmVuKSA9PiBfX2FzeW5jKG51bGwsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gIGNvbnN0IG1vdmVkSXRlbXNJZHMgPSBtb3ZlZEl0ZW1zLm1hcCgoaXRlbSkgPT4gaXRlbS5nZXRJZCgpKTtcbiAgY29uc3QgdW5pcXVlUGFyZW50cyA9IFtcbiAgICAuLi5uZXcgU2V0KG1vdmVkSXRlbXMubWFwKChpdGVtKSA9PiBpdGVtLmdldFBhcmVudCgpKSlcbiAgXTtcbiAgZm9yIChjb25zdCBwYXJlbnQgb2YgdW5pcXVlUGFyZW50cykge1xuICAgIGNvbnN0IHNpYmxpbmdzID0gcGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwYXJlbnQuZ2V0Q2hpbGRyZW4oKTtcbiAgICBpZiAoc2libGluZ3MgJiYgcGFyZW50KSB7XG4gICAgICBjb25zdCBuZXdDaGlsZHJlbiA9IHNpYmxpbmdzLmZpbHRlcigoc2libGluZykgPT4gIW1vdmVkSXRlbXNJZHMuaW5jbHVkZXMoc2libGluZy5nZXRJZCgpKSkubWFwKChpKSA9PiBpLmdldElkKCkpO1xuICAgICAgeWllbGQgb25DaGFuZ2VDaGlsZHJlbihwYXJlbnQsIG5ld0NoaWxkcmVuKTtcbiAgICAgIGlmIChwYXJlbnQgJiYgXCJ1cGRhdGVDYWNoZWRDaGlsZHJlbklkc1wiIGluIHBhcmVudCkge1xuICAgICAgICBwYXJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmVudC51cGRhdGVDYWNoZWRDaGlsZHJlbklkcyhuZXdDaGlsZHJlbik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG1vdmVkSXRlbXNbMF0uZ2V0VHJlZSgpLnJlYnVpbGRUcmVlKCk7XG59KTtcblxuLy8gc3JjL3V0aWxpdGllcy9pbnNlcnQtaXRlbXMtYXQtdGFyZ2V0LnRzXG52YXIgaW5zZXJ0SXRlbXNBdFRhcmdldCA9IChpdGVtSWRzLCB0YXJnZXQsIG9uQ2hhbmdlQ2hpbGRyZW4pID0+IF9fYXN5bmMobnVsbCwgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgeWllbGQgdGFyZ2V0Lml0ZW0uZ2V0VHJlZSgpLndhaXRGb3JJdGVtQ2hpbGRyZW5Mb2FkZWQodGFyZ2V0Lml0ZW0uZ2V0SWQoKSk7XG4gIGNvbnN0IG9sZENoaWxkcmVuSWRzID0gdGFyZ2V0Lml0ZW0uZ2V0VHJlZSgpLnJldHJpZXZlQ2hpbGRyZW5JZHModGFyZ2V0Lml0ZW0uZ2V0SWQoKSk7XG4gIGlmICghKFwiY2hpbGRJbmRleFwiIGluIHRhcmdldCkpIHtcbiAgICBjb25zdCBuZXdDaGlsZHJlbjIgPSBbLi4ub2xkQ2hpbGRyZW5JZHMsIC4uLml0ZW1JZHNdO1xuICAgIHlpZWxkIG9uQ2hhbmdlQ2hpbGRyZW4odGFyZ2V0Lml0ZW0sIG5ld0NoaWxkcmVuMik7XG4gICAgaWYgKHRhcmdldC5pdGVtICYmIFwidXBkYXRlQ2FjaGVkQ2hpbGRyZW5JZHNcIiBpbiB0YXJnZXQuaXRlbSkge1xuICAgICAgdGFyZ2V0Lml0ZW0udXBkYXRlQ2FjaGVkQ2hpbGRyZW5JZHMobmV3Q2hpbGRyZW4yKTtcbiAgICB9XG4gICAgdGFyZ2V0Lml0ZW0uZ2V0VHJlZSgpLnJlYnVpbGRUcmVlKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG5ld0NoaWxkcmVuID0gW1xuICAgIC4uLm9sZENoaWxkcmVuSWRzLnNsaWNlKDAsIHRhcmdldC5pbnNlcnRpb25JbmRleCksXG4gICAgLi4uaXRlbUlkcyxcbiAgICAuLi5vbGRDaGlsZHJlbklkcy5zbGljZSh0YXJnZXQuaW5zZXJ0aW9uSW5kZXgpXG4gIF07XG4gIHlpZWxkIG9uQ2hhbmdlQ2hpbGRyZW4odGFyZ2V0Lml0ZW0sIG5ld0NoaWxkcmVuKTtcbiAgaWYgKHRhcmdldC5pdGVtICYmIFwidXBkYXRlQ2FjaGVkQ2hpbGRyZW5JZHNcIiBpbiB0YXJnZXQuaXRlbSkge1xuICAgIHRhcmdldC5pdGVtLnVwZGF0ZUNhY2hlZENoaWxkcmVuSWRzKG5ld0NoaWxkcmVuKTtcbiAgfVxuICB0YXJnZXQuaXRlbS5nZXRUcmVlKCkucmVidWlsZFRyZWUoKTtcbn0pO1xuXG4vLyBzcmMvdXRpbGl0aWVzL2NyZWF0ZS1vbi1kcm9wLWhhbmRsZXIudHNcbnZhciBjcmVhdGVPbkRyb3BIYW5kbGVyID0gKG9uQ2hhbmdlQ2hpbGRyZW4pID0+IChpdGVtcywgdGFyZ2V0KSA9PiBfX2FzeW5jKG51bGwsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gIGNvbnN0IGl0ZW1JZHMgPSBpdGVtcy5tYXAoKGl0ZW0pID0+IGl0ZW0uZ2V0SWQoKSk7XG4gIHlpZWxkIHJlbW92ZUl0ZW1zRnJvbVBhcmVudHMoaXRlbXMsIG9uQ2hhbmdlQ2hpbGRyZW4pO1xuICB5aWVsZCBpbnNlcnRJdGVtc0F0VGFyZ2V0KGl0ZW1JZHMsIHRhcmdldCwgb25DaGFuZ2VDaGlsZHJlbik7XG59KTtcblxuLy8gc3JjL2NvcmUvYnVpbGQtcHJveGlmaWVkLWluc3RhbmNlLnRzXG52YXIgbm9vcCA9ICgpID0+IHtcbn07XG52YXIgZmluZFByZXZJbnN0YW5jZU1ldGhvZCA9IChmZWF0dXJlcywgaW5zdGFuY2VUeXBlLCBtZXRob2RLZXksIGZlYXR1cmVTZWFyY2hJbmRleCkgPT4ge1xuICB2YXIgX2E7XG4gIGZvciAobGV0IGkgPSBmZWF0dXJlU2VhcmNoSW5kZXg7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3QgZmVhdHVyZSA9IGZlYXR1cmVzW2ldO1xuICAgIGNvbnN0IGl0ZW1JbnN0YW5jZU1ldGhvZCA9IChfYSA9IGZlYXR1cmVbaW5zdGFuY2VUeXBlXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hW21ldGhvZEtleV07XG4gICAgaWYgKGl0ZW1JbnN0YW5jZU1ldGhvZCkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcbnZhciBpbnZva2VJbnN0YW5jZU1ldGhvZCA9IChmZWF0dXJlcywgaW5zdGFuY2VUeXBlLCBvcHRzLCBtZXRob2RLZXksIGZlYXR1cmVJbmRleCwgYXJncykgPT4ge1xuICB2YXIgX2E7XG4gIGNvbnN0IHByZXZJbmRleCA9IGZpbmRQcmV2SW5zdGFuY2VNZXRob2QoXG4gICAgZmVhdHVyZXMsXG4gICAgaW5zdGFuY2VUeXBlLFxuICAgIG1ldGhvZEtleSxcbiAgICBmZWF0dXJlSW5kZXggLSAxXG4gICk7XG4gIGNvbnN0IGl0ZW1JbnN0YW5jZU1ldGhvZCA9IChfYSA9IGZlYXR1cmVzW2ZlYXR1cmVJbmRleF1baW5zdGFuY2VUeXBlXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hW21ldGhvZEtleV07XG4gIHJldHVybiBpdGVtSW5zdGFuY2VNZXRob2QoXG4gICAgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0cyksIHtcbiAgICAgIHByZXY6IHByZXZJbmRleCAhPT0gbnVsbCA/ICguLi5uZXdBcmdzKSA9PiBpbnZva2VJbnN0YW5jZU1ldGhvZChcbiAgICAgICAgZmVhdHVyZXMsXG4gICAgICAgIGluc3RhbmNlVHlwZSxcbiAgICAgICAgb3B0cyxcbiAgICAgICAgbWV0aG9kS2V5LFxuICAgICAgICBwcmV2SW5kZXgsXG4gICAgICAgIG5ld0FyZ3NcbiAgICAgICkgOiBudWxsXG4gICAgfSksXG4gICAgLi4uYXJnc1xuICApO1xufTtcbnZhciBidWlsZFByb3hpZWRJbnN0YW5jZSA9IChmZWF0dXJlcywgaW5zdGFuY2VUeXBlLCBidWlsZE9wdHMpID0+IHtcbiAgY29uc3Qgb3B0cyA9IHt9O1xuICBjb25zdCBpdGVtID0gbmV3IFByb3h5KFxuICAgIHt9LFxuICAgIHtcbiAgICAgIGhhcyh0YXJnZXQsIGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ID09PSBcInRvSlNPTlwiKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc0luc3RhbmNlTWV0aG9kID0gZmluZFByZXZJbnN0YW5jZU1ldGhvZChcbiAgICAgICAgICBmZWF0dXJlcyxcbiAgICAgICAgICBpbnN0YW5jZVR5cGUsXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGZlYXR1cmVzLmxlbmd0aCAtIDFcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oaGFzSW5zdGFuY2VNZXRob2QpO1xuICAgICAgfSxcbiAgICAgIGdldCh0YXJnZXQsIGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleSA9PT0gXCJ0b0pTT05cIikge1xuICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICBjb25zdCBmZWF0dXJlSW5kZXggPSBmaW5kUHJldkluc3RhbmNlTWV0aG9kKFxuICAgICAgICAgICAgZmVhdHVyZXMsXG4gICAgICAgICAgICBpbnN0YW5jZVR5cGUsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBmZWF0dXJlcy5sZW5ndGggLSAxXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoZmVhdHVyZUluZGV4ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyB0aHJvd0Vycm9yKGBmZWF0dXJlIG1pc3NpbmcgZm9yIG1ldGhvZCAke2tleX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGludm9rZUluc3RhbmNlTWV0aG9kKFxuICAgICAgICAgICAgZmVhdHVyZXMsXG4gICAgICAgICAgICBpbnN0YW5jZVR5cGUsXG4gICAgICAgICAgICBvcHRzLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZmVhdHVyZUluZGV4LFxuICAgICAgICAgICAgYXJnc1xuICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICApO1xuICBPYmplY3QuYXNzaWduKG9wdHMsIGJ1aWxkT3B0cyhpdGVtKSk7XG4gIHJldHVybiBbaXRlbSwgbm9vcF07XG59O1xuZXhwb3J0IHtcbiAgQXNzaXN0aXZlRG5kU3RhdGUsXG4gIENoZWNrZWRTdGF0ZSxcbiAgRHJhZ1RhcmdldFBvc2l0aW9uLFxuICBhc3luY0RhdGFMb2FkZXJGZWF0dXJlLFxuICBidWlsZFByb3hpZWRJbnN0YW5jZSxcbiAgYnVpbGRTdGF0aWNJbnN0YW5jZSxcbiAgY2hlY2tib3hlc0ZlYXR1cmUsXG4gIGNyZWF0ZU9uRHJvcEhhbmRsZXIsXG4gIGNyZWF0ZVRyZWUsXG4gIGRyYWdBbmREcm9wRmVhdHVyZSxcbiAgZXhwYW5kQWxsRmVhdHVyZSxcbiAgaG90a2V5c0NvcmVGZWF0dXJlLFxuICBpbnNlcnRJdGVtc0F0VGFyZ2V0LFxuICBpc09yZGVyZWREcmFnVGFyZ2V0LFxuICBrZXlib2FyZERyYWdBbmREcm9wRmVhdHVyZSxcbiAgbWFrZVN0YXRlVXBkYXRlcixcbiAgcHJvcE1lbW9pemF0aW9uRmVhdHVyZSxcbiAgcmVtb3ZlSXRlbXNGcm9tUGFyZW50cyxcbiAgcmVuYW1pbmdGZWF0dXJlLFxuICBzZWFyY2hGZWF0dXJlLFxuICBzZWxlY3Rpb25GZWF0dXJlLFxuICBzeW5jRGF0YUxvYWRlckZlYXR1cmVcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@headless-tree/core/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@headless-tree/react/dist/chunk-FWCSY2DS.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@headless-tree/react/dist/chunk-FWCSY2DS.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __objRest: () => (/* binding */ __objRest),\n/* harmony export */   __spreadProps: () => (/* binding */ __spreadProps),\n/* harmony export */   __spreadValues: () => (/* binding */ __spreadValues)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AaGVhZGxlc3MtdHJlZS9yZWFjdC9kaXN0L2NodW5rLUZXQ1NZMkRTLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQU1FIiwic291cmNlcyI6WyIvVXNlcnMvdGVyZWNhbC91aS1pbnRlcmFjaXR2ZS1sZXYxL215LWFkbWluLXByb2plY3QvdWktZXhhbXBsZS1mcm9udC9ub2RlX21vZHVsZXMvQGhlYWRsZXNzLXRyZWUvcmVhY3QvZGlzdC9jaHVuay1GV0NTWTJEUy5tanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG52YXIgX19vYmpSZXN0ID0gKHNvdXJjZSwgZXhjbHVkZSkgPT4ge1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIGZvciAodmFyIHByb3AgaW4gc291cmNlKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChzb3VyY2UsIHByb3ApICYmIGV4Y2x1ZGUuaW5kZXhPZihwcm9wKSA8IDApXG4gICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gIGlmIChzb3VyY2UgIT0gbnVsbCAmJiBfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhzb3VyY2UpKSB7XG4gICAgICBpZiAoZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMCAmJiBfX3Byb3BJc0VudW0uY2FsbChzb3VyY2UsIHByb3ApKVxuICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuZXhwb3J0IHtcbiAgX19zcHJlYWRWYWx1ZXMsXG4gIF9fc3ByZWFkUHJvcHMsXG4gIF9fb2JqUmVzdFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@headless-tree/react/dist/chunk-FWCSY2DS.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@headless-tree/react/dist/index.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@headless-tree/react/dist/index.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AssistiveTreeDescription: () => (/* binding */ AssistiveTreeDescription),\n/* harmony export */   useTree: () => (/* binding */ useTree)\n/* harmony export */ });\n/* harmony import */ var _chunk_FWCSY2DS_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-FWCSY2DS.mjs */ \"(app-pages-browser)/./node_modules/@headless-tree/react/dist/chunk-FWCSY2DS.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _headless_tree_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @headless-tree/core */ \"(app-pages-browser)/./node_modules/@headless-tree/core/dist/index.mjs\");\n\n\n// src/assistive-tree-description.tsx\n\n\nvar styles = {\n  position: \"absolute\",\n  margin: \"-1px\",\n  width: \"1px\",\n  height: \"1px\",\n  overflow: \"hidden\",\n  clip: \"rect(0 0 0 0)\"\n};\nvar getDefaultLabel = (dnd, assistiveState, hotkeys) => {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n  if (!hotkeys.startDrag) return \"\";\n  const itemNames = (_b = (_a = dnd == null ? void 0 : dnd.draggedItems) == null ? void 0 : _a.map((item) => item.getItemName()).join(\", \")) != null ? _b : \"\";\n  const position = !(dnd == null ? void 0 : dnd.dragTarget) ? \"None\" : \"childIndex\" in dnd.dragTarget ? `${dnd.dragTarget.childIndex} of ${dnd.dragTarget.item.getChildren().length} in ${dnd.dragTarget.item.getItemName()}` : `in ${dnd.dragTarget.item.getItemName()}`;\n  const navGuide = `Press ${(_c = hotkeys.dragUp) == null ? void 0 : _c.hotkey} and ${(_d = hotkeys.dragDown) == null ? void 0 : _d.hotkey} to move up or down, ${(_e = hotkeys.completeDrag) == null ? void 0 : _e.hotkey} to drop, ${(_f = hotkeys.cancelDrag) == null ? void 0 : _f.hotkey} to abort.`;\n  switch (assistiveState) {\n    case _headless_tree_core__WEBPACK_IMPORTED_MODULE_1__.AssistiveDndState.Started:\n      return itemNames ? `Dragging ${itemNames}. Current position: ${position}. ${navGuide}` : `Current position: ${position}. ${navGuide}`;\n    case _headless_tree_core__WEBPACK_IMPORTED_MODULE_1__.AssistiveDndState.Dragging:\n      return itemNames ? `${itemNames}, ${position}` : position;\n    case _headless_tree_core__WEBPACK_IMPORTED_MODULE_1__.AssistiveDndState.Completed:\n      return `Drag completed. Press ${(_g = hotkeys.startDrag) == null ? void 0 : _g.hotkey} to move selected items`;\n    case _headless_tree_core__WEBPACK_IMPORTED_MODULE_1__.AssistiveDndState.Aborted:\n      return `Drag cancelled. Press ${(_h = hotkeys.startDrag) == null ? void 0 : _h.hotkey} to move selected items`;\n    case _headless_tree_core__WEBPACK_IMPORTED_MODULE_1__.AssistiveDndState.None:\n    default:\n      return `Press ${(_i = hotkeys.startDrag) == null ? void 0 : _i.hotkey} to move selected items`;\n  }\n};\nvar AssistiveTreeDescription = (_a) => {\n  var _b = _a, {\n    tree,\n    getLabel = getDefaultLabel\n  } = _b, props = (0,_chunk_FWCSY2DS_mjs__WEBPACK_IMPORTED_MODULE_2__.__objRest)(_b, [\n    \"tree\",\n    \"getLabel\"\n  ]);\n  var _a2;\n  const state = tree.getState();\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    \"span\",\n    (0,_chunk_FWCSY2DS_mjs__WEBPACK_IMPORTED_MODULE_2__.__spreadProps)((0,_chunk_FWCSY2DS_mjs__WEBPACK_IMPORTED_MODULE_2__.__spreadValues)({\n      \"aria-live\": \"assertive\"\n    }, props), {\n      style: (0,_chunk_FWCSY2DS_mjs__WEBPACK_IMPORTED_MODULE_2__.__spreadValues)((0,_chunk_FWCSY2DS_mjs__WEBPACK_IMPORTED_MODULE_2__.__spreadValues)({}, styles), props.style)\n    }),\n    getLabel(\n      state.dnd,\n      (_a2 = state.assistiveDndState) != null ? _a2 : _headless_tree_core__WEBPACK_IMPORTED_MODULE_1__.AssistiveDndState.None,\n      tree.getHotkeyPresets()\n    )\n  );\n};\n\n// src/use-tree.tsx\n\n\nvar useApplyAfterMount = () => {\n  const isMounted = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  const callbacks = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    isMounted.current = true;\n    callbacks.current.forEach((callback) => callback());\n  }, []);\n  const apply = (callback) => {\n    if (isMounted.current) {\n      callback();\n    } else {\n      callbacks.current.push(callback);\n    }\n  };\n  return apply;\n};\nvar useTree = (config) => {\n  const apply = useApplyAfterMount();\n  const [tree] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => ({ current: (0,_headless_tree_core__WEBPACK_IMPORTED_MODULE_1__.createTree)(config) }));\n  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n    () => tree.current.getState()\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    tree.current.rebuildTree();\n  }, [tree]);\n  tree.current.setConfig((prev) => (0,_chunk_FWCSY2DS_mjs__WEBPACK_IMPORTED_MODULE_2__.__spreadProps)((0,_chunk_FWCSY2DS_mjs__WEBPACK_IMPORTED_MODULE_2__.__spreadValues)((0,_chunk_FWCSY2DS_mjs__WEBPACK_IMPORTED_MODULE_2__.__spreadValues)({}, prev), config), {\n    state: (0,_chunk_FWCSY2DS_mjs__WEBPACK_IMPORTED_MODULE_2__.__spreadValues)((0,_chunk_FWCSY2DS_mjs__WEBPACK_IMPORTED_MODULE_2__.__spreadValues)({}, state), config.state),\n    setState: (state2) => {\n      apply(() => {\n        var _a;\n        setState(state2);\n        (_a = config.setState) == null ? void 0 : _a.call(config, state2);\n      });\n    }\n  }));\n  return tree.current;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AaGVhZGxlc3MtdHJlZS9yZWFjdC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUk4Qjs7QUFFOUI7QUFDMEI7QUFHRztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMkcsMkJBQTJCLEtBQUssMENBQTBDLEtBQUssa0NBQWtDLFVBQVUsa0NBQWtDO0FBQ3hRLDRCQUE0QixvREFBb0QsTUFBTSxzREFBc0Qsc0JBQXNCLDBEQUEwRCxXQUFXLHdEQUF3RDtBQUMvUjtBQUNBLFNBQVMsa0VBQWlCO0FBQzFCLHFDQUFxQyxVQUFVLHNCQUFzQixTQUFTLElBQUksU0FBUyx5QkFBeUIsU0FBUyxJQUFJLFNBQVM7QUFDMUksU0FBUyxrRUFBaUI7QUFDMUIsNEJBQTRCLFVBQVUsSUFBSSxTQUFTO0FBQ25ELFNBQVMsa0VBQWlCO0FBQzFCLHNDQUFzQyx1REFBdUQ7QUFDN0YsU0FBUyxrRUFBaUI7QUFDMUIsc0NBQXNDLHVEQUF1RDtBQUM3RixTQUFTLGtFQUFpQjtBQUMxQjtBQUNBLHNCQUFzQix1REFBdUQ7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxjQUFjLDhEQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0RBQW1CO0FBQzVDO0FBQ0EsSUFBSSxrRUFBYSxDQUFDLG1FQUFjO0FBQ2hDO0FBQ0EsS0FBSztBQUNMLGFBQWEsbUVBQWMsQ0FBQyxtRUFBYyxHQUFHO0FBQzdDLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0RBQXNELGtFQUFpQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNvRDtBQUNIO0FBQ2pEO0FBQ0Esb0JBQW9CLDZDQUFNO0FBQzFCLG9CQUFvQiw2Q0FBTTtBQUMxQixFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0NBQVEsVUFBVSxTQUFTLCtEQUFVLFVBQVU7QUFDaEUsNEJBQTRCLCtDQUFRO0FBQ3BDO0FBQ0E7QUFDQSxFQUFFLGdEQUFTO0FBQ1g7QUFDQSxHQUFHO0FBQ0gsbUNBQW1DLGtFQUFhLENBQUMsbUVBQWMsQ0FBQyxtRUFBYyxHQUFHO0FBQ2pGLFdBQVcsbUVBQWMsQ0FBQyxtRUFBYyxHQUFHO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUlFIiwic291cmNlcyI6WyIvVXNlcnMvdGVyZWNhbC91aS1pbnRlcmFjaXR2ZS1sZXYxL215LWFkbWluLXByb2plY3QvdWktZXhhbXBsZS1mcm9udC9ub2RlX21vZHVsZXMvQGhlYWRsZXNzLXRyZWUvcmVhY3QvZGlzdC9pbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgX19vYmpSZXN0LFxuICBfX3NwcmVhZFByb3BzLFxuICBfX3NwcmVhZFZhbHVlc1xufSBmcm9tIFwiLi9jaHVuay1GV0NTWTJEUy5tanNcIjtcblxuLy8gc3JjL2Fzc2lzdGl2ZS10cmVlLWRlc2NyaXB0aW9uLnRzeFxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHtcbiAgQXNzaXN0aXZlRG5kU3RhdGVcbn0gZnJvbSBcIkBoZWFkbGVzcy10cmVlL2NvcmVcIjtcbnZhciBzdHlsZXMgPSB7XG4gIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gIG1hcmdpbjogXCItMXB4XCIsXG4gIHdpZHRoOiBcIjFweFwiLFxuICBoZWlnaHQ6IFwiMXB4XCIsXG4gIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICBjbGlwOiBcInJlY3QoMCAwIDAgMClcIlxufTtcbnZhciBnZXREZWZhdWx0TGFiZWwgPSAoZG5kLCBhc3Npc3RpdmVTdGF0ZSwgaG90a2V5cykgPT4ge1xuICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaTtcbiAgaWYgKCFob3RrZXlzLnN0YXJ0RHJhZykgcmV0dXJuIFwiXCI7XG4gIGNvbnN0IGl0ZW1OYW1lcyA9IChfYiA9IChfYSA9IGRuZCA9PSBudWxsID8gdm9pZCAwIDogZG5kLmRyYWdnZWRJdGVtcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm1hcCgoaXRlbSkgPT4gaXRlbS5nZXRJdGVtTmFtZSgpKS5qb2luKFwiLCBcIikpICE9IG51bGwgPyBfYiA6IFwiXCI7XG4gIGNvbnN0IHBvc2l0aW9uID0gIShkbmQgPT0gbnVsbCA/IHZvaWQgMCA6IGRuZC5kcmFnVGFyZ2V0KSA/IFwiTm9uZVwiIDogXCJjaGlsZEluZGV4XCIgaW4gZG5kLmRyYWdUYXJnZXQgPyBgJHtkbmQuZHJhZ1RhcmdldC5jaGlsZEluZGV4fSBvZiAke2RuZC5kcmFnVGFyZ2V0Lml0ZW0uZ2V0Q2hpbGRyZW4oKS5sZW5ndGh9IGluICR7ZG5kLmRyYWdUYXJnZXQuaXRlbS5nZXRJdGVtTmFtZSgpfWAgOiBgaW4gJHtkbmQuZHJhZ1RhcmdldC5pdGVtLmdldEl0ZW1OYW1lKCl9YDtcbiAgY29uc3QgbmF2R3VpZGUgPSBgUHJlc3MgJHsoX2MgPSBob3RrZXlzLmRyYWdVcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmhvdGtleX0gYW5kICR7KF9kID0gaG90a2V5cy5kcmFnRG93bikgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmhvdGtleX0gdG8gbW92ZSB1cCBvciBkb3duLCAkeyhfZSA9IGhvdGtleXMuY29tcGxldGVEcmFnKSA9PSBudWxsID8gdm9pZCAwIDogX2UuaG90a2V5fSB0byBkcm9wLCAkeyhfZiA9IGhvdGtleXMuY2FuY2VsRHJhZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLmhvdGtleX0gdG8gYWJvcnQuYDtcbiAgc3dpdGNoIChhc3Npc3RpdmVTdGF0ZSkge1xuICAgIGNhc2UgQXNzaXN0aXZlRG5kU3RhdGUuU3RhcnRlZDpcbiAgICAgIHJldHVybiBpdGVtTmFtZXMgPyBgRHJhZ2dpbmcgJHtpdGVtTmFtZXN9LiBDdXJyZW50IHBvc2l0aW9uOiAke3Bvc2l0aW9ufS4gJHtuYXZHdWlkZX1gIDogYEN1cnJlbnQgcG9zaXRpb246ICR7cG9zaXRpb259LiAke25hdkd1aWRlfWA7XG4gICAgY2FzZSBBc3Npc3RpdmVEbmRTdGF0ZS5EcmFnZ2luZzpcbiAgICAgIHJldHVybiBpdGVtTmFtZXMgPyBgJHtpdGVtTmFtZXN9LCAke3Bvc2l0aW9ufWAgOiBwb3NpdGlvbjtcbiAgICBjYXNlIEFzc2lzdGl2ZURuZFN0YXRlLkNvbXBsZXRlZDpcbiAgICAgIHJldHVybiBgRHJhZyBjb21wbGV0ZWQuIFByZXNzICR7KF9nID0gaG90a2V5cy5zdGFydERyYWcpID09IG51bGwgPyB2b2lkIDAgOiBfZy5ob3RrZXl9IHRvIG1vdmUgc2VsZWN0ZWQgaXRlbXNgO1xuICAgIGNhc2UgQXNzaXN0aXZlRG5kU3RhdGUuQWJvcnRlZDpcbiAgICAgIHJldHVybiBgRHJhZyBjYW5jZWxsZWQuIFByZXNzICR7KF9oID0gaG90a2V5cy5zdGFydERyYWcpID09IG51bGwgPyB2b2lkIDAgOiBfaC5ob3RrZXl9IHRvIG1vdmUgc2VsZWN0ZWQgaXRlbXNgO1xuICAgIGNhc2UgQXNzaXN0aXZlRG5kU3RhdGUuTm9uZTpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGBQcmVzcyAkeyhfaSA9IGhvdGtleXMuc3RhcnREcmFnKSA9PSBudWxsID8gdm9pZCAwIDogX2kuaG90a2V5fSB0byBtb3ZlIHNlbGVjdGVkIGl0ZW1zYDtcbiAgfVxufTtcbnZhciBBc3Npc3RpdmVUcmVlRGVzY3JpcHRpb24gPSAoX2EpID0+IHtcbiAgdmFyIF9iID0gX2EsIHtcbiAgICB0cmVlLFxuICAgIGdldExhYmVsID0gZ2V0RGVmYXVsdExhYmVsXG4gIH0gPSBfYiwgcHJvcHMgPSBfX29ialJlc3QoX2IsIFtcbiAgICBcInRyZWVcIixcbiAgICBcImdldExhYmVsXCJcbiAgXSk7XG4gIHZhciBfYTI7XG4gIGNvbnN0IHN0YXRlID0gdHJlZS5nZXRTdGF0ZSgpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJzcGFuXCIsXG4gICAgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBcImFyaWEtbGl2ZVwiOiBcImFzc2VydGl2ZVwiXG4gICAgfSwgcHJvcHMpLCB7XG4gICAgICBzdHlsZTogX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHN0eWxlcyksIHByb3BzLnN0eWxlKVxuICAgIH0pLFxuICAgIGdldExhYmVsKFxuICAgICAgc3RhdGUuZG5kLFxuICAgICAgKF9hMiA9IHN0YXRlLmFzc2lzdGl2ZURuZFN0YXRlKSAhPSBudWxsID8gX2EyIDogQXNzaXN0aXZlRG5kU3RhdGUuTm9uZSxcbiAgICAgIHRyZWUuZ2V0SG90a2V5UHJlc2V0cygpXG4gICAgKVxuICApO1xufTtcblxuLy8gc3JjL3VzZS10cmVlLnRzeFxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBjcmVhdGVUcmVlIH0gZnJvbSBcIkBoZWFkbGVzcy10cmVlL2NvcmVcIjtcbnZhciB1c2VBcHBseUFmdGVyTW91bnQgPSAoKSA9PiB7XG4gIGNvbnN0IGlzTW91bnRlZCA9IHVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IGNhbGxiYWNrcyA9IHVzZVJlZihbXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaXNNb3VudGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgIGNhbGxiYWNrcy5jdXJyZW50LmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjaygpKTtcbiAgfSwgW10pO1xuICBjb25zdCBhcHBseSA9IChjYWxsYmFjaykgPT4ge1xuICAgIGlmIChpc01vdW50ZWQuY3VycmVudCkge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2tzLmN1cnJlbnQucHVzaChjYWxsYmFjayk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gYXBwbHk7XG59O1xudmFyIHVzZVRyZWUgPSAoY29uZmlnKSA9PiB7XG4gIGNvbnN0IGFwcGx5ID0gdXNlQXBwbHlBZnRlck1vdW50KCk7XG4gIGNvbnN0IFt0cmVlXSA9IHVzZVN0YXRlKCgpID0+ICh7IGN1cnJlbnQ6IGNyZWF0ZVRyZWUoY29uZmlnKSB9KSk7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGUoXG4gICAgKCkgPT4gdHJlZS5jdXJyZW50LmdldFN0YXRlKClcbiAgKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICB0cmVlLmN1cnJlbnQucmVidWlsZFRyZWUoKTtcbiAgfSwgW3RyZWVdKTtcbiAgdHJlZS5jdXJyZW50LnNldENvbmZpZygocHJldikgPT4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgcHJldiksIGNvbmZpZyksIHtcbiAgICBzdGF0ZTogX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHN0YXRlKSwgY29uZmlnLnN0YXRlKSxcbiAgICBzZXRTdGF0ZTogKHN0YXRlMikgPT4ge1xuICAgICAgYXBwbHkoKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHNldFN0YXRlKHN0YXRlMik7XG4gICAgICAgIChfYSA9IGNvbmZpZy5zZXRTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoY29uZmlnLCBzdGF0ZTIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KSk7XG4gIHJldHVybiB0cmVlLmN1cnJlbnQ7XG59O1xuZXhwb3J0IHtcbiAgQXNzaXN0aXZlVHJlZURlc2NyaXB0aW9uLFxuICB1c2VUcmVlXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@headless-tree/react/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fterecal%2Fui-interacitve-lev1%2Fmy-admin-project%2Fui-example-front%2Fsrc%2Fapp%2Fheadless-tree%2Flevel-1%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fterecal%2Fui-interacitve-lev1%2Fmy-admin-project%2Fui-example-front%2Fsrc%2Fapp%2Fheadless-tree%2Flevel-1%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/headless-tree/level-1/page.tsx */ \"(app-pages-browser)/./src/app/headless-tree/level-1/page.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZ0ZXJlY2FsJTJGdWktaW50ZXJhY2l0dmUtbGV2MSUyRm15LWFkbWluLXByb2plY3QlMkZ1aS1leGFtcGxlLWZyb250JTJGc3JjJTJGYXBwJTJGaGVhZGxlc3MtdHJlZSUyRmxldmVsLTElMkZwYWdlLnRzeCUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBLDBNQUFnSiIsInNvdXJjZXMiOlsiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL3RlcmVjYWwvdWktaW50ZXJhY2l0dmUtbGV2MS9teS1hZG1pbi1wcm9qZWN0L3VpLWV4YW1wbGUtZnJvbnQvc3JjL2FwcC9oZWFkbGVzcy10cmVlL2xldmVsLTEvcGFnZS50c3hcIik7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fterecal%2Fui-interacitve-lev1%2Fmy-admin-project%2Fui-example-front%2Fsrc%2Fapp%2Fheadless-tree%2Flevel-1%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_ACTIVITY_TYPE:\n          return \"Activity\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_CONTEXT_TYPE:\n            return type.displayName || \"Context\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function UnknownOwner() {\n      return Error(\"react-stack-top-frame\");\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(type, key, props, owner, debugStack, debugTask) {\n      var refProp = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== refProp ? refProp : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.defineProperty(type, \"_debugStack\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugStack\n      });\n      Object.defineProperty(type, \"_debugTask\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugTask\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      debugStack,\n      debugTask\n    ) {\n      var children = config.children;\n      if (void 0 !== children)\n        if (isStaticChildren)\n          if (isArrayImpl(children)) {\n            for (\n              isStaticChildren = 0;\n              isStaticChildren < children.length;\n              isStaticChildren++\n            )\n              validateChildKeys(children[isStaticChildren]);\n            Object.freeze && Object.freeze(children);\n          } else\n            console.error(\n              \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n            );\n        else validateChildKeys(children);\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(\n        type,\n        children,\n        maybeKey,\n        getOwner(),\n        debugStack,\n        debugTask\n      );\n    }\n    function validateChildKeys(node) {\n      \"object\" === typeof node &&\n        null !== node &&\n        node.$$typeof === REACT_ELEMENT_TYPE &&\n        node._store &&\n        (node._store.validated = 1);\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\n      REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      isArrayImpl = Array.isArray,\n      createTask = console.createTask\n        ? console.createTask\n        : function () {\n            return null;\n          };\n    React = {\n      react_stack_bottom_frame: function (callStackForError) {\n        return callStackForError();\n      }\n    };\n    var specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(\n      React,\n      UnknownOwner\n    )();\n    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n    var didWarnAboutKeySpread = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (type, config, maybeKey, isStaticChildren) {\n      var trackActualOwner =\n        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n      return jsxDEVImpl(\n        type,\n        config,\n        maybeKey,\n        isStaticChildren,\n        trackActualOwner\n          ? Error(\"react-stack-top-frame\")\n          : unknownOwnerDebugStack,\n        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask\n      );\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCwrQ0FBK0MsNkJBQTZCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQWdEO0FBQ2hFLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSxnQ0FBZ0Msa0NBQWtDLE9BQU87QUFDekU7QUFDQSxnR0FBZ0csU0FBUyxVQUFVLHNGQUFzRixhQUFhLFVBQVUsVUFBVTtBQUMxTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsc0dBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCO0FBQ3BCLElBQUksY0FBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUciLCJzb3VyY2VzIjpbIi9Vc2Vycy90ZXJlY2FsL3VpLWludGVyYWNpdHZlLWxldjEvbXktYWRtaW4tcHJvamVjdC91aS1leGFtcGxlLWZyb250L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9BQ1RJVklUWV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIkFjdGl2aXR5XCI7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgKFwibnVtYmVyXCIgPT09IHR5cGVvZiB0eXBlLnRhZyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIHR5cGUuJCR0eXBlb2YpXG4gICAgICAgICkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHZhciBpbm5lclR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgdHlwZSB8fFxuICAgICAgICAgICAgICAoKHR5cGUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChpbm5lclR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGwpLFxuICAgICAgICAgICAgICBudWxsICE9PSBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA/IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgIDogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBpbm5lclR5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUoaW5uZXJUeXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgfVxuICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBjb25zb2xlO1xuICAgICAgICB2YXIgSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmVycm9yO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID1cbiAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10pIHx8XG4gICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICAgIFwiT2JqZWN0XCI7XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdC5jYWxsKFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCxcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUYXNrTmFtZSh0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkgcmV0dXJuIFwiPD5cIjtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgbnVsbCAhPT0gdHlwZSAmJlxuICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEVcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIFwiPC4uLj5cIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICByZXR1cm4gbmFtZSA/IFwiPFwiICsgbmFtZSArIFwiPlwiIDogXCI8Li4uPlwiO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICByZXR1cm4gXCI8Li4uPlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRPd25lcigpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuQTtcbiAgICAgIHJldHVybiBudWxsID09PSBkaXNwYXRjaGVyID8gbnVsbCA6IGRpc3BhdGNoZXIuZ2V0T3duZXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVW5rbm93bk93bmVyKCkge1xuICAgICAgcmV0dXJuIEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCBcImtleVwiKS5nZXQ7XG4gICAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb25maWcua2V5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgICAgIGZ1bmN0aW9uIHdhcm5BYm91dEFjY2Vzc2luZ0tleSgpIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gfHxcbiAgICAgICAgICAoKHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gITApLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zcGVjaWFsLXByb3BzKVwiLFxuICAgICAgICAgICAgZGlzcGxheU5hbWVcbiAgICAgICAgICApKTtcbiAgICAgIH1cbiAgICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9ICEwO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCBcImtleVwiLCB7XG4gICAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmcoKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0aGlzLnR5cGUpO1xuICAgICAgZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSB8fFxuICAgICAgICAoKGRpZFdhcm5BYm91dEVsZW1lbnRSZWZbY29tcG9uZW50TmFtZV0gPSAhMCksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJBY2Nlc3NpbmcgZWxlbWVudC5yZWYgd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIHJlZiBpcyBub3cgYSByZWd1bGFyIHByb3AuIEl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBKU1ggRWxlbWVudCB0eXBlIGluIGEgZnV0dXJlIHJlbGVhc2UuXCJcbiAgICAgICAgKSk7XG4gICAgICBjb21wb25lbnROYW1lID0gdGhpcy5wcm9wcy5yZWY7XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb21wb25lbnROYW1lID8gY29tcG9uZW50TmFtZSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHByb3BzLCBvd25lciwgZGVidWdTdGFjaywgZGVidWdUYXNrKSB7XG4gICAgICB2YXIgcmVmUHJvcCA9IHByb3BzLnJlZjtcbiAgICAgIHR5cGUgPSB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGtleToga2V5LFxuICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgIF9vd25lcjogb3duZXJcbiAgICAgIH07XG4gICAgICBudWxsICE9PSAodm9pZCAwICE9PSByZWZQcm9wID8gcmVmUHJvcCA6IG51bGwpXG4gICAgICAgID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwicmVmXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgICAgZ2V0OiBlbGVtZW50UmVmR2V0dGVyV2l0aERlcHJlY2F0aW9uV2FybmluZ1xuICAgICAgICAgIH0pXG4gICAgICAgIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwicmVmXCIsIHsgZW51bWVyYWJsZTogITEsIHZhbHVlOiBudWxsIH0pO1xuICAgICAgdHlwZS5fc3RvcmUgPSB7fTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLl9zdG9yZSwgXCJ2YWxpZGF0ZWRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogMFxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJfZGVidWdJbmZvXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnU3RhY2tcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogZGVidWdTdGFja1xuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJfZGVidWdUYXNrXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IGRlYnVnVGFza1xuICAgICAgfSk7XG4gICAgICBPYmplY3QuZnJlZXplICYmIChPYmplY3QuZnJlZXplKHR5cGUucHJvcHMpLCBPYmplY3QuZnJlZXplKHR5cGUpKTtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBqc3hERVZJbXBsKFxuICAgICAgdHlwZSxcbiAgICAgIGNvbmZpZyxcbiAgICAgIG1heWJlS2V5LFxuICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgIGRlYnVnU3RhY2ssXG4gICAgICBkZWJ1Z1Rhc2tcbiAgICApIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcbiAgICAgIGlmICh2b2lkIDAgIT09IGNoaWxkcmVuKVxuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbilcbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuID0gMDtcbiAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA8IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbisrXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2lzU3RhdGljQ2hpbGRyZW5dKTtcbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUgJiYgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuIFlvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgZWxzZSB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbik7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIFwia2V5XCIpKSB7XG4gICAgICAgIGNoaWxkcmVuID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNvbmZpZykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgcmV0dXJuIFwia2V5XCIgIT09IGs7XG4gICAgICAgIH0pO1xuICAgICAgICBpc1N0YXRpY0NoaWxkcmVuID1cbiAgICAgICAgICAwIDwga2V5cy5sZW5ndGhcbiAgICAgICAgICAgID8gXCJ7a2V5OiBzb21lS2V5LCBcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiXG4gICAgICAgICAgICA6IFwie2tleTogc29tZUtleX1cIjtcbiAgICAgICAgZGlkV2FybkFib3V0S2V5U3ByZWFkW2NoaWxkcmVuICsgaXNTdGF0aWNDaGlsZHJlbl0gfHxcbiAgICAgICAgICAoKGtleXMgPVxuICAgICAgICAgICAgMCA8IGtleXMubGVuZ3RoID8gXCJ7XCIgKyBrZXlzLmpvaW4oXCI6IC4uLiwgXCIpICsgXCI6IC4uLn1cIiA6IFwie31cIiksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4gIGxldCBwcm9wcyA9ICVzO1xcbiAgPCVzIHsuLi5wcm9wc30gLz5cXG5SZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4gIGxldCBwcm9wcyA9ICVzO1xcbiAgPCVzIGtleT17c29tZUtleX0gey4uLnByb3BzfSAvPicsXG4gICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICBrZXlzLFxuICAgICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgICApLFxuICAgICAgICAgIChkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSA9ICEwKSk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbiA9IG51bGw7XG4gICAgICB2b2lkIDAgIT09IG1heWJlS2V5ICYmXG4gICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKG1heWJlS2V5KSwgKGNoaWxkcmVuID0gXCJcIiArIG1heWJlS2V5KSk7XG4gICAgICBoYXNWYWxpZEtleShjb25maWcpICYmXG4gICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgY29uZmlnLmtleSkpO1xuICAgICAgaWYgKFwia2V5XCIgaW4gY29uZmlnKSB7XG4gICAgICAgIG1heWJlS2V5ID0ge307XG4gICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIGNvbmZpZylcbiAgICAgICAgICBcImtleVwiICE9PSBwcm9wTmFtZSAmJiAobWF5YmVLZXlbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXSk7XG4gICAgICB9IGVsc2UgbWF5YmVLZXkgPSBjb25maWc7XG4gICAgICBjaGlsZHJlbiAmJlxuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihcbiAgICAgICAgICBtYXliZUtleSxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlXG4gICAgICAgICAgICA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IFwiVW5rbm93blwiXG4gICAgICAgICAgICA6IHR5cGVcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBSZWFjdEVsZW1lbnQoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBtYXliZUtleSxcbiAgICAgICAgZ2V0T3duZXIoKSxcbiAgICAgICAgZGVidWdTdGFjayxcbiAgICAgICAgZGVidWdUYXNrXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlKSB7XG4gICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygbm9kZSAmJlxuICAgICAgICBudWxsICE9PSBub2RlICYmXG4gICAgICAgIG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSAmJlxuICAgICAgICBub2RlLl9zdG9yZSAmJlxuICAgICAgICAobm9kZS5fc3RvcmUudmFsaWRhdGVkID0gMSk7XG4gICAgfVxuICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIiksXG4gICAgICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIiksXG4gICAgICBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksXG4gICAgICBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLFxuICAgICAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSxcbiAgICAgIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIiksXG4gICAgICBSRUFDVF9DT05TVU1FUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnN1bWVyXCIpLFxuICAgICAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksXG4gICAgICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLFxuICAgICAgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIiksXG4gICAgICBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSxcbiAgICAgIFJFQUNUX0FDVElWSVRZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuYWN0aXZpdHlcIiksXG4gICAgICBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscyA9XG4gICAgICAgIFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcbiAgICAgIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheSxcbiAgICAgIGNyZWF0ZVRhc2sgPSBjb25zb2xlLmNyZWF0ZVRhc2tcbiAgICAgICAgPyBjb25zb2xlLmNyZWF0ZVRhc2tcbiAgICAgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9O1xuICAgIFJlYWN0ID0ge1xuICAgICAgcmVhY3Rfc3RhY2tfYm90dG9tX2ZyYW1lOiBmdW5jdGlvbiAoY2FsbFN0YWNrRm9yRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxTdGFja0ZvckVycm9yKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG4gICAgdmFyIGRpZFdhcm5BYm91dEVsZW1lbnRSZWYgPSB7fTtcbiAgICB2YXIgdW5rbm93bk93bmVyRGVidWdTdGFjayA9IFJlYWN0LnJlYWN0X3N0YWNrX2JvdHRvbV9mcmFtZS5iaW5kKFxuICAgICAgUmVhY3QsXG4gICAgICBVbmtub3duT3duZXJcbiAgICApKCk7XG4gICAgdmFyIHVua25vd25Pd25lckRlYnVnVGFzayA9IGNyZWF0ZVRhc2soZ2V0VGFza05hbWUoVW5rbm93bk93bmVyKSk7XG4gICAgdmFyIGRpZFdhcm5BYm91dEtleVNwcmVhZCA9IHt9O1xuICAgIGV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuICAgIGV4cG9ydHMuanN4REVWID0gZnVuY3Rpb24gKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgIHZhciB0cmFja0FjdHVhbE93bmVyID1cbiAgICAgICAgMWU0ID4gUmVhY3RTaGFyZWRJbnRlcm5hbHMucmVjZW50bHlDcmVhdGVkT3duZXJTdGFja3MrKztcbiAgICAgIHJldHVybiBqc3hERVZJbXBsKFxuICAgICAgICB0eXBlLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIG1heWJlS2V5LFxuICAgICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgICB0cmFja0FjdHVhbE93bmVyXG4gICAgICAgICAgPyBFcnJvcihcInJlYWN0LXN0YWNrLXRvcC1mcmFtZVwiKVxuICAgICAgICAgIDogdW5rbm93bk93bmVyRGVidWdTdGFjayxcbiAgICAgICAgdHJhY2tBY3R1YWxPd25lciA/IGNyZWF0ZVRhc2soZ2V0VGFza05hbWUodHlwZSkpIDogdW5rbm93bk93bmVyRGVidWdUYXNrXG4gICAgICApO1xuICAgIH07XG4gIH0pKCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIi9Vc2Vycy90ZXJlY2FsL3VpLWludGVyYWNpdHZlLWxldjEvbXktYWRtaW4tcHJvamVjdC91aS1leGFtcGxlLWZyb250L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/headless-tree/level-1/page.tsx":
/*!************************************************!*\
  !*** ./src/app/headless-tree/level-1/page.tsx ***!
  \************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ HeadlessTreeLevel1)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _headless_tree_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @headless-tree/react */ \"(app-pages-browser)/./node_modules/@headless-tree/react/dist/index.mjs\");\n/* harmony import */ var _headless_tree_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @headless-tree/core */ \"(app-pages-browser)/./node_modules/@headless-tree/core/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nconst initialTreeData = {\n    \"package.json\": {\n        \"//\": \"...\"\n    },\n    src: {\n        \"App.tsx\": {\n            \"//\": \"...\"\n        },\n        \"index.ts\": {\n            \"//\": \"...\"\n        },\n        components: {\n            \"Button.tsx\": {\n                \"//\": \"...\"\n            },\n            \"Modal.tsx\": {\n                \"//\": \"...\"\n            }\n        }\n    }\n};\n// Helper functions to work with tree data\nconst getItemFromPath = (data, path)=>{\n    const parts = path.split('/').filter(Boolean);\n    let current = data;\n    let name = path;\n    for (const part of parts){\n        if (current && typeof current === 'object' && current[part] !== undefined) {\n            current = current[part];\n            name = part;\n        } else {\n            return null;\n        }\n    }\n    return {\n        name,\n        isFolder: current && typeof current === 'object' && !current.hasOwnProperty('//')\n    };\n};\nconst getChildrenFromPath = (data, path)=>{\n    if (!path) return Object.keys(data);\n    const parts = path.split('/').filter(Boolean);\n    let current = data;\n    for (const part of parts){\n        if (current && typeof current === 'object' && current[part] !== undefined) {\n            current = current[part];\n        } else {\n            return [];\n        }\n    }\n    if (current && typeof current === 'object' && !current.hasOwnProperty('//')) {\n        return Object.keys(current).map((key)=>path ? \"\".concat(path, \"/\").concat(key) : key);\n    }\n    return [];\n};\n// The TreeItem component\nconst TreeItem = (param)=>{\n    let { item } = param;\n    const isExpanded = item.isExpanded();\n    const isFolder = item.isFolder();\n    const isSelected = item.isSelected();\n    const itemData = getItemFromPath(initialTreeData, item.getItemData());\n    const label = (itemData === null || itemData === void 0 ? void 0 : itemData.name) || item.getItemData();\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ...item.getProps(),\n        style: {\n            paddingLeft: \"\".concat(item.getItemMeta().level * 20, \"px\")\n        },\n        className: \"flex items-center space-x-2 cursor-pointer hover:bg-slate-100 rounded-md p-1 \".concat(isSelected ? \"bg-blue-100\" : \"\"),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                children: isFolder ? isExpanded ? \"📂\" : \"📁\" : \"📄\"\n            }, void 0, false, {\n                fileName: \"/Users/terecal/ui-interacitve-lev1/my-admin-project/ui-example-front/src/app/headless-tree/level-1/page.tsx\",\n                lineNumber: 76,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                children: label\n            }, void 0, false, {\n                fileName: \"/Users/terecal/ui-interacitve-lev1/my-admin-project/ui-example-front/src/app/headless-tree/level-1/page.tsx\",\n                lineNumber: 77,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/terecal/ui-interacitve-lev1/my-admin-project/ui-example-front/src/app/headless-tree/level-1/page.tsx\",\n        lineNumber: 71,\n        columnNumber: 5\n    }, undefined);\n};\n_c = TreeItem;\nfunction HeadlessTreeLevel1() {\n    _s();\n    // The main tree controller\n    const tree = (0,_headless_tree_react__WEBPACK_IMPORTED_MODULE_2__.useTree)({\n        rootItemId: \"\",\n        getItemName: {\n            \"HeadlessTreeLevel1.useTree[tree]\": (item)=>{\n                const itemData = getItemFromPath(initialTreeData, item.getItemData());\n                return (itemData === null || itemData === void 0 ? void 0 : itemData.name) || item.getItemData();\n            }\n        }[\"HeadlessTreeLevel1.useTree[tree]\"],\n        isItemFolder: {\n            \"HeadlessTreeLevel1.useTree[tree]\": (item)=>{\n                const itemData = getItemFromPath(initialTreeData, item.getItemData());\n                return (itemData === null || itemData === void 0 ? void 0 : itemData.isFolder) || false;\n            }\n        }[\"HeadlessTreeLevel1.useTree[tree]\"],\n        dataLoader: {\n            getItem: {\n                \"HeadlessTreeLevel1.useTree[tree]\": (itemId)=>itemId\n            }[\"HeadlessTreeLevel1.useTree[tree]\"],\n            getChildren: {\n                \"HeadlessTreeLevel1.useTree[tree]\": (itemId)=>getChildrenFromPath(initialTreeData, itemId)\n            }[\"HeadlessTreeLevel1.useTree[tree]\"]\n        },\n        features: [\n            _headless_tree_core__WEBPACK_IMPORTED_MODULE_3__.syncDataLoaderFeature,\n            _headless_tree_core__WEBPACK_IMPORTED_MODULE_3__.selectionFeature,\n            _headless_tree_core__WEBPACK_IMPORTED_MODULE_3__.hotkeysCoreFeature\n        ],\n        initialState: {\n            expandedItems: [\n                \"src\"\n            ]\n        }\n    });\n    // Get all items for rendering\n    const items = tree.getItems();\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"container mx-auto py-10\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"max-w-md mx-auto\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                    className: \"text-4xl font-bold mb-6 text-center\",\n                    children: \"Headless Tree - Level 1\"\n                }, void 0, false, {\n                    fileName: \"/Users/terecal/ui-interacitve-lev1/my-admin-project/ui-example-front/src/app/headless-tree/level-1/page.tsx\",\n                    lineNumber: 110,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                    className: \"text-muted-foreground text-center mb-8\",\n                    children: \"Basic file explorer tree implementation. Click on folders to expand and collapse them.\"\n                }, void 0, false, {\n                    fileName: \"/Users/terecal/ui-interacitve-lev1/my-admin-project/ui-example-front/src/app/headless-tree/level-1/page.tsx\",\n                    lineNumber: 113,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    ...tree.getContainerProps(),\n                    className: \"p-4 bg-white border rounded-lg\",\n                    children: items.map((item)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(TreeItem, {\n                            item: item\n                        }, item.getId(), false, {\n                            fileName: \"/Users/terecal/ui-interacitve-lev1/my-admin-project/ui-example-front/src/app/headless-tree/level-1/page.tsx\",\n                            lineNumber: 118,\n                            columnNumber: 13\n                        }, this))\n                }, void 0, false, {\n                    fileName: \"/Users/terecal/ui-interacitve-lev1/my-admin-project/ui-example-front/src/app/headless-tree/level-1/page.tsx\",\n                    lineNumber: 116,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/terecal/ui-interacitve-lev1/my-admin-project/ui-example-front/src/app/headless-tree/level-1/page.tsx\",\n            lineNumber: 109,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/terecal/ui-interacitve-lev1/my-admin-project/ui-example-front/src/app/headless-tree/level-1/page.tsx\",\n        lineNumber: 108,\n        columnNumber: 5\n    }, this);\n}\n_s(HeadlessTreeLevel1, \"ior+FCT7IEVtSaa3nesd5tl0ans=\", false, function() {\n    return [\n        _headless_tree_react__WEBPACK_IMPORTED_MODULE_2__.useTree\n    ];\n});\n_c1 = HeadlessTreeLevel1;\nvar _c, _c1;\n$RefreshReg$(_c, \"TreeItem\");\n$RefreshReg$(_c1, \"HeadlessTreeLevel1\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvaGVhZGxlc3MtdHJlZS9sZXZlbC0xL3BhZ2UudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBRStDO0FBQ21EO0FBRS9DO0FBRW5ELE1BQU1LLGtCQUFrQjtJQUN0QixnQkFBZ0I7UUFBRSxNQUFNO0lBQU07SUFDOUJDLEtBQUs7UUFDSCxXQUFXO1lBQUUsTUFBTTtRQUFNO1FBQ3pCLFlBQVk7WUFBRSxNQUFNO1FBQU07UUFDMUJDLFlBQVk7WUFDVixjQUFjO2dCQUFFLE1BQU07WUFBTTtZQUM1QixhQUFhO2dCQUFFLE1BQU07WUFBTTtRQUM3QjtJQUNGO0FBQ0Y7QUFFQSwwQ0FBMEM7QUFDMUMsTUFBTUMsa0JBQWtCLENBQUNDLE1BQVdDO0lBQ2xDLE1BQU1DLFFBQVFELEtBQUtFLEtBQUssQ0FBQyxLQUFLQyxNQUFNLENBQUNDO0lBQ3JDLElBQUlDLFVBQVVOO0lBQ2QsSUFBSU8sT0FBT047SUFFWCxLQUFLLE1BQU1PLFFBQVFOLE1BQU87UUFDeEIsSUFBSUksV0FBVyxPQUFPQSxZQUFZLFlBQVlBLE9BQU8sQ0FBQ0UsS0FBSyxLQUFLQyxXQUFXO1lBQ3pFSCxVQUFVQSxPQUFPLENBQUNFLEtBQUs7WUFDdkJELE9BQU9DO1FBQ1QsT0FBTztZQUNMLE9BQU87UUFDVDtJQUNGO0lBRUEsT0FBTztRQUNMRDtRQUNBRyxVQUFVSixXQUFXLE9BQU9BLFlBQVksWUFBWSxDQUFDQSxRQUFRSyxjQUFjLENBQUM7SUFDOUU7QUFDRjtBQUVBLE1BQU1DLHNCQUFzQixDQUFDWixNQUFXQztJQUN0QyxJQUFJLENBQUNBLE1BQU0sT0FBT1ksT0FBT0MsSUFBSSxDQUFDZDtJQUU5QixNQUFNRSxRQUFRRCxLQUFLRSxLQUFLLENBQUMsS0FBS0MsTUFBTSxDQUFDQztJQUNyQyxJQUFJQyxVQUFVTjtJQUVkLEtBQUssTUFBTVEsUUFBUU4sTUFBTztRQUN4QixJQUFJSSxXQUFXLE9BQU9BLFlBQVksWUFBWUEsT0FBTyxDQUFDRSxLQUFLLEtBQUtDLFdBQVc7WUFDekVILFVBQVVBLE9BQU8sQ0FBQ0UsS0FBSztRQUN6QixPQUFPO1lBQ0wsT0FBTyxFQUFFO1FBQ1g7SUFDRjtJQUVBLElBQUlGLFdBQVcsT0FBT0EsWUFBWSxZQUFZLENBQUNBLFFBQVFLLGNBQWMsQ0FBQyxPQUFPO1FBQzNFLE9BQU9FLE9BQU9DLElBQUksQ0FBQ1IsU0FBU1MsR0FBRyxDQUFDQyxDQUFBQSxNQUFPZixPQUFPLEdBQVdlLE9BQVJmLE1BQUssS0FBTyxPQUFKZSxPQUFRQTtJQUNuRTtJQUVBLE9BQU8sRUFBRTtBQUNYO0FBRUEseUJBQXlCO0FBQ3pCLE1BQU1DLFdBQVc7UUFBQyxFQUFFQyxJQUFJLEVBQWtDO0lBQ3hELE1BQU1DLGFBQWFELEtBQUtDLFVBQVU7SUFDbEMsTUFBTVQsV0FBV1EsS0FBS1IsUUFBUTtJQUM5QixNQUFNVSxhQUFhRixLQUFLRSxVQUFVO0lBQ2xDLE1BQU1DLFdBQVd0QixnQkFBZ0JILGlCQUFpQnNCLEtBQUtJLFdBQVc7SUFDbEUsTUFBTUMsUUFBUUYsQ0FBQUEscUJBQUFBLCtCQUFBQSxTQUFVZCxJQUFJLEtBQUlXLEtBQUtJLFdBQVc7SUFFaEQscUJBQ0UsOERBQUNFO1FBQ0UsR0FBR04sS0FBS08sUUFBUSxFQUFFO1FBQ25CQyxPQUFPO1lBQUVDLGFBQWEsR0FBaUMsT0FBOUJULEtBQUtVLFdBQVcsR0FBR0MsS0FBSyxHQUFHLElBQUc7UUFBSTtRQUMzREMsV0FBVyxnRkFBZ0gsT0FBaENWLGFBQWEsZ0JBQWdCOzswQkFFeEgsOERBQUNXOzBCQUFNckIsV0FBWVMsYUFBYSxPQUFPLE9BQVE7Ozs7OzswQkFDL0MsOERBQUNZOzBCQUFNUjs7Ozs7Ozs7Ozs7O0FBR2I7S0FqQk1OO0FBbUJTLFNBQVNlOztJQUN0QiwyQkFBMkI7SUFDM0IsTUFBTUMsT0FBTzFDLDZEQUFPQSxDQUFTO1FBQzNCMkMsWUFBWTtRQUNaQyxXQUFXO2dEQUFFLENBQUNqQjtnQkFDWixNQUFNRyxXQUFXdEIsZ0JBQWdCSCxpQkFBaUJzQixLQUFLSSxXQUFXO2dCQUNsRSxPQUFPRCxDQUFBQSxxQkFBQUEsK0JBQUFBLFNBQVVkLElBQUksS0FBSVcsS0FBS0ksV0FBVztZQUMzQzs7UUFDQWMsWUFBWTtnREFBRSxDQUFDbEI7Z0JBQ2IsTUFBTUcsV0FBV3RCLGdCQUFnQkgsaUJBQWlCc0IsS0FBS0ksV0FBVztnQkFDbEUsT0FBT0QsQ0FBQUEscUJBQUFBLCtCQUFBQSxTQUFVWCxRQUFRLEtBQUk7WUFDL0I7O1FBQ0EyQixZQUFZO1lBQ1ZDLE9BQU87b0RBQUUsQ0FBQ0MsU0FBbUJBOztZQUM3QkMsV0FBVztvREFBRSxDQUFDRCxTQUFtQjNCLG9CQUFvQmhCLGlCQUFpQjJDOztRQUN4RTtRQUNBRSxVQUFVO1lBQUNqRCxzRUFBcUJBO1lBQUVDLGlFQUFnQkE7WUFBRUMsbUVBQWtCQTtTQUFDO1FBQ3ZFZ0QsY0FBYztZQUNaQyxlQUFlO2dCQUFDO2FBQU07UUFDeEI7SUFDRjtJQUVBLDhCQUE4QjtJQUM5QixNQUFNQyxRQUFRWCxLQUFLWSxRQUFRO0lBRTNCLHFCQUNFLDhEQUFDckI7UUFBSU0sV0FBVTtrQkFDYiw0RUFBQ047WUFBSU0sV0FBVTs7OEJBQ2IsOERBQUNnQjtvQkFBR2hCLFdBQVU7OEJBQXNDOzs7Ozs7OEJBR3BELDhEQUFDaUI7b0JBQUVqQixXQUFVOzhCQUF5Qzs7Ozs7OzhCQUd0RCw4REFBQ047b0JBQUssR0FBR1MsS0FBS2UsaUJBQWlCLEVBQUU7b0JBQUVsQixXQUFVOzhCQUMxQ2MsTUFBTTdCLEdBQUcsQ0FBQyxDQUFDRyxxQkFDViw4REFBQ0Q7NEJBQTRCQyxNQUFNQTsyQkFBcEJBLEtBQUsrQixLQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFNckM7R0ExQ3dCakI7O1FBRVR6Qyx5REFBT0E7OztNQUZFeUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy90ZXJlY2FsL3VpLWludGVyYWNpdHZlLWxldjEvbXktYWRtaW4tcHJvamVjdC91aS1leGFtcGxlLWZyb250L3NyYy9hcHAvaGVhZGxlc3MtdHJlZS9sZXZlbC0xL3BhZ2UudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgeyB1c2VUcmVlIH0gZnJvbSBcIkBoZWFkbGVzcy10cmVlL3JlYWN0XCI7XG5pbXBvcnQgeyBzeW5jRGF0YUxvYWRlckZlYXR1cmUsIHNlbGVjdGlvbkZlYXR1cmUsIGhvdGtleXNDb3JlRmVhdHVyZSB9IGZyb20gXCJAaGVhZGxlc3MtdHJlZS9jb3JlXCI7XG5pbXBvcnQgdHlwZSB7IEl0ZW1JbnN0YW5jZSwgVHJlZUluc3RhbmNlIH0gZnJvbSBcIkBoZWFkbGVzcy10cmVlL2NvcmVcIjtcbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XG5cbmNvbnN0IGluaXRpYWxUcmVlRGF0YSA9IHtcbiAgXCJwYWNrYWdlLmpzb25cIjogeyBcIi8vXCI6IFwiLi4uXCIgfSxcbiAgc3JjOiB7XG4gICAgXCJBcHAudHN4XCI6IHsgXCIvL1wiOiBcIi4uLlwiIH0sXG4gICAgXCJpbmRleC50c1wiOiB7IFwiLy9cIjogXCIuLi5cIiB9LFxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgIFwiQnV0dG9uLnRzeFwiOiB7IFwiLy9cIjogXCIuLi5cIiB9LFxuICAgICAgXCJNb2RhbC50c3hcIjogeyBcIi8vXCI6IFwiLi4uXCIgfSxcbiAgICB9LFxuICB9LFxufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGggdHJlZSBkYXRhXG5jb25zdCBnZXRJdGVtRnJvbVBhdGggPSAoZGF0YTogYW55LCBwYXRoOiBzdHJpbmcpOiB7IG5hbWU6IHN0cmluZzsgaXNGb2xkZXI6IGJvb2xlYW4gfSB8IG51bGwgPT4ge1xuICBjb25zdCBwYXJ0cyA9IHBhdGguc3BsaXQoJy8nKS5maWx0ZXIoQm9vbGVhbik7XG4gIGxldCBjdXJyZW50ID0gZGF0YTtcbiAgbGV0IG5hbWUgPSBwYXRoO1xuICBcbiAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgaWYgKGN1cnJlbnQgJiYgdHlwZW9mIGN1cnJlbnQgPT09ICdvYmplY3QnICYmIGN1cnJlbnRbcGFydF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY3VycmVudCA9IGN1cnJlbnRbcGFydF07XG4gICAgICBuYW1lID0gcGFydDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4ge1xuICAgIG5hbWUsXG4gICAgaXNGb2xkZXI6IGN1cnJlbnQgJiYgdHlwZW9mIGN1cnJlbnQgPT09ICdvYmplY3QnICYmICFjdXJyZW50Lmhhc093blByb3BlcnR5KCcvLycpXG4gIH07XG59O1xuXG5jb25zdCBnZXRDaGlsZHJlbkZyb21QYXRoID0gKGRhdGE6IGFueSwgcGF0aDogc3RyaW5nKTogc3RyaW5nW10gPT4ge1xuICBpZiAoIXBhdGgpIHJldHVybiBPYmplY3Qua2V5cyhkYXRhKTtcbiAgXG4gIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdCgnLycpLmZpbHRlcihCb29sZWFuKTtcbiAgbGV0IGN1cnJlbnQgPSBkYXRhO1xuICBcbiAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgaWYgKGN1cnJlbnQgJiYgdHlwZW9mIGN1cnJlbnQgPT09ICdvYmplY3QnICYmIGN1cnJlbnRbcGFydF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY3VycmVudCA9IGN1cnJlbnRbcGFydF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cbiAgXG4gIGlmIChjdXJyZW50ICYmIHR5cGVvZiBjdXJyZW50ID09PSAnb2JqZWN0JyAmJiAhY3VycmVudC5oYXNPd25Qcm9wZXJ0eSgnLy8nKSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhjdXJyZW50KS5tYXAoa2V5ID0+IHBhdGggPyBgJHtwYXRofS8ke2tleX1gIDoga2V5KTtcbiAgfVxuICBcbiAgcmV0dXJuIFtdO1xufTtcblxuLy8gVGhlIFRyZWVJdGVtIGNvbXBvbmVudFxuY29uc3QgVHJlZUl0ZW0gPSAoeyBpdGVtIH06IHsgaXRlbTogSXRlbUluc3RhbmNlPHN0cmluZz4gfSkgPT4ge1xuICBjb25zdCBpc0V4cGFuZGVkID0gaXRlbS5pc0V4cGFuZGVkKCk7XG4gIGNvbnN0IGlzRm9sZGVyID0gaXRlbS5pc0ZvbGRlcigpO1xuICBjb25zdCBpc1NlbGVjdGVkID0gaXRlbS5pc1NlbGVjdGVkKCk7XG4gIGNvbnN0IGl0ZW1EYXRhID0gZ2V0SXRlbUZyb21QYXRoKGluaXRpYWxUcmVlRGF0YSwgaXRlbS5nZXRJdGVtRGF0YSgpKTtcbiAgY29uc3QgbGFiZWwgPSBpdGVtRGF0YT8ubmFtZSB8fCBpdGVtLmdldEl0ZW1EYXRhKCk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICB7Li4uaXRlbS5nZXRQcm9wcygpfVxuICAgICAgc3R5bGU9e3sgcGFkZGluZ0xlZnQ6IGAke2l0ZW0uZ2V0SXRlbU1ldGEoKS5sZXZlbCAqIDIwfXB4YCB9fVxuICAgICAgY2xhc3NOYW1lPXtgZmxleCBpdGVtcy1jZW50ZXIgc3BhY2UteC0yIGN1cnNvci1wb2ludGVyIGhvdmVyOmJnLXNsYXRlLTEwMCByb3VuZGVkLW1kIHAtMSAke2lzU2VsZWN0ZWQgPyBcImJnLWJsdWUtMTAwXCIgOiBcIlwifWB9XG4gICAgPlxuICAgICAgPHNwYW4+e2lzRm9sZGVyID8gKGlzRXhwYW5kZWQgPyBcIvCfk4JcIiA6IFwi8J+TgVwiKSA6IFwi8J+ThFwifTwvc3Bhbj5cbiAgICAgIDxzcGFuPntsYWJlbH08L3NwYW4+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBIZWFkbGVzc1RyZWVMZXZlbDEoKSB7XG4gIC8vIFRoZSBtYWluIHRyZWUgY29udHJvbGxlclxuICBjb25zdCB0cmVlID0gdXNlVHJlZTxzdHJpbmc+KHtcbiAgICByb290SXRlbUlkOiBcIlwiLFxuICAgIGdldEl0ZW1OYW1lOiAoaXRlbSkgPT4ge1xuICAgICAgY29uc3QgaXRlbURhdGEgPSBnZXRJdGVtRnJvbVBhdGgoaW5pdGlhbFRyZWVEYXRhLCBpdGVtLmdldEl0ZW1EYXRhKCkpO1xuICAgICAgcmV0dXJuIGl0ZW1EYXRhPy5uYW1lIHx8IGl0ZW0uZ2V0SXRlbURhdGEoKTtcbiAgICB9LFxuICAgIGlzSXRlbUZvbGRlcjogKGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1EYXRhID0gZ2V0SXRlbUZyb21QYXRoKGluaXRpYWxUcmVlRGF0YSwgaXRlbS5nZXRJdGVtRGF0YSgpKTtcbiAgICAgIHJldHVybiBpdGVtRGF0YT8uaXNGb2xkZXIgfHwgZmFsc2U7XG4gICAgfSxcbiAgICBkYXRhTG9hZGVyOiB7XG4gICAgICBnZXRJdGVtOiAoaXRlbUlkOiBzdHJpbmcpID0+IGl0ZW1JZCxcbiAgICAgIGdldENoaWxkcmVuOiAoaXRlbUlkOiBzdHJpbmcpID0+IGdldENoaWxkcmVuRnJvbVBhdGgoaW5pdGlhbFRyZWVEYXRhLCBpdGVtSWQpXG4gICAgfSxcbiAgICBmZWF0dXJlczogW3N5bmNEYXRhTG9hZGVyRmVhdHVyZSwgc2VsZWN0aW9uRmVhdHVyZSwgaG90a2V5c0NvcmVGZWF0dXJlXSxcbiAgICBpbml0aWFsU3RhdGU6IHtcbiAgICAgIGV4cGFuZGVkSXRlbXM6IFtcInNyY1wiXVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gR2V0IGFsbCBpdGVtcyBmb3IgcmVuZGVyaW5nXG4gIGNvbnN0IGl0ZW1zID0gdHJlZS5nZXRJdGVtcygpO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJjb250YWluZXIgbXgtYXV0byBweS0xMFwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYXgtdy1tZCBteC1hdXRvXCI+XG4gICAgICAgIDxoMSBjbGFzc05hbWU9XCJ0ZXh0LTR4bCBmb250LWJvbGQgbWItNiB0ZXh0LWNlbnRlclwiPlxuICAgICAgICAgIEhlYWRsZXNzIFRyZWUgLSBMZXZlbCAxXG4gICAgICAgIDwvaDE+XG4gICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtbXV0ZWQtZm9yZWdyb3VuZCB0ZXh0LWNlbnRlciBtYi04XCI+XG4gICAgICAgICAgQmFzaWMgZmlsZSBleHBsb3JlciB0cmVlIGltcGxlbWVudGF0aW9uLiBDbGljayBvbiBmb2xkZXJzIHRvIGV4cGFuZCBhbmQgY29sbGFwc2UgdGhlbS5cbiAgICAgICAgPC9wPlxuICAgICAgICA8ZGl2IHsuLi50cmVlLmdldENvbnRhaW5lclByb3BzKCl9IGNsYXNzTmFtZT1cInAtNCBiZy13aGl0ZSBib3JkZXIgcm91bmRlZC1sZ1wiPlxuICAgICAgICAgIHtpdGVtcy5tYXAoKGl0ZW0pID0+IChcbiAgICAgICAgICAgIDxUcmVlSXRlbSBrZXk9e2l0ZW0uZ2V0SWQoKX0gaXRlbT17aXRlbX0gLz5cbiAgICAgICAgICApKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn0iXSwibmFtZXMiOlsidXNlVHJlZSIsInN5bmNEYXRhTG9hZGVyRmVhdHVyZSIsInNlbGVjdGlvbkZlYXR1cmUiLCJob3RrZXlzQ29yZUZlYXR1cmUiLCJSZWFjdCIsImluaXRpYWxUcmVlRGF0YSIsInNyYyIsImNvbXBvbmVudHMiLCJnZXRJdGVtRnJvbVBhdGgiLCJkYXRhIiwicGF0aCIsInBhcnRzIiwic3BsaXQiLCJmaWx0ZXIiLCJCb29sZWFuIiwiY3VycmVudCIsIm5hbWUiLCJwYXJ0IiwidW5kZWZpbmVkIiwiaXNGb2xkZXIiLCJoYXNPd25Qcm9wZXJ0eSIsImdldENoaWxkcmVuRnJvbVBhdGgiLCJPYmplY3QiLCJrZXlzIiwibWFwIiwia2V5IiwiVHJlZUl0ZW0iLCJpdGVtIiwiaXNFeHBhbmRlZCIsImlzU2VsZWN0ZWQiLCJpdGVtRGF0YSIsImdldEl0ZW1EYXRhIiwibGFiZWwiLCJkaXYiLCJnZXRQcm9wcyIsInN0eWxlIiwicGFkZGluZ0xlZnQiLCJnZXRJdGVtTWV0YSIsImxldmVsIiwiY2xhc3NOYW1lIiwic3BhbiIsIkhlYWRsZXNzVHJlZUxldmVsMSIsInRyZWUiLCJyb290SXRlbUlkIiwiZ2V0SXRlbU5hbWUiLCJpc0l0ZW1Gb2xkZXIiLCJkYXRhTG9hZGVyIiwiZ2V0SXRlbSIsIml0ZW1JZCIsImdldENoaWxkcmVuIiwiZmVhdHVyZXMiLCJpbml0aWFsU3RhdGUiLCJleHBhbmRlZEl0ZW1zIiwiaXRlbXMiLCJnZXRJdGVtcyIsImgxIiwicCIsImdldENvbnRhaW5lclByb3BzIiwiZ2V0SWQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/headless-tree/level-1/page.tsx\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fterecal%2Fui-interacitve-lev1%2Fmy-admin-project%2Fui-example-front%2Fsrc%2Fapp%2Fheadless-tree%2Flevel-1%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);
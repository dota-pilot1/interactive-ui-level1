"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@headless-tree";
exports.ids = ["vendor-chunks/@headless-tree"];
exports.modules = {

/***/ "(ssr)/./node_modules/@headless-tree/core/dist/index.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@headless-tree/core/dist/index.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AssistiveDndState: () => (/* binding */ AssistiveDndState),\n/* harmony export */   CheckedState: () => (/* binding */ CheckedState),\n/* harmony export */   DragTargetPosition: () => (/* binding */ DragTargetPosition),\n/* harmony export */   asyncDataLoaderFeature: () => (/* binding */ asyncDataLoaderFeature),\n/* harmony export */   buildProxiedInstance: () => (/* binding */ buildProxiedInstance),\n/* harmony export */   buildStaticInstance: () => (/* binding */ buildStaticInstance),\n/* harmony export */   checkboxesFeature: () => (/* binding */ checkboxesFeature),\n/* harmony export */   createOnDropHandler: () => (/* binding */ createOnDropHandler),\n/* harmony export */   createTree: () => (/* binding */ createTree),\n/* harmony export */   dragAndDropFeature: () => (/* binding */ dragAndDropFeature),\n/* harmony export */   expandAllFeature: () => (/* binding */ expandAllFeature),\n/* harmony export */   hotkeysCoreFeature: () => (/* binding */ hotkeysCoreFeature),\n/* harmony export */   insertItemsAtTarget: () => (/* binding */ insertItemsAtTarget),\n/* harmony export */   isOrderedDragTarget: () => (/* binding */ isOrderedDragTarget),\n/* harmony export */   keyboardDragAndDropFeature: () => (/* binding */ keyboardDragAndDropFeature),\n/* harmony export */   makeStateUpdater: () => (/* binding */ makeStateUpdater),\n/* harmony export */   propMemoizationFeature: () => (/* binding */ propMemoizationFeature),\n/* harmony export */   removeItemsFromParents: () => (/* binding */ removeItemsFromParents),\n/* harmony export */   renamingFeature: () => (/* binding */ renamingFeature),\n/* harmony export */   searchFeature: () => (/* binding */ searchFeature),\n/* harmony export */   selectionFeature: () => (/* binding */ selectionFeature),\n/* harmony export */   syncDataLoaderFeature: () => (/* binding */ syncDataLoaderFeature)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/utils.ts\nvar memo = (deps, fn) => {\n  let value;\n  let oldDeps = null;\n  return (...a) => {\n    const newDeps = deps(...a);\n    if (!value) {\n      value = fn(...newDeps);\n      oldDeps = newDeps;\n      return value;\n    }\n    const match = oldDeps && oldDeps.length === newDeps.length && !oldDeps.some((dep, i) => dep !== newDeps[i]);\n    if (match) {\n      return value;\n    }\n    value = fn(...newDeps);\n    oldDeps = newDeps;\n    return value;\n  };\n};\nfunction functionalUpdate(updater, input) {\n  return typeof updater === \"function\" ? updater(input) : updater;\n}\nfunction makeStateUpdater(key, instance) {\n  return (updater) => {\n    instance.setState((old) => {\n      return __spreadProps(__spreadValues({}, old), {\n        [key]: functionalUpdate(updater, old[key])\n      });\n    });\n  };\n}\nvar poll = (fn, interval = 100, timeout = 1e3) => new Promise((resolve) => {\n  let clear;\n  const i = setInterval(() => {\n    if (fn()) {\n      resolve();\n      clearInterval(i);\n      clearTimeout(clear);\n    }\n  }, interval);\n  clear = setTimeout(() => {\n    clearInterval(i);\n  }, timeout);\n});\n\n// src/utilities/errors.ts\nvar prefix = \"Headless Tree: \";\nvar throwError = (message) => Error(prefix + message);\nvar logWarning = (message) => console.warn(prefix + message);\n\n// src/features/tree/feature.ts\nvar treeFeature = {\n  key: \"tree\",\n  getInitialState: (initialState) => __spreadValues({\n    expandedItems: [],\n    focusedItem: null\n  }, initialState),\n  getDefaultConfig: (defaultConfig, tree) => __spreadValues({\n    setExpandedItems: makeStateUpdater(\"expandedItems\", tree),\n    setFocusedItem: makeStateUpdater(\"focusedItem\", tree)\n  }, defaultConfig),\n  stateHandlerNames: {\n    expandedItems: \"setExpandedItems\",\n    focusedItem: \"setFocusedItem\"\n  },\n  treeInstance: {\n    getItemsMeta: ({ tree }) => {\n      const { rootItemId } = tree.getConfig();\n      const { expandedItems } = tree.getState();\n      const flatItems = [];\n      const expandedItemsSet = new Set(expandedItems);\n      const recursiveAdd = (itemId, path, level, setSize, posInSet) => {\n        var _a;\n        if (path.includes(itemId)) {\n          logWarning(`Circular reference for ${path.join(\".\")}`);\n          return;\n        }\n        flatItems.push({\n          itemId,\n          level,\n          index: flatItems.length,\n          parentId: path.at(-1),\n          setSize,\n          posInSet\n        });\n        if (expandedItemsSet.has(itemId)) {\n          const children2 = (_a = tree.retrieveChildrenIds(itemId)) != null ? _a : [];\n          let i2 = 0;\n          for (const childId of children2) {\n            recursiveAdd(\n              childId,\n              path.concat(itemId),\n              level + 1,\n              children2.length,\n              i2++\n            );\n          }\n        }\n      };\n      const children = tree.retrieveChildrenIds(rootItemId);\n      let i = 0;\n      for (const itemId of children) {\n        recursiveAdd(itemId, [rootItemId], 0, children.length, i++);\n      }\n      return flatItems;\n    },\n    getFocusedItem: ({ tree }) => {\n      var _a;\n      const focusedItemId = tree.getState().focusedItem;\n      return (_a = focusedItemId !== null ? tree.getItemInstance(focusedItemId) : null) != null ? _a : tree.getItems()[0];\n    },\n    getRootItem: ({ tree }) => {\n      const { rootItemId } = tree.getConfig();\n      return tree.getItemInstance(rootItemId);\n    },\n    focusNextItem: ({ tree }) => {\n      var _a;\n      const focused = tree.getFocusedItem().getItemMeta();\n      if (!focused) return;\n      const nextIndex = Math.min(focused.index + 1, tree.getItems().length - 1);\n      (_a = tree.getItems()[nextIndex]) == null ? void 0 : _a.setFocused();\n    },\n    focusPreviousItem: ({ tree }) => {\n      var _a;\n      const focused = tree.getFocusedItem().getItemMeta();\n      if (!focused) return;\n      const nextIndex = Math.max(focused.index - 1, 0);\n      (_a = tree.getItems()[nextIndex]) == null ? void 0 : _a.setFocused();\n    },\n    updateDomFocus: ({ tree }) => {\n      setTimeout(() => __async(null, null, function* () {\n        var _a, _b;\n        const focusedItem = tree.getFocusedItem();\n        (_b = (_a = tree.getConfig()).scrollToItem) == null ? void 0 : _b.call(_a, focusedItem);\n        yield poll(() => focusedItem.getElement() !== null, 20);\n        const focusedElement = focusedItem.getElement();\n        if (!focusedElement) return;\n        focusedElement.focus();\n      }));\n    },\n    getContainerProps: ({ prev, tree }, treeLabel) => __spreadProps(__spreadValues({}, prev == null ? void 0 : prev()), {\n      role: \"tree\",\n      \"aria-label\": treeLabel != null ? treeLabel : \"\",\n      ref: tree.registerElement\n    }),\n    // relevant for hotkeys of this feature\n    isSearchOpen: () => false\n  },\n  itemInstance: {\n    scrollTo: (_0, _1) => __async(null, [_0, _1], function* ({ tree, item }, scrollIntoViewArg) {\n      var _a, _b, _c;\n      (_b = (_a = tree.getConfig()).scrollToItem) == null ? void 0 : _b.call(_a, item);\n      yield poll(() => item.getElement() !== null, 20);\n      (_c = item.getElement()) == null ? void 0 : _c.scrollIntoView(scrollIntoViewArg);\n    }),\n    getId: ({ itemId }) => itemId,\n    getKey: ({ itemId }) => itemId,\n    // TODO apply to all stories to use\n    getProps: ({ item, prev }) => {\n      const itemMeta = item.getItemMeta();\n      return __spreadProps(__spreadValues({}, prev == null ? void 0 : prev()), {\n        ref: item.registerElement,\n        role: \"treeitem\",\n        \"aria-setsize\": itemMeta.setSize,\n        \"aria-posinset\": itemMeta.posInSet + 1,\n        \"aria-selected\": \"false\",\n        \"aria-label\": item.getItemName(),\n        \"aria-level\": itemMeta.level + 1,\n        tabIndex: item.isFocused() ? 0 : -1,\n        onClick: (e) => {\n          item.setFocused();\n          item.primaryAction();\n          if (e.ctrlKey || e.shiftKey || e.metaKey) {\n            return;\n          }\n          if (!item.isFolder()) {\n            return;\n          }\n          if (item.isExpanded()) {\n            item.collapse();\n          } else {\n            item.expand();\n          }\n        }\n      });\n    },\n    expand: ({ tree, item, itemId }) => {\n      var _a;\n      if (!item.isFolder()) {\n        return;\n      }\n      if ((_a = tree.getState().loadingItemChildrens) == null ? void 0 : _a.includes(itemId)) {\n        return;\n      }\n      tree.applySubStateUpdate(\"expandedItems\", (expandedItems) => [\n        ...expandedItems,\n        itemId\n      ]);\n      tree.rebuildTree();\n    },\n    collapse: ({ tree, item, itemId }) => {\n      if (!item.isFolder()) {\n        return;\n      }\n      tree.applySubStateUpdate(\n        \"expandedItems\",\n        (expandedItems) => expandedItems.filter((id) => id !== itemId)\n      );\n      tree.rebuildTree();\n    },\n    getItemData: ({ tree, itemId }) => tree.retrieveItemData(itemId),\n    equals: ({ item }, other) => item.getId() === (other == null ? void 0 : other.getId()),\n    isExpanded: ({ tree, itemId }) => tree.getState().expandedItems.includes(itemId),\n    isDescendentOf: ({ item }, parentId) => {\n      const parent = item.getParent();\n      return Boolean(\n        (parent == null ? void 0 : parent.getId()) === parentId || (parent == null ? void 0 : parent.isDescendentOf(parentId))\n      );\n    },\n    isFocused: ({ tree, item, itemId }) => tree.getState().focusedItem === itemId || tree.getState().focusedItem === null && item.getItemMeta().index === 0,\n    isFolder: ({ tree, item }) => item.getItemMeta().level === -1 || tree.getConfig().isItemFolder(item),\n    getItemName: ({ tree, item }) => {\n      const config = tree.getConfig();\n      return config.getItemName(item);\n    },\n    setFocused: ({ tree, itemId }) => {\n      tree.applySubStateUpdate(\"focusedItem\", itemId);\n    },\n    primaryAction: ({ tree, item }) => {\n      var _a, _b;\n      return (_b = (_a = tree.getConfig()).onPrimaryAction) == null ? void 0 : _b.call(_a, item);\n    },\n    getParent: ({ tree, item }) => item.getItemMeta().parentId ? tree.getItemInstance(item.getItemMeta().parentId) : void 0,\n    getIndexInParent: ({ item }) => item.getItemMeta().posInSet,\n    getChildren: ({ tree, itemId }) => tree.retrieveChildrenIds(itemId).map((id) => tree.getItemInstance(id)),\n    getTree: ({ tree }) => tree,\n    getItemAbove: ({ tree, item }) => tree.getItems()[item.getItemMeta().index - 1],\n    getItemBelow: ({ tree, item }) => tree.getItems()[item.getItemMeta().index + 1]\n  },\n  hotkeys: {\n    focusNextItem: {\n      hotkey: \"ArrowDown\",\n      canRepeat: true,\n      preventDefault: true,\n      isEnabled: (tree) => {\n        var _a, _b;\n        return !((_b = (_a = tree.isSearchOpen) == null ? void 0 : _a.call(tree)) != null ? _b : false) && !tree.getState().dnd;\n      },\n      // TODO what happens when the feature doesnt exist? proxy method still claims to exist\n      handler: (e, tree) => {\n        tree.focusNextItem();\n        tree.updateDomFocus();\n      }\n    },\n    focusPreviousItem: {\n      hotkey: \"ArrowUp\",\n      canRepeat: true,\n      preventDefault: true,\n      isEnabled: (tree) => {\n        var _a, _b;\n        return !((_b = (_a = tree.isSearchOpen) == null ? void 0 : _a.call(tree)) != null ? _b : false) && !tree.getState().dnd;\n      },\n      handler: (e, tree) => {\n        tree.focusPreviousItem();\n        tree.updateDomFocus();\n      }\n    },\n    expandOrDown: {\n      hotkey: \"ArrowRight\",\n      canRepeat: true,\n      handler: (e, tree) => {\n        const item = tree.getFocusedItem();\n        if (item.isExpanded() || !item.isFolder()) {\n          tree.focusNextItem();\n          tree.updateDomFocus();\n        } else {\n          item.expand();\n        }\n      }\n    },\n    collapseOrUp: {\n      hotkey: \"ArrowLeft\",\n      canRepeat: true,\n      handler: (e, tree) => {\n        var _a;\n        const item = tree.getFocusedItem();\n        if ((!item.isExpanded() || !item.isFolder()) && item.getItemMeta().level !== 0) {\n          (_a = item.getParent()) == null ? void 0 : _a.setFocused();\n          tree.updateDomFocus();\n        } else {\n          item.collapse();\n        }\n      }\n    },\n    focusFirstItem: {\n      hotkey: \"Home\",\n      handler: (e, tree) => {\n        var _a;\n        (_a = tree.getItems()[0]) == null ? void 0 : _a.setFocused();\n        tree.updateDomFocus();\n      }\n    },\n    focusLastItem: {\n      hotkey: \"End\",\n      handler: (e, tree) => {\n        var _a;\n        (_a = tree.getItems()[tree.getItems().length - 1]) == null ? void 0 : _a.setFocused();\n        tree.updateDomFocus();\n      }\n    }\n  }\n};\n\n// src/core/build-static-instance.ts\nvar buildStaticInstance = (features, instanceType, buildOpts) => {\n  const instance = {};\n  const finalize = () => {\n    const opts = buildOpts(instance);\n    featureLoop: for (let i = 0; i < features.length; i++) {\n      const definition = features[i][instanceType];\n      if (!definition) continue featureLoop;\n      methodLoop: for (const [key, method] of Object.entries(definition)) {\n        if (!method) continue methodLoop;\n        const prev = instance[key];\n        instance[key] = (...args) => {\n          return method(__spreadProps(__spreadValues({}, opts), { prev }), ...args);\n        };\n      }\n    }\n  };\n  return [instance, finalize];\n};\n\n// src/core/create-tree.ts\nvar verifyFeatures = (features) => {\n  var _a;\n  const loadedFeatures = features == null ? void 0 : features.map((feature) => feature.key);\n  for (const feature of features != null ? features : []) {\n    const missingDependency = (_a = feature.deps) == null ? void 0 : _a.find(\n      (dep) => !(loadedFeatures == null ? void 0 : loadedFeatures.includes(dep))\n    );\n    if (missingDependency) {\n      throw throwError(`${feature.key} needs ${missingDependency}`);\n    }\n  }\n};\nvar exhaustiveSort = (arr, compareFn) => {\n  const n = arr.length;\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      if (compareFn(arr[j], arr[i]) < 0) {\n        [arr[i], arr[j]] = [arr[j], arr[i]];\n      }\n    }\n  }\n  return arr;\n};\nvar compareFeatures = (originalOrder) => (feature1, feature2) => {\n  var _a, _b;\n  if (feature2.key && ((_a = feature1.overwrites) == null ? void 0 : _a.includes(feature2.key))) {\n    return 1;\n  }\n  if (feature1.key && ((_b = feature2.overwrites) == null ? void 0 : _b.includes(feature1.key))) {\n    return -1;\n  }\n  return originalOrder.indexOf(feature1) - originalOrder.indexOf(feature2);\n};\nvar sortFeatures = (features = []) => exhaustiveSort(features, compareFeatures(features));\nvar createTree = (initialConfig) => {\n  var _a, _b, _c, _d;\n  const buildInstance = (_a = initialConfig.instanceBuilder) != null ? _a : buildStaticInstance;\n  const additionalFeatures = [\n    treeFeature,\n    ...sortFeatures(initialConfig.features)\n  ];\n  verifyFeatures(additionalFeatures);\n  const features = [...additionalFeatures];\n  const [treeInstance, finalizeTree] = buildInstance(\n    features,\n    \"treeInstance\",\n    (tree) => ({ tree })\n  );\n  let state = additionalFeatures.reduce(\n    (acc, feature) => {\n      var _a2, _b2;\n      return (_b2 = (_a2 = feature.getInitialState) == null ? void 0 : _a2.call(feature, acc, treeInstance)) != null ? _b2 : acc;\n    },\n    (_c = (_b = initialConfig.initialState) != null ? _b : initialConfig.state) != null ? _c : {}\n  );\n  let config = additionalFeatures.reduce(\n    (acc, feature) => {\n      var _a2, _b2;\n      return (_b2 = (_a2 = feature.getDefaultConfig) == null ? void 0 : _a2.call(feature, acc, treeInstance)) != null ? _b2 : acc;\n    },\n    initialConfig\n  );\n  const stateHandlerNames = additionalFeatures.reduce(\n    (acc, feature) => __spreadValues(__spreadValues({}, acc), feature.stateHandlerNames),\n    {}\n  );\n  let treeElement;\n  const treeDataRef = { current: {} };\n  const itemInstancesMap = {};\n  let itemInstances = [];\n  const itemElementsMap = {};\n  const itemDataRefs = {};\n  let itemMetaMap = {};\n  const hotkeyPresets = {};\n  const rebuildItemMeta = () => {\n    itemInstances = [];\n    itemMetaMap = {};\n    const [rootInstance, finalizeRootInstance] = buildInstance(\n      features,\n      \"itemInstance\",\n      (item) => ({ item, tree: treeInstance, itemId: config.rootItemId })\n    );\n    finalizeRootInstance();\n    itemInstancesMap[config.rootItemId] = rootInstance;\n    itemMetaMap[config.rootItemId] = {\n      itemId: config.rootItemId,\n      index: -1,\n      parentId: null,\n      level: -1,\n      posInSet: 0,\n      setSize: 1\n    };\n    for (const item of treeInstance.getItemsMeta()) {\n      itemMetaMap[item.itemId] = item;\n      if (!itemInstancesMap[item.itemId]) {\n        const [instance, finalizeInstance] = buildInstance(\n          features,\n          \"itemInstance\",\n          (instance2) => ({\n            item: instance2,\n            tree: treeInstance,\n            itemId: item.itemId\n          })\n        );\n        finalizeInstance();\n        itemInstancesMap[item.itemId] = instance;\n        itemInstances.push(instance);\n      } else {\n        itemInstances.push(itemInstancesMap[item.itemId]);\n      }\n    }\n  };\n  const eachFeature = (fn) => {\n    for (const feature of additionalFeatures) {\n      fn(feature);\n    }\n  };\n  const mainFeature = {\n    key: \"main\",\n    treeInstance: {\n      getState: () => state,\n      setState: ({}, updater) => {\n        var _a2;\n        (_a2 = config.setState) == null ? void 0 : _a2.call(config, state);\n      },\n      applySubStateUpdate: ({}, stateName, updater) => {\n        state[stateName] = typeof updater === \"function\" ? updater(state[stateName]) : updater;\n        const externalStateSetter = config[stateHandlerNames[stateName]];\n        externalStateSetter == null ? void 0 : externalStateSetter(state[stateName]);\n      },\n      // TODO rebuildSubTree: (itemId: string) => void;\n      rebuildTree: () => {\n        var _a2;\n        rebuildItemMeta();\n        (_a2 = config.setState) == null ? void 0 : _a2.call(config, state);\n      },\n      getConfig: () => config,\n      setConfig: (_, updater) => {\n        var _a2, _b2, _c2;\n        const newConfig = typeof updater === \"function\" ? updater(config) : updater;\n        const hasChangedExpandedItems = ((_a2 = newConfig.state) == null ? void 0 : _a2.expandedItems) && ((_b2 = newConfig.state) == null ? void 0 : _b2.expandedItems) !== state.expandedItems;\n        config = newConfig;\n        if (newConfig.state) {\n          state = __spreadValues(__spreadValues({}, state), newConfig.state);\n        }\n        if (hasChangedExpandedItems) {\n          rebuildItemMeta();\n          (_c2 = config.setState) == null ? void 0 : _c2.call(config, state);\n        }\n      },\n      getItemInstance: ({}, itemId) => {\n        const existingInstance = itemInstancesMap[itemId];\n        if (!existingInstance) {\n          const [instance, finalizeInstance] = buildInstance(\n            features,\n            \"itemInstance\",\n            (instance2) => ({\n              item: instance2,\n              tree: treeInstance,\n              itemId\n            })\n          );\n          finalizeInstance();\n          return instance;\n        }\n        return existingInstance;\n      },\n      getItems: () => itemInstances,\n      registerElement: ({}, element) => {\n        if (treeElement === element) {\n          return;\n        }\n        if (treeElement && !element) {\n          eachFeature(\n            (feature) => {\n              var _a2;\n              return (_a2 = feature.onTreeUnmount) == null ? void 0 : _a2.call(feature, treeInstance, treeElement);\n            }\n          );\n        } else if (!treeElement && element) {\n          eachFeature(\n            (feature) => {\n              var _a2;\n              return (_a2 = feature.onTreeMount) == null ? void 0 : _a2.call(feature, treeInstance, element);\n            }\n          );\n        }\n        treeElement = element;\n      },\n      getElement: () => treeElement,\n      getDataRef: () => treeDataRef,\n      getHotkeyPresets: () => hotkeyPresets\n    },\n    itemInstance: {\n      registerElement: ({ itemId, item }, element) => {\n        if (itemElementsMap[itemId] === element) {\n          return;\n        }\n        const oldElement = itemElementsMap[itemId];\n        if (oldElement && !element) {\n          eachFeature(\n            (feature) => {\n              var _a2;\n              return (_a2 = feature.onItemUnmount) == null ? void 0 : _a2.call(feature, item, oldElement, treeInstance);\n            }\n          );\n        } else if (!oldElement && element) {\n          eachFeature(\n            (feature) => {\n              var _a2;\n              return (_a2 = feature.onItemMount) == null ? void 0 : _a2.call(feature, item, element, treeInstance);\n            }\n          );\n        }\n        itemElementsMap[itemId] = element;\n      },\n      getElement: ({ itemId }) => itemElementsMap[itemId],\n      // eslint-disable-next-line no-return-assign\n      getDataRef: ({ itemId }) => {\n        var _a2;\n        return (_a2 = itemDataRefs[itemId]) != null ? _a2 : itemDataRefs[itemId] = { current: {} };\n      },\n      getItemMeta: ({ itemId }) => {\n        var _a2;\n        return (_a2 = itemMetaMap[itemId]) != null ? _a2 : {\n          itemId,\n          parentId: null,\n          level: -1,\n          index: -1,\n          posInSet: 0,\n          setSize: 1\n        };\n      }\n    }\n  };\n  features.unshift(mainFeature);\n  for (const feature of features) {\n    Object.assign(hotkeyPresets, (_d = feature.hotkeys) != null ? _d : {});\n  }\n  finalizeTree();\n  return treeInstance;\n};\n\n// src/features/drag-and-drop/types.ts\nvar DragTargetPosition = /* @__PURE__ */ ((DragTargetPosition2) => {\n  DragTargetPosition2[\"Top\"] = \"top\";\n  DragTargetPosition2[\"Bottom\"] = \"bottom\";\n  DragTargetPosition2[\"Item\"] = \"item\";\n  return DragTargetPosition2;\n})(DragTargetPosition || {});\n\n// src/features/keyboard-drag-and-drop/types.ts\nvar AssistiveDndState = /* @__PURE__ */ ((AssistiveDndState2) => {\n  AssistiveDndState2[AssistiveDndState2[\"None\"] = 0] = \"None\";\n  AssistiveDndState2[AssistiveDndState2[\"Started\"] = 1] = \"Started\";\n  AssistiveDndState2[AssistiveDndState2[\"Dragging\"] = 2] = \"Dragging\";\n  AssistiveDndState2[AssistiveDndState2[\"Completed\"] = 3] = \"Completed\";\n  AssistiveDndState2[AssistiveDndState2[\"Aborted\"] = 4] = \"Aborted\";\n  return AssistiveDndState2;\n})(AssistiveDndState || {});\n\n// src/features/checkboxes/types.ts\nvar CheckedState = /* @__PURE__ */ ((CheckedState2) => {\n  CheckedState2[\"Checked\"] = \"checked\";\n  CheckedState2[\"Unchecked\"] = \"unchecked\";\n  CheckedState2[\"Indeterminate\"] = \"indeterminate\";\n  return CheckedState2;\n})(CheckedState || {});\n\n// src/features/selection/feature.ts\nvar selectionFeature = {\n  key: \"selection\",\n  getInitialState: (initialState) => __spreadValues({\n    selectedItems: []\n  }, initialState),\n  getDefaultConfig: (defaultConfig, tree) => __spreadValues({\n    setSelectedItems: makeStateUpdater(\"selectedItems\", tree)\n  }, defaultConfig),\n  stateHandlerNames: {\n    selectedItems: \"setSelectedItems\"\n  },\n  treeInstance: {\n    setSelectedItems: ({ tree }, selectedItems) => {\n      tree.applySubStateUpdate(\"selectedItems\", selectedItems);\n    },\n    getSelectedItems: ({ tree }) => {\n      return tree.getState().selectedItems.map(tree.getItemInstance);\n    }\n  },\n  itemInstance: {\n    select: ({ tree, itemId }) => {\n      const { selectedItems } = tree.getState();\n      tree.setSelectedItems(\n        selectedItems.includes(itemId) ? selectedItems : [...selectedItems, itemId]\n      );\n    },\n    deselect: ({ tree, itemId }) => {\n      const { selectedItems } = tree.getState();\n      tree.setSelectedItems(selectedItems.filter((id) => id !== itemId));\n    },\n    isSelected: ({ tree, itemId }) => {\n      const { selectedItems } = tree.getState();\n      return selectedItems.includes(itemId);\n    },\n    selectUpTo: ({ tree, item }, ctrl) => {\n      const indexA = item.getItemMeta().index;\n      const indexB = tree.getFocusedItem().getItemMeta().index;\n      const [a, b] = indexA < indexB ? [indexA, indexB] : [indexB, indexA];\n      const newSelectedItems = tree.getItems().slice(a, b + 1).map((treeItem) => treeItem.getItemMeta().itemId);\n      if (!ctrl) {\n        tree.setSelectedItems(newSelectedItems);\n        return;\n      }\n      const { selectedItems } = tree.getState();\n      const uniqueSelectedItems = [\n        .../* @__PURE__ */ new Set([...selectedItems, ...newSelectedItems])\n      ];\n      tree.setSelectedItems(uniqueSelectedItems);\n    },\n    toggleSelect: ({ item }) => {\n      if (item.isSelected()) {\n        item.deselect();\n      } else {\n        item.select();\n      }\n    },\n    getProps: ({ tree, item, prev }) => __spreadProps(__spreadValues({}, prev == null ? void 0 : prev()), {\n      \"aria-selected\": item.isSelected() ? \"true\" : \"false\",\n      onClick: (e) => {\n        var _a, _b;\n        if (e.shiftKey) {\n          item.selectUpTo(e.ctrlKey || e.metaKey);\n        } else if (e.ctrlKey || e.metaKey) {\n          item.toggleSelect();\n        } else {\n          tree.setSelectedItems([item.getItemMeta().itemId]);\n        }\n        (_b = (_a = prev == null ? void 0 : prev()) == null ? void 0 : _a.onClick) == null ? void 0 : _b.call(_a, e);\n      }\n    })\n  },\n  hotkeys: {\n    // setSelectedItem: {\n    //   hotkey: \"space\",\n    //   handler: (e, tree) => {\n    //     tree.setSelectedItems([tree.getFocusedItem().getId()]);\n    //   },\n    // },\n    toggleSelectedItem: {\n      hotkey: \"Control+Space\",\n      preventDefault: true,\n      handler: (_, tree) => {\n        tree.getFocusedItem().toggleSelect();\n      }\n    },\n    selectUpwards: {\n      hotkey: \"Shift+ArrowUp\",\n      handler: (e, tree) => {\n        const focused = tree.getFocusedItem();\n        const above = focused.getItemAbove();\n        if (!above) return;\n        if (focused.isSelected() && above.isSelected()) {\n          focused.deselect();\n        } else {\n          above.select();\n        }\n        above.setFocused();\n        tree.updateDomFocus();\n      }\n    },\n    selectDownwards: {\n      hotkey: \"Shift+ArrowDown\",\n      handler: (e, tree) => {\n        const focused = tree.getFocusedItem();\n        const below = focused.getItemBelow();\n        if (!below) return;\n        if (focused.isSelected() && below.isSelected()) {\n          focused.deselect();\n        } else {\n          below.select();\n        }\n        below.setFocused();\n        tree.updateDomFocus();\n      }\n    },\n    selectAll: {\n      hotkey: \"Control+KeyA\",\n      preventDefault: true,\n      handler: (e, tree) => {\n        tree.setSelectedItems(tree.getItems().map((item) => item.getId()));\n      }\n    }\n  }\n};\n\n// src/features/checkboxes/feature.ts\nvar getAllLoadedDescendants = (tree, itemId, includeFolders = false) => {\n  if (!tree.getConfig().isItemFolder(tree.getItemInstance(itemId))) {\n    return [itemId];\n  }\n  const descendants = tree.retrieveChildrenIds(itemId).map((child) => getAllLoadedDescendants(tree, child, includeFolders)).flat();\n  return includeFolders ? [itemId, ...descendants] : descendants;\n};\nvar checkboxesFeature = {\n  key: \"checkboxes\",\n  overwrites: [\"selection\"],\n  getInitialState: (initialState) => __spreadValues({\n    checkedItems: []\n  }, initialState),\n  getDefaultConfig: (defaultConfig, tree) => {\n    var _a, _b, _c;\n    const hasAsyncLoader = (_a = defaultConfig.features) == null ? void 0 : _a.some(\n      (f) => f.key === \"async-data-loader\"\n    );\n    if (hasAsyncLoader && defaultConfig.propagateCheckedState) {\n      throwError(`propagateCheckedState not supported with async trees`);\n    }\n    const propagateCheckedState = (_b = defaultConfig.propagateCheckedState) != null ? _b : !hasAsyncLoader;\n    const canCheckFolders = (_c = defaultConfig.canCheckFolders) != null ? _c : !propagateCheckedState;\n    return __spreadValues({\n      setCheckedItems: makeStateUpdater(\"checkedItems\", tree),\n      propagateCheckedState,\n      canCheckFolders\n    }, defaultConfig);\n  },\n  stateHandlerNames: {\n    checkedItems: \"setCheckedItems\"\n  },\n  treeInstance: {\n    setCheckedItems: ({ tree }, checkedItems) => {\n      tree.applySubStateUpdate(\"checkedItems\", checkedItems);\n    }\n  },\n  itemInstance: {\n    getCheckboxProps: ({ item }) => {\n      const checkedState = item.getCheckedState();\n      return {\n        onChange: item.toggleCheckedState,\n        checked: checkedState === \"checked\" /* Checked */,\n        ref: (r) => {\n          if (r) {\n            r.indeterminate = checkedState === \"indeterminate\" /* Indeterminate */;\n          }\n        }\n      };\n    },\n    toggleCheckedState: ({ item }) => {\n      if (item.getCheckedState() === \"checked\" /* Checked */) {\n        item.setUnchecked();\n      } else {\n        item.setChecked();\n      }\n    },\n    getCheckedState: ({ item, tree }) => {\n      const { checkedItems } = tree.getState();\n      const { propagateCheckedState } = tree.getConfig();\n      const itemId = item.getId();\n      if (checkedItems.includes(itemId)) {\n        return \"checked\" /* Checked */;\n      }\n      if (item.isFolder() && propagateCheckedState) {\n        const descendants = getAllLoadedDescendants(tree, itemId);\n        if (descendants.every((d) => checkedItems.includes(d))) {\n          return \"checked\" /* Checked */;\n        }\n        if (descendants.some((d) => checkedItems.includes(d))) {\n          return \"indeterminate\" /* Indeterminate */;\n        }\n      }\n      return \"unchecked\" /* Unchecked */;\n    },\n    setChecked: ({ item, tree, itemId }) => {\n      const { propagateCheckedState, canCheckFolders } = tree.getConfig();\n      if (item.isFolder() && propagateCheckedState) {\n        tree.applySubStateUpdate(\"checkedItems\", (items) => [\n          ...items,\n          ...getAllLoadedDescendants(tree, itemId, canCheckFolders)\n        ]);\n      } else if (!item.isFolder() || canCheckFolders) {\n        tree.applySubStateUpdate(\"checkedItems\", (items) => [...items, itemId]);\n      }\n    },\n    setUnchecked: ({ item, tree, itemId }) => {\n      const { propagateCheckedState, canCheckFolders } = tree.getConfig();\n      if (item.isFolder() && propagateCheckedState) {\n        const descendants = getAllLoadedDescendants(\n          tree,\n          itemId,\n          canCheckFolders\n        );\n        tree.applySubStateUpdate(\n          \"checkedItems\",\n          (items) => items.filter((id) => !descendants.includes(id) && id !== itemId)\n        );\n      } else {\n        tree.applySubStateUpdate(\n          \"checkedItems\",\n          (items) => items.filter((id) => id !== itemId)\n        );\n      }\n    }\n  }\n};\n\n// src/features/hotkeys-core/feature.ts\nvar specialKeys = {\n  // TODO:breaking deprecate auto-lowercase\n  letter: /^Key[A-Z]$/,\n  letterornumber: /^(Key[A-Z]|Digit[0-9])$/,\n  plus: /^(NumpadAdd|Plus)$/,\n  minus: /^(NumpadSubtract|Minus)$/,\n  control: /^(ControlLeft|ControlRight)$/,\n  shift: /^(ShiftLeft|ShiftRight)$/\n};\nvar testHotkeyMatch = (pressedKeys, tree, hotkey) => {\n  const supposedKeys = hotkey.hotkey.toLowerCase().split(\"+\");\n  const doKeysMatch = supposedKeys.every((key) => {\n    if (key in specialKeys) {\n      return [...pressedKeys].some(\n        (pressedKey) => specialKeys[key].test(pressedKey)\n      );\n    }\n    const pressedKeysLowerCase = [...pressedKeys].map((k) => k.toLowerCase());\n    if (pressedKeysLowerCase.includes(key.toLowerCase())) {\n      return true;\n    }\n    if (pressedKeysLowerCase.includes(`key${key.toLowerCase()}`)) {\n      return true;\n    }\n    return false;\n  });\n  const isEnabled = !hotkey.isEnabled || hotkey.isEnabled(tree);\n  const equalCounts = pressedKeys.size === supposedKeys.length;\n  return doKeysMatch && isEnabled && equalCounts;\n};\nvar findHotkeyMatch = (pressedKeys, tree, config1, config2) => {\n  var _a;\n  return (_a = Object.entries(__spreadValues(__spreadValues({}, config1), config2)).find(\n    ([, hotkey]) => testHotkeyMatch(pressedKeys, tree, hotkey)\n  )) == null ? void 0 : _a[0];\n};\nvar hotkeysCoreFeature = {\n  key: \"hotkeys-core\",\n  onTreeMount: (tree, element) => {\n    const data = tree.getDataRef();\n    const keydown = (e) => {\n      var _a, _b;\n      const { ignoreHotkeysOnInputs, onTreeHotkey, hotkeys } = tree.getConfig();\n      if (e.target instanceof HTMLInputElement && ignoreHotkeysOnInputs) {\n        return;\n      }\n      (_b = (_a = data.current).pressedKeys) != null ? _b : _a.pressedKeys = /* @__PURE__ */ new Set();\n      const newMatch = !data.current.pressedKeys.has(e.code);\n      data.current.pressedKeys.add(e.code);\n      const hotkeyName = findHotkeyMatch(\n        data.current.pressedKeys,\n        tree,\n        tree.getHotkeyPresets(),\n        hotkeys\n      );\n      if (e.target instanceof HTMLInputElement) {\n        data.current.pressedKeys.delete(e.code);\n      }\n      if (!hotkeyName) return;\n      const hotkeyConfig = __spreadValues(__spreadValues({}, tree.getHotkeyPresets()[hotkeyName]), hotkeys == null ? void 0 : hotkeys[hotkeyName]);\n      if (!hotkeyConfig) return;\n      if (!hotkeyConfig.allowWhenInputFocused && e.target instanceof HTMLInputElement)\n        return;\n      if (!hotkeyConfig.canRepeat && !newMatch) return;\n      if (hotkeyConfig.preventDefault) e.preventDefault();\n      hotkeyConfig.handler(e, tree);\n      onTreeHotkey == null ? void 0 : onTreeHotkey(hotkeyName, e);\n    };\n    const keyup = (e) => {\n      var _a, _b;\n      (_b = (_a = data.current).pressedKeys) != null ? _b : _a.pressedKeys = /* @__PURE__ */ new Set();\n      data.current.pressedKeys.delete(e.code);\n    };\n    const reset = () => {\n      data.current.pressedKeys = /* @__PURE__ */ new Set();\n    };\n    element.addEventListener(\"keydown\", keydown);\n    document.addEventListener(\"keyup\", keyup);\n    window.addEventListener(\"focus\", reset);\n    data.current.keydownHandler = keydown;\n    data.current.keyupHandler = keyup;\n    data.current.resetHandler = reset;\n  },\n  onTreeUnmount: (tree, element) => {\n    const data = tree.getDataRef();\n    if (data.current.keyupHandler) {\n      document.removeEventListener(\"keyup\", data.current.keyupHandler);\n      delete data.current.keyupHandler;\n    }\n    if (data.current.keydownHandler) {\n      element.removeEventListener(\"keydown\", data.current.keydownHandler);\n      delete data.current.keydownHandler;\n    }\n    if (data.current.resetHandler) {\n      window.removeEventListener(\"focus\", data.current.resetHandler);\n      delete data.current.resetHandler;\n    }\n  }\n};\n\n// src/features/async-data-loader/feature.ts\nvar getDataRef = (tree) => {\n  var _a, _b, _c, _d;\n  const dataRef = tree.getDataRef();\n  (_b = (_a = dataRef.current).itemData) != null ? _b : _a.itemData = {};\n  (_d = (_c = dataRef.current).childrenIds) != null ? _d : _c.childrenIds = {};\n  return dataRef;\n};\nvar loadItemData = (tree, itemId) => __async(null, null, function* () {\n  var _a;\n  const config = tree.getConfig();\n  const dataRef = getDataRef(tree);\n  const item = yield config.dataLoader.getItem(itemId);\n  dataRef.current.itemData[itemId] = item;\n  (_a = config.onLoadedItem) == null ? void 0 : _a.call(config, itemId, item);\n  tree.applySubStateUpdate(\n    \"loadingItemData\",\n    (loadingItemData) => loadingItemData.filter((id) => id !== itemId)\n  );\n  return item;\n});\nvar loadChildrenIds = (tree, itemId) => __async(null, null, function* () {\n  var _a, _b;\n  const config = tree.getConfig();\n  const dataRef = getDataRef(tree);\n  let childrenIds;\n  if (\"getChildrenWithData\" in config.dataLoader) {\n    const children = yield config.dataLoader.getChildrenWithData(itemId);\n    childrenIds = children.map((c) => c.id);\n    dataRef.current.childrenIds[itemId] = childrenIds;\n    children.forEach(({ id, data }) => {\n      var _a2;\n      dataRef.current.itemData[id] = data;\n      (_a2 = config.onLoadedItem) == null ? void 0 : _a2.call(config, id, data);\n    });\n    (_a = config.onLoadedChildren) == null ? void 0 : _a.call(config, itemId, childrenIds);\n    tree.rebuildTree();\n    tree.applySubStateUpdate(\n      \"loadingItemData\",\n      (loadingItemData) => loadingItemData.filter((id) => !childrenIds.includes(id))\n    );\n  } else {\n    childrenIds = yield config.dataLoader.getChildren(itemId);\n    dataRef.current.childrenIds[itemId] = childrenIds;\n    (_b = config.onLoadedChildren) == null ? void 0 : _b.call(config, itemId, childrenIds);\n    tree.rebuildTree();\n  }\n  tree.applySubStateUpdate(\n    \"loadingItemChildrens\",\n    (loadingItemChildrens) => loadingItemChildrens.filter((id) => id !== itemId)\n  );\n  return childrenIds;\n});\nvar asyncDataLoaderFeature = {\n  key: \"async-data-loader\",\n  getInitialState: (initialState) => __spreadValues({\n    loadingItemData: [],\n    loadingItemChildrens: []\n  }, initialState),\n  getDefaultConfig: (defaultConfig, tree) => __spreadValues({\n    setLoadingItemData: makeStateUpdater(\"loadingItemData\", tree),\n    setLoadingItemChildrens: makeStateUpdater(\"loadingItemChildrens\", tree)\n  }, defaultConfig),\n  stateHandlerNames: {\n    loadingItemData: \"setLoadingItemData\",\n    loadingItemChildrens: \"setLoadingItemChildrens\"\n  },\n  treeInstance: {\n    waitForItemDataLoaded: ({ tree }, itemId) => tree.loadItemData(itemId),\n    waitForItemChildrenLoaded: ({ tree }, itemId) => tree.loadChildrenIds(itemId),\n    loadItemData: (_0, _1) => __async(null, [_0, _1], function* ({ tree }, itemId) {\n      var _a;\n      return (_a = getDataRef(tree).current.itemData[itemId]) != null ? _a : yield loadItemData(tree, itemId);\n    }),\n    loadChildrenIds: (_0, _1) => __async(null, [_0, _1], function* ({ tree }, itemId) {\n      var _a;\n      return (_a = getDataRef(tree).current.childrenIds[itemId]) != null ? _a : yield loadChildrenIds(tree, itemId);\n    }),\n    retrieveItemData: ({ tree }, itemId, skipFetch = false) => {\n      var _a, _b;\n      const config = tree.getConfig();\n      const dataRef = getDataRef(tree);\n      if (dataRef.current.itemData[itemId]) {\n        return dataRef.current.itemData[itemId];\n      }\n      if (!tree.getState().loadingItemData.includes(itemId) && !skipFetch) {\n        tree.applySubStateUpdate(\"loadingItemData\", (loadingItemData) => [\n          ...loadingItemData,\n          itemId\n        ]);\n        loadItemData(tree, itemId);\n      }\n      return (_b = (_a = config.createLoadingItemData) == null ? void 0 : _a.call(config)) != null ? _b : null;\n    },\n    retrieveChildrenIds: ({ tree }, itemId, skipFetch = false) => {\n      const dataRef = getDataRef(tree);\n      if (dataRef.current.childrenIds[itemId]) {\n        return dataRef.current.childrenIds[itemId];\n      }\n      if (tree.getState().loadingItemChildrens.includes(itemId) || skipFetch) {\n        return [];\n      }\n      tree.applySubStateUpdate(\n        \"loadingItemChildrens\",\n        (loadingItemChildrens) => [...loadingItemChildrens, itemId]\n      );\n      loadChildrenIds(tree, itemId);\n      return [];\n    }\n  },\n  itemInstance: {\n    isLoading: ({ tree, item }) => tree.getState().loadingItemData.includes(item.getItemMeta().itemId) || tree.getState().loadingItemChildrens.includes(item.getItemMeta().itemId),\n    invalidateItemData: (_0, _1) => __async(null, [_0, _1], function* ({ tree, itemId }, optimistic) {\n      var _a;\n      if (!optimistic) {\n        (_a = getDataRef(tree).current.itemData) == null ? true : delete _a[itemId];\n        tree.applySubStateUpdate(\"loadingItemData\", (loadingItemData) => [\n          ...loadingItemData,\n          itemId\n        ]);\n      }\n      yield loadItemData(tree, itemId);\n    }),\n    invalidateChildrenIds: (_0, _1) => __async(null, [_0, _1], function* ({ tree, itemId }, optimistic) {\n      var _a;\n      if (!optimistic) {\n        (_a = getDataRef(tree).current.childrenIds) == null ? true : delete _a[itemId];\n        tree.applySubStateUpdate(\n          \"loadingItemChildrens\",\n          (loadingItemChildrens) => [...loadingItemChildrens, itemId]\n        );\n      }\n      yield loadChildrenIds(tree, itemId);\n    }),\n    updateCachedChildrenIds: ({ tree, itemId }, childrenIds) => {\n      const dataRef = tree.getDataRef();\n      dataRef.current.childrenIds[itemId] = childrenIds;\n      tree.rebuildTree();\n    },\n    updateCachedData: ({ tree, itemId }, data) => {\n      const dataRef = tree.getDataRef();\n      dataRef.current.itemData[itemId] = data;\n      tree.rebuildTree();\n    }\n  }\n};\n\n// src/features/sync-data-loader/feature.ts\nvar undefErrorMessage = \"sync dataLoader returned undefined\";\nvar promiseErrorMessage = \"sync dataLoader returned promise\";\nvar unpromise = (data) => {\n  if (!data) {\n    throw throwError(undefErrorMessage);\n  }\n  if (typeof data === \"object\" && \"then\" in data) {\n    throw throwError(promiseErrorMessage);\n  }\n  return data;\n};\nvar syncDataLoaderFeature = {\n  key: \"sync-data-loader\",\n  getInitialState: (initialState) => __spreadValues({\n    loadingItemData: [],\n    loadingItemChildrens: []\n  }, initialState),\n  getDefaultConfig: (defaultConfig, tree) => __spreadValues({\n    setLoadingItemData: makeStateUpdater(\"loadingItemData\", tree),\n    setLoadingItemChildrens: makeStateUpdater(\"loadingItemChildrens\", tree)\n  }, defaultConfig),\n  stateHandlerNames: {\n    loadingItemData: \"setLoadingItemData\",\n    loadingItemChildrens: \"setLoadingItemChildrens\"\n  },\n  treeInstance: {\n    waitForItemDataLoaded: () => __async(null, null, function* () {\n    }),\n    waitForItemChildrenLoaded: () => __async(null, null, function* () {\n    }),\n    retrieveItemData: ({ tree }, itemId) => {\n      return unpromise(tree.getConfig().dataLoader.getItem(itemId));\n    },\n    retrieveChildrenIds: ({ tree }, itemId) => {\n      const { dataLoader } = tree.getConfig();\n      if (\"getChildren\" in dataLoader) {\n        return unpromise(dataLoader.getChildren(itemId));\n      }\n      return unpromise(dataLoader.getChildrenWithData(itemId)).map(\n        (c) => c.data\n      );\n    },\n    loadItemData: ({ tree }, itemId) => tree.retrieveItemData(itemId),\n    loadChildrenIds: ({ tree }, itemId) => tree.retrieveChildrenIds(itemId)\n  },\n  itemInstance: {\n    isLoading: () => false\n  }\n};\n\n// src/features/drag-and-drop/utils.ts\nvar isOrderedDragTarget = (dragTarget) => \"childIndex\" in dragTarget;\nvar canDrop = (dataTransfer, target, tree) => {\n  var _a, _b, _c;\n  const draggedItems = (_a = tree.getState().dnd) == null ? void 0 : _a.draggedItems;\n  const config = tree.getConfig();\n  if (draggedItems && !((_c = (_b = config.canDrop) == null ? void 0 : _b.call(config, draggedItems, target)) != null ? _c : true)) {\n    return false;\n  }\n  if (draggedItems && draggedItems.some(\n    (draggedItem) => target.item.getId() === draggedItem.getId() || target.item.isDescendentOf(draggedItem.getId())\n  )) {\n    return false;\n  }\n  if (!draggedItems && dataTransfer && config.canDropForeignDragObject && !config.canDropForeignDragObject(dataTransfer, target)) {\n    return false;\n  }\n  return true;\n};\nvar getItemDropCategory = (item) => {\n  if (item.isExpanded()) {\n    return 1 /* ExpandedFolder */;\n  }\n  const parent = item.getParent();\n  if (parent && item.getIndexInParent() === item.getItemMeta().setSize - 1) {\n    return 2 /* LastInGroup */;\n  }\n  return 0 /* Item */;\n};\nvar getInsertionIndex = (children, childIndex, draggedItems) => {\n  var _a;\n  const numberOfDragItemsBeforeTarget = (_a = children.slice(0, childIndex).reduce(\n    (counter, child) => child && (draggedItems == null ? void 0 : draggedItems.some((i) => i.getId() === child.getId())) ? ++counter : counter,\n    0\n  )) != null ? _a : 0;\n  return childIndex - numberOfDragItemsBeforeTarget;\n};\nvar getTargetPlacement = (e, item, tree, canMakeChild) => {\n  var _a, _b, _c, _d, _e;\n  const config = tree.getConfig();\n  if (!config.canReorder) {\n    return canMakeChild ? { type: 2 /* MakeChild */ } : { type: 1 /* ReorderBelow */ };\n  }\n  const bb = (_a = item.getElement()) == null ? void 0 : _a.getBoundingClientRect();\n  const topPercent = bb ? (e.clientY - bb.top) / bb.height : 0.5;\n  const leftPixels = bb ? e.clientX - bb.left : 0;\n  const targetDropCategory = getItemDropCategory(item);\n  const reorderAreaPercentage = !canMakeChild ? 0.5 : (_b = config.reorderAreaPercentage) != null ? _b : 0.3;\n  const indent = (_c = config.indent) != null ? _c : 20;\n  const makeChildType = canMakeChild ? 2 /* MakeChild */ : 1 /* ReorderBelow */;\n  if (targetDropCategory === 1 /* ExpandedFolder */) {\n    if (topPercent < reorderAreaPercentage) {\n      return { type: 0 /* ReorderAbove */ };\n    }\n    return { type: makeChildType };\n  }\n  if (targetDropCategory === 2 /* LastInGroup */) {\n    if (leftPixels < item.getItemMeta().level * indent) {\n      if (topPercent < 0.5) {\n        return { type: 0 /* ReorderAbove */ };\n      }\n      const minLevel = (_e = (_d = item.getItemBelow()) == null ? void 0 : _d.getItemMeta().level) != null ? _e : 0;\n      return {\n        type: 3 /* Reparent */,\n        reparentLevel: Math.max(minLevel, Math.floor(leftPixels / indent))\n      };\n    }\n  }\n  if (topPercent < reorderAreaPercentage) {\n    return { type: 0 /* ReorderAbove */ };\n  }\n  if (topPercent > 1 - reorderAreaPercentage) {\n    return { type: 1 /* ReorderBelow */ };\n  }\n  return { type: makeChildType };\n};\nvar getDragCode = (item, placement) => {\n  return [\n    item.getId(),\n    placement.type,\n    placement.type === 3 /* Reparent */ ? placement.reparentLevel : 0\n  ].join(\"__\");\n};\nvar getNthParent = (item, n) => {\n  if (n === item.getItemMeta().level) {\n    return item;\n  }\n  return getNthParent(item.getParent(), n);\n};\nvar getReparentTarget = (item, reparentLevel, draggedItems) => {\n  const itemMeta = item.getItemMeta();\n  const reparentedTarget = getNthParent(item, reparentLevel - 1);\n  const targetItemAbove = getNthParent(item, reparentLevel);\n  const targetIndex = targetItemAbove.getIndexInParent() + 1;\n  return {\n    item: reparentedTarget,\n    childIndex: targetIndex,\n    insertionIndex: getInsertionIndex(\n      reparentedTarget.getChildren(),\n      targetIndex,\n      draggedItems\n    ),\n    dragLineIndex: itemMeta.index + 1,\n    dragLineLevel: reparentLevel\n  };\n};\nvar getDragTarget = (e, item, tree, canReorder = tree.getConfig().canReorder) => {\n  var _a;\n  const draggedItems = (_a = tree.getState().dnd) == null ? void 0 : _a.draggedItems;\n  const itemMeta = item.getItemMeta();\n  const parent = item.getParent();\n  const itemTarget = { item };\n  const parentTarget = parent ? { item: parent } : null;\n  const canBecomeSibling = parentTarget && canDrop(e.dataTransfer, parentTarget, tree);\n  const canMakeChild = canDrop(e.dataTransfer, itemTarget, tree);\n  const placement = getTargetPlacement(e, item, tree, canMakeChild);\n  if (!canReorder && parent && canBecomeSibling && placement.type !== 2 /* MakeChild */) {\n    if (draggedItems == null ? void 0 : draggedItems.some((item2) => item2.isDescendentOf(parent.getId()))) {\n      return itemTarget;\n    }\n    return parentTarget;\n  }\n  if (!canReorder && parent && !canBecomeSibling) {\n    return getDragTarget(e, parent, tree, false);\n  }\n  if (!parent) {\n    return itemTarget;\n  }\n  if (placement.type === 2 /* MakeChild */) {\n    return itemTarget;\n  }\n  if (!canBecomeSibling) {\n    return getDragTarget(e, parent, tree, false);\n  }\n  if (placement.type === 3 /* Reparent */) {\n    return getReparentTarget(item, placement.reparentLevel, draggedItems);\n  }\n  const maybeAddOneForBelow = placement.type === 0 /* ReorderAbove */ ? 0 : 1;\n  const childIndex = item.getIndexInParent() + maybeAddOneForBelow;\n  return {\n    item: parent,\n    dragLineIndex: itemMeta.index + maybeAddOneForBelow,\n    dragLineLevel: itemMeta.level,\n    childIndex,\n    // TODO performance could be improved by computing this only when dragcode changed\n    insertionIndex: getInsertionIndex(\n      parent.getChildren(),\n      childIndex,\n      draggedItems\n    )\n  };\n};\n\n// src/features/drag-and-drop/feature.ts\nvar handleAutoOpenFolder = (dataRef, tree, item, placement) => {\n  const { openOnDropDelay } = tree.getConfig();\n  const dragCode = dataRef.current.lastDragCode;\n  if (!openOnDropDelay || !item.isFolder() || item.isExpanded() || placement.type !== 2 /* MakeChild */) {\n    return;\n  }\n  clearTimeout(dataRef.current.autoExpandTimeout);\n  dataRef.current.autoExpandTimeout = setTimeout(() => {\n    if (dragCode !== dataRef.current.lastDragCode || !dataRef.current.lastAllowDrop)\n      return;\n    item.expand();\n  }, openOnDropDelay);\n};\nvar defaultCanDropForeignDragObject = () => false;\nvar dragAndDropFeature = {\n  key: \"drag-and-drop\",\n  getDefaultConfig: (defaultConfig, tree) => __spreadValues({\n    canDrop: (_, target) => target.item.isFolder(),\n    canDropForeignDragObject: defaultCanDropForeignDragObject,\n    canDragForeignDragObjectOver: defaultConfig.canDropForeignDragObject !== defaultCanDropForeignDragObject ? (dataTransfer) => dataTransfer.effectAllowed !== \"none\" : () => false,\n    setDndState: makeStateUpdater(\"dnd\", tree),\n    canReorder: true,\n    openOnDropDelay: 800\n  }, defaultConfig),\n  stateHandlerNames: {\n    dnd: \"setDndState\"\n  },\n  onTreeMount: (tree) => {\n    const listener = () => {\n      tree.applySubStateUpdate(\"dnd\", null);\n    };\n    tree.getDataRef().current.windowDragEndListener = listener;\n    window.addEventListener(\"dragend\", listener);\n  },\n  onTreeUnmount: (tree) => {\n    const { windowDragEndListener } = tree.getDataRef().current;\n    if (!windowDragEndListener) return;\n    window.removeEventListener(\"dragend\", windowDragEndListener);\n  },\n  treeInstance: {\n    getDragTarget: ({ tree }) => {\n      var _a, _b;\n      return (_b = (_a = tree.getState().dnd) == null ? void 0 : _a.dragTarget) != null ? _b : null;\n    },\n    getDragLineData: ({ tree }) => {\n      var _a, _b, _c, _d, _e, _f;\n      const target = tree.getDragTarget();\n      const indent = ((_a = target == null ? void 0 : target.item.getItemMeta().level) != null ? _a : 0) + 1;\n      const treeBb = (_b = tree.getElement()) == null ? void 0 : _b.getBoundingClientRect();\n      if (!target || !treeBb || !isOrderedDragTarget(target)) return null;\n      const leftOffset = target.dragLineLevel * ((_c = tree.getConfig().indent) != null ? _c : 1);\n      const targetItem = tree.getItems()[target.dragLineIndex];\n      if (!targetItem) {\n        const bb2 = (_e = (_d = tree.getItems()[target.dragLineIndex - 1]) == null ? void 0 : _d.getElement()) == null ? void 0 : _e.getBoundingClientRect();\n        if (bb2) {\n          return {\n            indent,\n            top: bb2.bottom - treeBb.top,\n            left: bb2.left + leftOffset - treeBb.left,\n            width: bb2.width - leftOffset\n          };\n        }\n      }\n      const bb = (_f = targetItem == null ? void 0 : targetItem.getElement()) == null ? void 0 : _f.getBoundingClientRect();\n      if (bb) {\n        return {\n          indent,\n          top: bb.top - treeBb.top,\n          left: bb.left + leftOffset - treeBb.left,\n          width: bb.width - leftOffset\n        };\n      }\n      return null;\n    },\n    getDragLineStyle: ({ tree }, topOffset = -1, leftOffset = -8) => {\n      const dragLine = tree.getDragLineData();\n      return dragLine ? {\n        position: \"absolute\",\n        top: `${dragLine.top + topOffset}px`,\n        left: `${dragLine.left + leftOffset}px`,\n        width: `${dragLine.width - leftOffset}px`,\n        pointerEvents: \"none\"\n        // important to prevent capturing drag events\n      } : { display: \"none\" };\n    },\n    getContainerProps: ({ prev, tree }, treeLabel) => {\n      const prevProps = prev == null ? void 0 : prev(treeLabel);\n      return __spreadProps(__spreadValues({}, prevProps), {\n        onDragOver: (e) => {\n          e.preventDefault();\n        },\n        onDrop: (e) => __async(null, null, function* () {\n          var _a, _b, _c;\n          const dataRef = tree.getDataRef();\n          const target = { item: tree.getRootItem() };\n          if (!canDrop(e.dataTransfer, target, tree)) {\n            return;\n          }\n          e.preventDefault();\n          const config = tree.getConfig();\n          const draggedItems = (_a = tree.getState().dnd) == null ? void 0 : _a.draggedItems;\n          dataRef.current.lastDragCode = void 0;\n          if (draggedItems) {\n            yield (_b = config.onDrop) == null ? void 0 : _b.call(config, draggedItems, target);\n          } else if (e.dataTransfer) {\n            yield (_c = config.onDropForeignDragObject) == null ? void 0 : _c.call(config, e.dataTransfer, target);\n          }\n        }),\n        style: __spreadProps(__spreadValues({}, prevProps == null ? void 0 : prevProps.style), {\n          position: \"relative\"\n        })\n      });\n    }\n  },\n  itemInstance: {\n    getProps: ({ tree, item, prev }) => __spreadProps(__spreadValues({}, prev == null ? void 0 : prev()), {\n      draggable: true,\n      onDragEnter: (e) => e.preventDefault(),\n      onDragStart: (e) => {\n        var _a, _b, _c, _d;\n        const selectedItems = tree.getSelectedItems ? tree.getSelectedItems() : [tree.getFocusedItem()];\n        const items = selectedItems.includes(item) ? selectedItems : [item];\n        const config = tree.getConfig();\n        if (!selectedItems.includes(item)) {\n          (_a = tree.setSelectedItems) == null ? void 0 : _a.call(tree, [item.getItemMeta().itemId]);\n        }\n        if (!((_c = (_b = config.canDrag) == null ? void 0 : _b.call(config, items)) != null ? _c : true)) {\n          e.preventDefault();\n          return;\n        }\n        if (config.setDragImage) {\n          const { imgElement, xOffset, yOffset } = config.setDragImage(items);\n          (_d = e.dataTransfer) == null ? void 0 : _d.setDragImage(imgElement, xOffset != null ? xOffset : 0, yOffset != null ? yOffset : 0);\n        }\n        if (config.createForeignDragObject && e.dataTransfer) {\n          const { format, data, dropEffect, effectAllowed } = config.createForeignDragObject(items);\n          e.dataTransfer.setData(format, data);\n          if (dropEffect) e.dataTransfer.dropEffect = dropEffect;\n          if (effectAllowed) e.dataTransfer.effectAllowed = effectAllowed;\n        }\n        tree.applySubStateUpdate(\"dnd\", {\n          draggedItems: items,\n          draggingOverItem: tree.getFocusedItem()\n        });\n      },\n      onDragOver: (e) => {\n        var _a, _b, _c;\n        e.stopPropagation();\n        const dataRef = tree.getDataRef();\n        const placement = getTargetPlacement(e, item, tree, true);\n        const nextDragCode = getDragCode(item, placement);\n        if (nextDragCode === dataRef.current.lastDragCode) {\n          if (dataRef.current.lastAllowDrop) {\n            e.preventDefault();\n          }\n          return;\n        }\n        dataRef.current.lastDragCode = nextDragCode;\n        dataRef.current.lastDragEnter = Date.now();\n        handleAutoOpenFolder(dataRef, tree, item, placement);\n        const target = getDragTarget(e, item, tree);\n        if (!((_a = tree.getState().dnd) == null ? void 0 : _a.draggedItems) && (!e.dataTransfer || !((_c = (_b = tree.getConfig()).canDragForeignDragObjectOver) == null ? void 0 : _c.call(_b, e.dataTransfer, target)))) {\n          dataRef.current.lastAllowDrop = false;\n          return;\n        }\n        if (!canDrop(e.dataTransfer, target, tree)) {\n          dataRef.current.lastAllowDrop = false;\n          return;\n        }\n        tree.applySubStateUpdate(\"dnd\", (state) => __spreadProps(__spreadValues({}, state), {\n          dragTarget: target,\n          draggingOverItem: item\n        }));\n        dataRef.current.lastAllowDrop = true;\n        e.preventDefault();\n      },\n      onDragLeave: () => {\n        setTimeout(() => {\n          var _a;\n          const dataRef = tree.getDataRef();\n          if (((_a = dataRef.current.lastDragEnter) != null ? _a : 0) + 100 >= Date.now()) return;\n          dataRef.current.lastDragCode = \"no-drag\";\n          tree.applySubStateUpdate(\"dnd\", (state) => __spreadProps(__spreadValues({}, state), {\n            draggingOverItem: void 0,\n            dragTarget: void 0\n          }));\n        }, 100);\n      },\n      onDragEnd: (e) => {\n        var _a, _b;\n        const { onCompleteForeignDrop, canDragForeignDragObjectOver } = tree.getConfig();\n        const draggedItems = (_a = tree.getState().dnd) == null ? void 0 : _a.draggedItems;\n        if (((_b = e.dataTransfer) == null ? void 0 : _b.dropEffect) === \"none\" || !draggedItems) {\n          return;\n        }\n        const target = getDragTarget(e, item, tree);\n        if (canDragForeignDragObjectOver && e.dataTransfer && !canDragForeignDragObjectOver(e.dataTransfer, target)) {\n          return;\n        }\n        onCompleteForeignDrop == null ? void 0 : onCompleteForeignDrop(draggedItems);\n      },\n      onDrop: (e) => __async(null, null, function* () {\n        var _a, _b, _c;\n        e.stopPropagation();\n        const dataRef = tree.getDataRef();\n        const target = getDragTarget(e, item, tree);\n        const draggedItems = (_a = tree.getState().dnd) == null ? void 0 : _a.draggedItems;\n        const isValidDrop = canDrop(e.dataTransfer, target, tree);\n        tree.applySubStateUpdate(\"dnd\", {\n          draggedItems: void 0,\n          draggingOverItem: void 0,\n          dragTarget: void 0\n        });\n        if (!isValidDrop) {\n          return;\n        }\n        e.preventDefault();\n        const config = tree.getConfig();\n        dataRef.current.lastDragCode = void 0;\n        if (draggedItems) {\n          yield (_b = config.onDrop) == null ? void 0 : _b.call(config, draggedItems, target);\n        } else if (e.dataTransfer) {\n          yield (_c = config.onDropForeignDragObject) == null ? void 0 : _c.call(config, e.dataTransfer, target);\n        }\n      })\n    }),\n    isDragTarget: ({ tree, item }) => {\n      const target = tree.getDragTarget();\n      return target ? target.item.getId() === item.getId() : false;\n    },\n    isDragTargetAbove: ({ tree, item }) => {\n      const target = tree.getDragTarget();\n      if (!target || !isOrderedDragTarget(target) || target.item !== item.getParent())\n        return false;\n      return target.childIndex === item.getItemMeta().posInSet;\n    },\n    isDragTargetBelow: ({ tree, item }) => {\n      const target = tree.getDragTarget();\n      if (!target || !isOrderedDragTarget(target) || target.item !== item.getParent())\n        return false;\n      return target.childIndex - 1 === item.getItemMeta().posInSet;\n    },\n    isDraggingOver: ({ tree, item }) => {\n      var _a, _b;\n      return ((_b = (_a = tree.getState().dnd) == null ? void 0 : _a.draggingOverItem) == null ? void 0 : _b.getId()) === item.getId();\n    }\n  }\n};\n\n// src/features/keyboard-drag-and-drop/feature.ts\nvar getNextDragTarget = (tree, isUp, dragTarget) => {\n  var _a, _b, _c, _d;\n  const direction = isUp ? 0 : 1;\n  const draggedItems = (_a = tree.getState().dnd) == null ? void 0 : _a.draggedItems;\n  if (isOrderedDragTarget(dragTarget)) {\n    const parent = dragTarget.item.getParent();\n    const targetedItem = tree.getItems()[dragTarget.dragLineIndex - 1];\n    const targetCategory = targetedItem ? getItemDropCategory(targetedItem) : 0 /* Item */;\n    const maxLevel = (_b = targetedItem == null ? void 0 : targetedItem.getItemMeta().level) != null ? _b : 0;\n    const minLevel = (_d = (_c = targetedItem == null ? void 0 : targetedItem.getItemBelow()) == null ? void 0 : _c.getItemMeta().level) != null ? _d : 0;\n    if (targetCategory === 2 /* LastInGroup */) {\n      if (isUp && dragTarget.dragLineLevel < maxLevel) {\n        return getReparentTarget(\n          targetedItem,\n          dragTarget.dragLineLevel + 1,\n          draggedItems\n        );\n      }\n      if (!isUp && dragTarget.dragLineLevel > minLevel && parent) {\n        return getReparentTarget(\n          targetedItem,\n          dragTarget.dragLineLevel - 1,\n          draggedItems\n        );\n      }\n    }\n    const newIndex = dragTarget.dragLineIndex - 1 + direction;\n    const item = tree.getItems()[newIndex];\n    return item ? { item } : void 0;\n  }\n  const targetingExpandedFolder = getItemDropCategory(dragTarget.item) === 1 /* ExpandedFolder */;\n  if (targetingExpandedFolder && !isUp) {\n    return {\n      item: dragTarget.item,\n      childIndex: 0,\n      insertionIndex: getInsertionIndex(\n        dragTarget.item.getChildren(),\n        0,\n        draggedItems\n      ),\n      dragLineIndex: dragTarget.item.getItemMeta().index + direction,\n      dragLineLevel: dragTarget.item.getItemMeta().level + 1\n    };\n  }\n  const childIndex = dragTarget.item.getIndexInParent() + direction;\n  return {\n    item: dragTarget.item.getParent(),\n    childIndex,\n    insertionIndex: getInsertionIndex(\n      dragTarget.item.getParent().getChildren(),\n      childIndex,\n      draggedItems\n    ),\n    dragLineIndex: dragTarget.item.getItemMeta().index + direction,\n    dragLineLevel: dragTarget.item.getItemMeta().level\n  };\n};\nvar getNextValidDragTarget = (tree, isUp, previousTarget = ((_a) => (_a = tree.getState().dnd) == null ? void 0 : _a.dragTarget)()) => {\n  var _a2;\n  if (!previousTarget) return void 0;\n  const nextTarget = getNextDragTarget(tree, isUp, previousTarget);\n  const dataTransfer = (_a2 = tree.getDataRef().current.kDndDataTransfer) != null ? _a2 : null;\n  if (!nextTarget) return void 0;\n  if (canDrop(dataTransfer, nextTarget, tree)) {\n    return nextTarget;\n  }\n  return getNextValidDragTarget(tree, isUp, nextTarget);\n};\nvar updateScroll = (tree) => {\n  const state = tree.getState().dnd;\n  if (!(state == null ? void 0 : state.dragTarget) || isOrderedDragTarget(state.dragTarget)) return;\n  state.dragTarget.item.scrollTo({ block: \"nearest\", inline: \"nearest\" });\n};\nvar initiateDrag = (tree, draggedItems, dataTransfer) => {\n  var _a, _b;\n  const focusedItem = tree.getFocusedItem();\n  const { canDrag } = tree.getConfig();\n  if (draggedItems && canDrag && !canDrag(draggedItems)) {\n    return;\n  }\n  if (draggedItems) {\n    tree.applySubStateUpdate(\"dnd\", { draggedItems });\n    (_b = (_a = tree.getConfig()).onStartKeyboardDrag) == null ? void 0 : _b.call(_a, draggedItems);\n  } else if (dataTransfer) {\n    tree.getDataRef().current.kDndDataTransfer = dataTransfer;\n  }\n  const dragTarget = getNextValidDragTarget(tree, false, {\n    item: focusedItem\n  });\n  if (!dragTarget) return;\n  tree.applySubStateUpdate(\"dnd\", {\n    draggedItems,\n    dragTarget\n  });\n  tree.applySubStateUpdate(\"assistiveDndState\", 1 /* Started */);\n  updateScroll(tree);\n};\nvar moveDragPosition = (tree, isUp) => {\n  var _a;\n  const dragTarget = getNextValidDragTarget(tree, isUp);\n  if (!dragTarget) return;\n  tree.applySubStateUpdate(\"dnd\", {\n    draggedItems: (_a = tree.getState().dnd) == null ? void 0 : _a.draggedItems,\n    dragTarget\n  });\n  tree.applySubStateUpdate(\"assistiveDndState\", 2 /* Dragging */);\n  if (!isOrderedDragTarget(dragTarget)) {\n    dragTarget.item.setFocused();\n  }\n  updateScroll(tree);\n};\nvar keyboardDragAndDropFeature = {\n  key: \"keyboard-drag-and-drop\",\n  deps: [\"drag-and-drop\"],\n  getDefaultConfig: (defaultConfig, tree) => __spreadValues({\n    setAssistiveDndState: makeStateUpdater(\"assistiveDndState\", tree)\n  }, defaultConfig),\n  stateHandlerNames: {\n    assistiveDndState: \"setAssistiveDndState\"\n  },\n  treeInstance: {\n    startKeyboardDrag: ({ tree }, draggedItems) => {\n      initiateDrag(tree, draggedItems, void 0);\n    },\n    startKeyboardDragOnForeignObject: ({ tree }, dataTransfer) => {\n      initiateDrag(tree, void 0, dataTransfer);\n    },\n    stopKeyboardDrag: ({ tree }) => {\n      tree.getDataRef().current.kDndDataTransfer = void 0;\n      tree.applySubStateUpdate(\"dnd\", null);\n      tree.applySubStateUpdate(\"assistiveDndState\", 0 /* None */);\n    }\n  },\n  hotkeys: {\n    startDrag: {\n      hotkey: \"Control+Shift+KeyD\",\n      preventDefault: true,\n      isEnabled: (tree) => !tree.getState().dnd,\n      handler: (_, tree) => {\n        var _a, _b;\n        const selectedItems = (_b = (_a = tree.getSelectedItems) == null ? void 0 : _a.call(tree)) != null ? _b : [\n          tree.getFocusedItem()\n        ];\n        const focusedItem = tree.getFocusedItem();\n        tree.startKeyboardDrag(\n          selectedItems.includes(focusedItem) ? selectedItems : selectedItems.concat(focusedItem)\n        );\n      }\n    },\n    dragUp: {\n      hotkey: \"ArrowUp\",\n      preventDefault: true,\n      isEnabled: (tree) => !!tree.getState().dnd,\n      handler: (_, tree) => {\n        moveDragPosition(tree, true);\n      }\n    },\n    dragDown: {\n      hotkey: \"ArrowDown\",\n      preventDefault: true,\n      isEnabled: (tree) => !!tree.getState().dnd,\n      handler: (_, tree) => {\n        moveDragPosition(tree, false);\n      }\n    },\n    cancelDrag: {\n      hotkey: \"Escape\",\n      isEnabled: (tree) => !!tree.getState().dnd,\n      handler: (_, tree) => {\n        tree.stopKeyboardDrag();\n      }\n    },\n    completeDrag: {\n      hotkey: \"Enter\",\n      preventDefault: true,\n      isEnabled: (tree) => !!tree.getState().dnd,\n      handler: (e, tree) => __async(null, null, function* () {\n        var _a, _b, _c, _d;\n        e.stopPropagation();\n        const dataRef = tree.getDataRef();\n        const target = tree.getDragTarget();\n        const dataTransfer = (_a = dataRef.current.kDndDataTransfer) != null ? _a : null;\n        if (!target || !canDrop(dataTransfer, target, tree)) {\n          return;\n        }\n        const config = tree.getConfig();\n        const draggedItems = (_b = tree.getState().dnd) == null ? void 0 : _b.draggedItems;\n        dataRef.current.lastDragCode = void 0;\n        tree.applySubStateUpdate(\"dnd\", null);\n        if (draggedItems) {\n          yield (_c = config.onDrop) == null ? void 0 : _c.call(config, draggedItems, target);\n          tree.getItemInstance(draggedItems[0].getId()).setFocused();\n        } else if (dataTransfer) {\n          yield (_d = config.onDropForeignDragObject) == null ? void 0 : _d.call(config, dataTransfer, target);\n        }\n        tree.applySubStateUpdate(\n          \"assistiveDndState\",\n          3 /* Completed */\n        );\n      })\n    }\n  }\n};\n\n// src/features/search/feature.ts\nvar searchFeature = {\n  key: \"search\",\n  getInitialState: (initialState) => __spreadValues({\n    search: null\n  }, initialState),\n  getDefaultConfig: (defaultConfig, tree) => __spreadValues({\n    setSearch: makeStateUpdater(\"search\", tree),\n    isSearchMatchingItem: (search, item) => search.length > 0 && item.getItemName().toLowerCase().includes(search.toLowerCase())\n  }, defaultConfig),\n  stateHandlerNames: {\n    search: \"setSearch\"\n  },\n  treeInstance: {\n    setSearch: ({ tree }, search) => {\n      var _a;\n      tree.applySubStateUpdate(\"search\", search);\n      (_a = tree.getItems().find(\n        (item) => {\n          var _a2, _b;\n          return (_b = (_a2 = tree.getConfig()).isSearchMatchingItem) == null ? void 0 : _b.call(_a2, tree.getSearchValue(), item);\n        }\n      )) == null ? void 0 : _a.setFocused();\n    },\n    openSearch: ({ tree }, initialValue = \"\") => {\n      var _a, _b;\n      tree.setSearch(initialValue);\n      (_b = (_a = tree.getConfig()).onOpenSearch) == null ? void 0 : _b.call(_a);\n      setTimeout(() => {\n        var _a2;\n        (_a2 = tree.getDataRef().current.searchInput) == null ? void 0 : _a2.focus();\n      });\n    },\n    closeSearch: ({ tree }) => {\n      var _a, _b;\n      tree.setSearch(null);\n      (_b = (_a = tree.getConfig()).onCloseSearch) == null ? void 0 : _b.call(_a);\n      tree.updateDomFocus();\n    },\n    isSearchOpen: ({ tree }) => tree.getState().search !== null,\n    getSearchValue: ({ tree }) => tree.getState().search || \"\",\n    registerSearchInputElement: ({ tree }, element) => {\n      const dataRef = tree.getDataRef();\n      dataRef.current.searchInput = element;\n      if (element && dataRef.current.keydownHandler) {\n        element.addEventListener(\"keydown\", dataRef.current.keydownHandler);\n      }\n    },\n    getSearchInputElement: ({ tree }) => {\n      var _a;\n      return (_a = tree.getDataRef().current.searchInput) != null ? _a : null;\n    },\n    // TODO memoize with propMemoizationFeature\n    getSearchInputElementProps: ({ tree }) => ({\n      value: tree.getSearchValue(),\n      onChange: (e) => tree.setSearch(e.target.value),\n      onBlur: () => tree.closeSearch(),\n      ref: tree.registerSearchInputElement\n    }),\n    getSearchMatchingItems: memo(\n      ({ tree }) => [\n        tree.getSearchValue(),\n        tree.getItems(),\n        tree.getConfig().isSearchMatchingItem\n      ],\n      (search, items, isSearchMatchingItem) => items.filter((item) => search && (isSearchMatchingItem == null ? void 0 : isSearchMatchingItem(search, item)))\n    )\n  },\n  itemInstance: {\n    isMatchingSearch: ({ tree, item }) => tree.getSearchMatchingItems().some((i) => i.getId() === item.getId())\n  },\n  hotkeys: {\n    openSearch: {\n      hotkey: \"LetterOrNumber\",\n      preventDefault: true,\n      // TODO make true default\n      isEnabled: (tree) => !tree.isSearchOpen(),\n      handler: (e, tree) => {\n        e.stopPropagation();\n        tree.openSearch(e.key);\n      }\n    },\n    closeSearch: {\n      // TODO allow multiple, i.e. Enter\n      hotkey: \"Escape\",\n      allowWhenInputFocused: true,\n      isEnabled: (tree) => tree.isSearchOpen(),\n      handler: (e, tree) => {\n        tree.closeSearch();\n      }\n    },\n    submitSearch: {\n      hotkey: \"Enter\",\n      allowWhenInputFocused: true,\n      isEnabled: (tree) => tree.isSearchOpen(),\n      handler: (e, tree) => {\n        tree.closeSearch();\n        tree.setSelectedItems([tree.getFocusedItem().getId()]);\n      }\n    },\n    nextSearchItem: {\n      hotkey: \"ArrowDown\",\n      allowWhenInputFocused: true,\n      canRepeat: true,\n      isEnabled: (tree) => tree.isSearchOpen(),\n      handler: (e, tree) => {\n        const focusItem = tree.getSearchMatchingItems().find(\n          (item) => item.getItemMeta().index > tree.getFocusedItem().getItemMeta().index\n        );\n        focusItem == null ? void 0 : focusItem.setFocused();\n        focusItem == null ? void 0 : focusItem.scrollTo({ block: \"nearest\", inline: \"nearest\" });\n      }\n    },\n    previousSearchItem: {\n      hotkey: \"ArrowUp\",\n      allowWhenInputFocused: true,\n      canRepeat: true,\n      isEnabled: (tree) => tree.isSearchOpen(),\n      handler: (e, tree) => {\n        const focusItem = [...tree.getSearchMatchingItems()].reverse().find(\n          (item) => item.getItemMeta().index < tree.getFocusedItem().getItemMeta().index\n        );\n        focusItem == null ? void 0 : focusItem.setFocused();\n        focusItem == null ? void 0 : focusItem.scrollTo({ block: \"nearest\", inline: \"nearest\" });\n      }\n    }\n  }\n};\n\n// src/features/renaming/feature.ts\nvar renamingFeature = {\n  key: \"renaming\",\n  overwrites: [\"drag-and-drop\"],\n  getDefaultConfig: (defaultConfig, tree) => __spreadValues({\n    setRenamingItem: makeStateUpdater(\"renamingItem\", tree),\n    setRenamingValue: makeStateUpdater(\"renamingValue\", tree),\n    canRename: () => true\n  }, defaultConfig),\n  stateHandlerNames: {\n    renamingItem: \"setRenamingItem\",\n    renamingValue: \"setRenamingValue\"\n  },\n  treeInstance: {\n    getRenamingItem: ({ tree }) => {\n      const itemId = tree.getState().renamingItem;\n      return itemId ? tree.getItemInstance(itemId) : null;\n    },\n    getRenamingValue: ({ tree }) => tree.getState().renamingValue || \"\",\n    abortRenaming: ({ tree }) => {\n      tree.applySubStateUpdate(\"renamingItem\", null);\n      tree.updateDomFocus();\n    },\n    completeRenaming: ({ tree }) => {\n      var _a;\n      const config = tree.getConfig();\n      const item = tree.getRenamingItem();\n      if (item) {\n        (_a = config.onRename) == null ? void 0 : _a.call(config, item, tree.getState().renamingValue || \"\");\n      }\n      tree.applySubStateUpdate(\"renamingItem\", null);\n      tree.updateDomFocus();\n    },\n    isRenamingItem: ({ tree }) => !!tree.getState().renamingItem\n  },\n  itemInstance: {\n    startRenaming: ({ tree, item, itemId }) => {\n      if (!item.canRename()) {\n        return;\n      }\n      tree.applySubStateUpdate(\"renamingItem\", itemId);\n      tree.applySubStateUpdate(\"renamingValue\", item.getItemName());\n    },\n    getRenameInputProps: ({ tree }) => ({\n      ref: (r) => r == null ? void 0 : r.focus(),\n      onBlur: () => tree.abortRenaming(),\n      value: tree.getRenamingValue(),\n      onChange: (e) => {\n        var _a;\n        tree.applySubStateUpdate(\"renamingValue\", (_a = e.target) == null ? void 0 : _a.value);\n      }\n    }),\n    canRename: ({ tree, item }) => {\n      var _a, _b, _c;\n      return (_c = (_b = (_a = tree.getConfig()).canRename) == null ? void 0 : _b.call(_a, item)) != null ? _c : true;\n    },\n    isRenaming: ({ tree, item }) => item.getId() === tree.getState().renamingItem,\n    getProps: ({ prev, item }) => {\n      var _a;\n      const isRenaming = item.isRenaming();\n      const prevProps = (_a = prev == null ? void 0 : prev()) != null ? _a : {};\n      return isRenaming ? __spreadProps(__spreadValues({}, prevProps), {\n        draggable: false,\n        onDragStart: () => {\n        }\n      }) : prevProps;\n    }\n  },\n  hotkeys: {\n    renameItem: {\n      hotkey: \"F2\",\n      handler: (e, tree) => {\n        tree.getFocusedItem().startRenaming();\n      }\n    },\n    abortRenaming: {\n      hotkey: \"Escape\",\n      allowWhenInputFocused: true,\n      isEnabled: (tree) => tree.isRenamingItem(),\n      handler: (e, tree) => {\n        tree.abortRenaming();\n      }\n    },\n    completeRenaming: {\n      hotkey: \"Enter\",\n      allowWhenInputFocused: true,\n      isEnabled: (tree) => tree.isRenamingItem(),\n      handler: (e, tree) => {\n        tree.completeRenaming();\n      }\n    }\n  }\n};\n\n// src/features/expand-all/feature.ts\nvar expandAllFeature = {\n  key: \"expand-all\",\n  treeInstance: {\n    expandAll: (_0, _1) => __async(null, [_0, _1], function* ({ tree }, cancelToken) {\n      yield Promise.all(\n        tree.getItems().map((item) => item.expandAll(cancelToken))\n      );\n    }),\n    collapseAll: ({ tree }) => {\n      tree.applySubStateUpdate(\"expandedItems\", []);\n      tree.rebuildTree();\n    }\n  },\n  itemInstance: {\n    expandAll: (_0, _1) => __async(null, [_0, _1], function* ({ tree, item }, cancelToken) {\n      if (cancelToken == null ? void 0 : cancelToken.current) {\n        return;\n      }\n      if (!item.isFolder()) {\n        return;\n      }\n      item.expand();\n      yield tree.waitForItemChildrenLoaded(item.getId());\n      yield Promise.all(\n        item.getChildren().map((child) => __async(null, null, function* () {\n          yield tree.waitForItemChildrenLoaded(item.getId());\n          yield child == null ? void 0 : child.expandAll(cancelToken);\n        }))\n      );\n    }),\n    collapseAll: ({ item }) => {\n      if (!item.isExpanded()) return;\n      for (const child of item.getChildren()) {\n        child == null ? void 0 : child.collapseAll();\n      }\n      item.collapse();\n    }\n  },\n  hotkeys: {\n    expandSelected: {\n      hotkey: \"Control+Shift+Plus\",\n      handler: (_, tree) => __async(null, null, function* () {\n        const cancelToken = { current: false };\n        const cancelHandler = (e) => {\n          if (e.code === \"Escape\") {\n            cancelToken.current = true;\n          }\n        };\n        document.addEventListener(\"keydown\", cancelHandler);\n        yield Promise.all(\n          tree.getSelectedItems().map((item) => item.expandAll(cancelToken))\n        );\n        document.removeEventListener(\"keydown\", cancelHandler);\n      })\n    },\n    collapseSelected: {\n      hotkey: \"Control+Shift+Minus\",\n      handler: (_, tree) => {\n        tree.getSelectedItems().forEach((item) => item.collapseAll());\n      }\n    }\n  }\n};\n\n// src/features/prop-memoization/feature.ts\nvar memoize = (props, memoizedProps) => {\n  for (const key in props) {\n    if (typeof props[key] === \"function\") {\n      if (memoizedProps && key in memoizedProps) {\n        props[key] = memoizedProps[key];\n      } else {\n        memoizedProps[key] = props[key];\n      }\n    }\n  }\n  return props;\n};\nvar propMemoizationFeature = {\n  key: \"prop-memoization\",\n  overwrites: [\n    \"main\",\n    \"async-data-loader\",\n    \"sync-data-loader\",\n    \"drag-and-drop\",\n    \"expand-all\",\n    \"hotkeys-core\",\n    \"renaming\",\n    \"search\",\n    \"selection\"\n  ],\n  treeInstance: {\n    getContainerProps: ({ tree, prev }, treeLabel) => {\n      var _a, _b, _c, _d, _e;\n      const dataRef = tree.getDataRef();\n      const props = (_a = prev == null ? void 0 : prev(treeLabel)) != null ? _a : {};\n      (_c = (_b = dataRef.current).memo) != null ? _c : _b.memo = {};\n      (_e = (_d = dataRef.current.memo).tree) != null ? _e : _d.tree = {};\n      return memoize(props, dataRef.current.memo.tree);\n    },\n    getSearchInputElementProps: ({ tree, prev }) => {\n      var _a, _b, _c, _d, _e;\n      const dataRef = tree.getDataRef();\n      const props = (_a = prev == null ? void 0 : prev()) != null ? _a : {};\n      (_c = (_b = dataRef.current).memo) != null ? _c : _b.memo = {};\n      (_e = (_d = dataRef.current.memo).search) != null ? _e : _d.search = {};\n      return memoize(props, dataRef.current.memo.search);\n    }\n  },\n  itemInstance: {\n    getProps: ({ item, prev }) => {\n      var _a, _b, _c, _d, _e;\n      const dataRef = item.getDataRef();\n      const props = (_a = prev == null ? void 0 : prev()) != null ? _a : {};\n      (_c = (_b = dataRef.current).memo) != null ? _c : _b.memo = {};\n      (_e = (_d = dataRef.current.memo).item) != null ? _e : _d.item = {};\n      return memoize(props, dataRef.current.memo.item);\n    },\n    getRenameInputProps: ({ item, prev }) => {\n      var _a, _b, _c, _d, _e;\n      const dataRef = item.getDataRef();\n      const props = (_a = prev == null ? void 0 : prev()) != null ? _a : {};\n      (_c = (_b = dataRef.current).memo) != null ? _c : _b.memo = {};\n      (_e = (_d = dataRef.current.memo).rename) != null ? _e : _d.rename = {};\n      return memoize(props, dataRef.current.memo.rename);\n    }\n  }\n};\n\n// src/utilities/remove-items-from-parents.ts\nvar removeItemsFromParents = (movedItems, onChangeChildren) => __async(null, null, function* () {\n  const movedItemsIds = movedItems.map((item) => item.getId());\n  const uniqueParents = [\n    ...new Set(movedItems.map((item) => item.getParent()))\n  ];\n  for (const parent of uniqueParents) {\n    const siblings = parent == null ? void 0 : parent.getChildren();\n    if (siblings && parent) {\n      const newChildren = siblings.filter((sibling) => !movedItemsIds.includes(sibling.getId())).map((i) => i.getId());\n      yield onChangeChildren(parent, newChildren);\n      if (parent && \"updateCachedChildrenIds\" in parent) {\n        parent == null ? void 0 : parent.updateCachedChildrenIds(newChildren);\n      }\n    }\n  }\n  movedItems[0].getTree().rebuildTree();\n});\n\n// src/utilities/insert-items-at-target.ts\nvar insertItemsAtTarget = (itemIds, target, onChangeChildren) => __async(null, null, function* () {\n  yield target.item.getTree().waitForItemChildrenLoaded(target.item.getId());\n  const oldChildrenIds = target.item.getTree().retrieveChildrenIds(target.item.getId());\n  if (!(\"childIndex\" in target)) {\n    const newChildren2 = [...oldChildrenIds, ...itemIds];\n    yield onChangeChildren(target.item, newChildren2);\n    if (target.item && \"updateCachedChildrenIds\" in target.item) {\n      target.item.updateCachedChildrenIds(newChildren2);\n    }\n    target.item.getTree().rebuildTree();\n    return;\n  }\n  const newChildren = [\n    ...oldChildrenIds.slice(0, target.insertionIndex),\n    ...itemIds,\n    ...oldChildrenIds.slice(target.insertionIndex)\n  ];\n  yield onChangeChildren(target.item, newChildren);\n  if (target.item && \"updateCachedChildrenIds\" in target.item) {\n    target.item.updateCachedChildrenIds(newChildren);\n  }\n  target.item.getTree().rebuildTree();\n});\n\n// src/utilities/create-on-drop-handler.ts\nvar createOnDropHandler = (onChangeChildren) => (items, target) => __async(null, null, function* () {\n  const itemIds = items.map((item) => item.getId());\n  yield removeItemsFromParents(items, onChangeChildren);\n  yield insertItemsAtTarget(itemIds, target, onChangeChildren);\n});\n\n// src/core/build-proxified-instance.ts\nvar noop = () => {\n};\nvar findPrevInstanceMethod = (features, instanceType, methodKey, featureSearchIndex) => {\n  var _a;\n  for (let i = featureSearchIndex; i >= 0; i--) {\n    const feature = features[i];\n    const itemInstanceMethod = (_a = feature[instanceType]) == null ? void 0 : _a[methodKey];\n    if (itemInstanceMethod) {\n      return i;\n    }\n  }\n  return null;\n};\nvar invokeInstanceMethod = (features, instanceType, opts, methodKey, featureIndex, args) => {\n  var _a;\n  const prevIndex = findPrevInstanceMethod(\n    features,\n    instanceType,\n    methodKey,\n    featureIndex - 1\n  );\n  const itemInstanceMethod = (_a = features[featureIndex][instanceType]) == null ? void 0 : _a[methodKey];\n  return itemInstanceMethod(\n    __spreadProps(__spreadValues({}, opts), {\n      prev: prevIndex !== null ? (...newArgs) => invokeInstanceMethod(\n        features,\n        instanceType,\n        opts,\n        methodKey,\n        prevIndex,\n        newArgs\n      ) : null\n    }),\n    ...args\n  );\n};\nvar buildProxiedInstance = (features, instanceType, buildOpts) => {\n  const opts = {};\n  const item = new Proxy(\n    {},\n    {\n      has(target, key) {\n        if (typeof key === \"symbol\") {\n          return false;\n        }\n        if (key === \"toJSON\") {\n          return false;\n        }\n        const hasInstanceMethod = findPrevInstanceMethod(\n          features,\n          instanceType,\n          key,\n          features.length - 1\n        );\n        return Boolean(hasInstanceMethod);\n      },\n      get(target, key) {\n        if (typeof key === \"symbol\") {\n          return void 0;\n        }\n        if (key === \"toJSON\") {\n          return {};\n        }\n        return (...args) => {\n          const featureIndex = findPrevInstanceMethod(\n            features,\n            instanceType,\n            key,\n            features.length - 1\n          );\n          if (featureIndex === null) {\n            throw throwError(`feature missing for method ${key}`);\n          }\n          return invokeInstanceMethod(\n            features,\n            instanceType,\n            opts,\n            key,\n            featureIndex,\n            args\n          );\n        };\n      }\n    }\n  );\n  Object.assign(opts, buildOpts(item));\n  return [item, noop];\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGhlYWRsZXNzLXRyZWUvY29yZS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EscUJBQXFCLE1BQU07QUFDM0IsY0FBYyxhQUFhO0FBQzNCLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZUFBZTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsWUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsbUNBQW1DLFlBQVk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxJQUFJO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBd0JFIiwic291cmNlcyI6WyIvVXNlcnMvdGVyZWNhbC91aS1pbnRlcmFjaXR2ZS1sZXYxL215LWFkbWluLXByb2plY3QvdWktZXhhbXBsZS1mcm9udC9ub2RlX21vZHVsZXMvQGhlYWRsZXNzLXRyZWUvY29yZS9kaXN0L2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbnZhciBfX2FzeW5jID0gKF9fdGhpcywgX19hcmd1bWVudHMsIGdlbmVyYXRvcikgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHZhciBmdWxmaWxsZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlamVjdGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci50aHJvdyh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgc3RlcCA9ICh4KSA9PiB4LmRvbmUgPyByZXNvbHZlKHgudmFsdWUpIDogUHJvbWlzZS5yZXNvbHZlKHgudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KF9fdGhpcywgX19hcmd1bWVudHMpKS5uZXh0KCkpO1xuICB9KTtcbn07XG5cbi8vIHNyYy91dGlscy50c1xudmFyIG1lbW8gPSAoZGVwcywgZm4pID0+IHtcbiAgbGV0IHZhbHVlO1xuICBsZXQgb2xkRGVwcyA9IG51bGw7XG4gIHJldHVybiAoLi4uYSkgPT4ge1xuICAgIGNvbnN0IG5ld0RlcHMgPSBkZXBzKC4uLmEpO1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHZhbHVlID0gZm4oLi4ubmV3RGVwcyk7XG4gICAgICBvbGREZXBzID0gbmV3RGVwcztcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgbWF0Y2ggPSBvbGREZXBzICYmIG9sZERlcHMubGVuZ3RoID09PSBuZXdEZXBzLmxlbmd0aCAmJiAhb2xkRGVwcy5zb21lKChkZXAsIGkpID0+IGRlcCAhPT0gbmV3RGVwc1tpXSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHZhbHVlID0gZm4oLi4ubmV3RGVwcyk7XG4gICAgb2xkRGVwcyA9IG5ld0RlcHM7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufTtcbmZ1bmN0aW9uIGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgaW5wdXQpIHtcbiAgcmV0dXJuIHR5cGVvZiB1cGRhdGVyID09PSBcImZ1bmN0aW9uXCIgPyB1cGRhdGVyKGlucHV0KSA6IHVwZGF0ZXI7XG59XG5mdW5jdGlvbiBtYWtlU3RhdGVVcGRhdGVyKGtleSwgaW5zdGFuY2UpIHtcbiAgcmV0dXJuICh1cGRhdGVyKSA9PiB7XG4gICAgaW5zdGFuY2Uuc2V0U3RhdGUoKG9sZCkgPT4ge1xuICAgICAgcmV0dXJuIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9sZCksIHtcbiAgICAgICAgW2tleV06IGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgb2xkW2tleV0pXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn1cbnZhciBwb2xsID0gKGZuLCBpbnRlcnZhbCA9IDEwMCwgdGltZW91dCA9IDFlMykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgbGV0IGNsZWFyO1xuICBjb25zdCBpID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgIGlmIChmbigpKSB7XG4gICAgICByZXNvbHZlKCk7XG4gICAgICBjbGVhckludGVydmFsKGkpO1xuICAgICAgY2xlYXJUaW1lb3V0KGNsZWFyKTtcbiAgICB9XG4gIH0sIGludGVydmFsKTtcbiAgY2xlYXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBjbGVhckludGVydmFsKGkpO1xuICB9LCB0aW1lb3V0KTtcbn0pO1xuXG4vLyBzcmMvdXRpbGl0aWVzL2Vycm9ycy50c1xudmFyIHByZWZpeCA9IFwiSGVhZGxlc3MgVHJlZTogXCI7XG52YXIgdGhyb3dFcnJvciA9IChtZXNzYWdlKSA9PiBFcnJvcihwcmVmaXggKyBtZXNzYWdlKTtcbnZhciBsb2dXYXJuaW5nID0gKG1lc3NhZ2UpID0+IGNvbnNvbGUud2FybihwcmVmaXggKyBtZXNzYWdlKTtcblxuLy8gc3JjL2ZlYXR1cmVzL3RyZWUvZmVhdHVyZS50c1xudmFyIHRyZWVGZWF0dXJlID0ge1xuICBrZXk6IFwidHJlZVwiLFxuICBnZXRJbml0aWFsU3RhdGU6IChpbml0aWFsU3RhdGUpID0+IF9fc3ByZWFkVmFsdWVzKHtcbiAgICBleHBhbmRlZEl0ZW1zOiBbXSxcbiAgICBmb2N1c2VkSXRlbTogbnVsbFxuICB9LCBpbml0aWFsU3RhdGUpLFxuICBnZXREZWZhdWx0Q29uZmlnOiAoZGVmYXVsdENvbmZpZywgdHJlZSkgPT4gX19zcHJlYWRWYWx1ZXMoe1xuICAgIHNldEV4cGFuZGVkSXRlbXM6IG1ha2VTdGF0ZVVwZGF0ZXIoXCJleHBhbmRlZEl0ZW1zXCIsIHRyZWUpLFxuICAgIHNldEZvY3VzZWRJdGVtOiBtYWtlU3RhdGVVcGRhdGVyKFwiZm9jdXNlZEl0ZW1cIiwgdHJlZSlcbiAgfSwgZGVmYXVsdENvbmZpZyksXG4gIHN0YXRlSGFuZGxlck5hbWVzOiB7XG4gICAgZXhwYW5kZWRJdGVtczogXCJzZXRFeHBhbmRlZEl0ZW1zXCIsXG4gICAgZm9jdXNlZEl0ZW06IFwic2V0Rm9jdXNlZEl0ZW1cIlxuICB9LFxuICB0cmVlSW5zdGFuY2U6IHtcbiAgICBnZXRJdGVtc01ldGE6ICh7IHRyZWUgfSkgPT4ge1xuICAgICAgY29uc3QgeyByb290SXRlbUlkIH0gPSB0cmVlLmdldENvbmZpZygpO1xuICAgICAgY29uc3QgeyBleHBhbmRlZEl0ZW1zIH0gPSB0cmVlLmdldFN0YXRlKCk7XG4gICAgICBjb25zdCBmbGF0SXRlbXMgPSBbXTtcbiAgICAgIGNvbnN0IGV4cGFuZGVkSXRlbXNTZXQgPSBuZXcgU2V0KGV4cGFuZGVkSXRlbXMpO1xuICAgICAgY29uc3QgcmVjdXJzaXZlQWRkID0gKGl0ZW1JZCwgcGF0aCwgbGV2ZWwsIHNldFNpemUsIHBvc0luU2V0KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHBhdGguaW5jbHVkZXMoaXRlbUlkKSkge1xuICAgICAgICAgIGxvZ1dhcm5pbmcoYENpcmN1bGFyIHJlZmVyZW5jZSBmb3IgJHtwYXRoLmpvaW4oXCIuXCIpfWApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmbGF0SXRlbXMucHVzaCh7XG4gICAgICAgICAgaXRlbUlkLFxuICAgICAgICAgIGxldmVsLFxuICAgICAgICAgIGluZGV4OiBmbGF0SXRlbXMubGVuZ3RoLFxuICAgICAgICAgIHBhcmVudElkOiBwYXRoLmF0KC0xKSxcbiAgICAgICAgICBzZXRTaXplLFxuICAgICAgICAgIHBvc0luU2V0XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZXhwYW5kZWRJdGVtc1NldC5oYXMoaXRlbUlkKSkge1xuICAgICAgICAgIGNvbnN0IGNoaWxkcmVuMiA9IChfYSA9IHRyZWUucmV0cmlldmVDaGlsZHJlbklkcyhpdGVtSWQpKSAhPSBudWxsID8gX2EgOiBbXTtcbiAgICAgICAgICBsZXQgaTIgPSAwO1xuICAgICAgICAgIGZvciAoY29uc3QgY2hpbGRJZCBvZiBjaGlsZHJlbjIpIHtcbiAgICAgICAgICAgIHJlY3Vyc2l2ZUFkZChcbiAgICAgICAgICAgICAgY2hpbGRJZCxcbiAgICAgICAgICAgICAgcGF0aC5jb25jYXQoaXRlbUlkKSxcbiAgICAgICAgICAgICAgbGV2ZWwgKyAxLFxuICAgICAgICAgICAgICBjaGlsZHJlbjIubGVuZ3RoLFxuICAgICAgICAgICAgICBpMisrXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gdHJlZS5yZXRyaWV2ZUNoaWxkcmVuSWRzKHJvb3RJdGVtSWQpO1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChjb25zdCBpdGVtSWQgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgcmVjdXJzaXZlQWRkKGl0ZW1JZCwgW3Jvb3RJdGVtSWRdLCAwLCBjaGlsZHJlbi5sZW5ndGgsIGkrKyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmxhdEl0ZW1zO1xuICAgIH0sXG4gICAgZ2V0Rm9jdXNlZEl0ZW06ICh7IHRyZWUgfSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgZm9jdXNlZEl0ZW1JZCA9IHRyZWUuZ2V0U3RhdGUoKS5mb2N1c2VkSXRlbTtcbiAgICAgIHJldHVybiAoX2EgPSBmb2N1c2VkSXRlbUlkICE9PSBudWxsID8gdHJlZS5nZXRJdGVtSW5zdGFuY2UoZm9jdXNlZEl0ZW1JZCkgOiBudWxsKSAhPSBudWxsID8gX2EgOiB0cmVlLmdldEl0ZW1zKClbMF07XG4gICAgfSxcbiAgICBnZXRSb290SXRlbTogKHsgdHJlZSB9KSA9PiB7XG4gICAgICBjb25zdCB7IHJvb3RJdGVtSWQgfSA9IHRyZWUuZ2V0Q29uZmlnKCk7XG4gICAgICByZXR1cm4gdHJlZS5nZXRJdGVtSW5zdGFuY2Uocm9vdEl0ZW1JZCk7XG4gICAgfSxcbiAgICBmb2N1c05leHRJdGVtOiAoeyB0cmVlIH0pID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGZvY3VzZWQgPSB0cmVlLmdldEZvY3VzZWRJdGVtKCkuZ2V0SXRlbU1ldGEoKTtcbiAgICAgIGlmICghZm9jdXNlZCkgcmV0dXJuO1xuICAgICAgY29uc3QgbmV4dEluZGV4ID0gTWF0aC5taW4oZm9jdXNlZC5pbmRleCArIDEsIHRyZWUuZ2V0SXRlbXMoKS5sZW5ndGggLSAxKTtcbiAgICAgIChfYSA9IHRyZWUuZ2V0SXRlbXMoKVtuZXh0SW5kZXhdKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2V0Rm9jdXNlZCgpO1xuICAgIH0sXG4gICAgZm9jdXNQcmV2aW91c0l0ZW06ICh7IHRyZWUgfSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgZm9jdXNlZCA9IHRyZWUuZ2V0Rm9jdXNlZEl0ZW0oKS5nZXRJdGVtTWV0YSgpO1xuICAgICAgaWYgKCFmb2N1c2VkKSByZXR1cm47XG4gICAgICBjb25zdCBuZXh0SW5kZXggPSBNYXRoLm1heChmb2N1c2VkLmluZGV4IC0gMSwgMCk7XG4gICAgICAoX2EgPSB0cmVlLmdldEl0ZW1zKClbbmV4dEluZGV4XSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNldEZvY3VzZWQoKTtcbiAgICB9LFxuICAgIHVwZGF0ZURvbUZvY3VzOiAoeyB0cmVlIH0pID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gX19hc3luYyhudWxsLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBmb2N1c2VkSXRlbSA9IHRyZWUuZ2V0Rm9jdXNlZEl0ZW0oKTtcbiAgICAgICAgKF9iID0gKF9hID0gdHJlZS5nZXRDb25maWcoKSkuc2Nyb2xsVG9JdGVtKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgZm9jdXNlZEl0ZW0pO1xuICAgICAgICB5aWVsZCBwb2xsKCgpID0+IGZvY3VzZWRJdGVtLmdldEVsZW1lbnQoKSAhPT0gbnVsbCwgMjApO1xuICAgICAgICBjb25zdCBmb2N1c2VkRWxlbWVudCA9IGZvY3VzZWRJdGVtLmdldEVsZW1lbnQoKTtcbiAgICAgICAgaWYgKCFmb2N1c2VkRWxlbWVudCkgcmV0dXJuO1xuICAgICAgICBmb2N1c2VkRWxlbWVudC5mb2N1cygpO1xuICAgICAgfSkpO1xuICAgIH0sXG4gICAgZ2V0Q29udGFpbmVyUHJvcHM6ICh7IHByZXYsIHRyZWUgfSwgdHJlZUxhYmVsKSA9PiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBwcmV2ID09IG51bGwgPyB2b2lkIDAgOiBwcmV2KCkpLCB7XG4gICAgICByb2xlOiBcInRyZWVcIixcbiAgICAgIFwiYXJpYS1sYWJlbFwiOiB0cmVlTGFiZWwgIT0gbnVsbCA/IHRyZWVMYWJlbCA6IFwiXCIsXG4gICAgICByZWY6IHRyZWUucmVnaXN0ZXJFbGVtZW50XG4gICAgfSksXG4gICAgLy8gcmVsZXZhbnQgZm9yIGhvdGtleXMgb2YgdGhpcyBmZWF0dXJlXG4gICAgaXNTZWFyY2hPcGVuOiAoKSA9PiBmYWxzZVxuICB9LFxuICBpdGVtSW5zdGFuY2U6IHtcbiAgICBzY3JvbGxUbzogKF8wLCBfMSkgPT4gX19hc3luYyhudWxsLCBbXzAsIF8xXSwgZnVuY3Rpb24qICh7IHRyZWUsIGl0ZW0gfSwgc2Nyb2xsSW50b1ZpZXdBcmcpIHtcbiAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgKF9iID0gKF9hID0gdHJlZS5nZXRDb25maWcoKSkuc2Nyb2xsVG9JdGVtKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgaXRlbSk7XG4gICAgICB5aWVsZCBwb2xsKCgpID0+IGl0ZW0uZ2V0RWxlbWVudCgpICE9PSBudWxsLCAyMCk7XG4gICAgICAoX2MgPSBpdGVtLmdldEVsZW1lbnQoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnNjcm9sbEludG9WaWV3KHNjcm9sbEludG9WaWV3QXJnKTtcbiAgICB9KSxcbiAgICBnZXRJZDogKHsgaXRlbUlkIH0pID0+IGl0ZW1JZCxcbiAgICBnZXRLZXk6ICh7IGl0ZW1JZCB9KSA9PiBpdGVtSWQsXG4gICAgLy8gVE9ETyBhcHBseSB0byBhbGwgc3RvcmllcyB0byB1c2VcbiAgICBnZXRQcm9wczogKHsgaXRlbSwgcHJldiB9KSA9PiB7XG4gICAgICBjb25zdCBpdGVtTWV0YSA9IGl0ZW0uZ2V0SXRlbU1ldGEoKTtcbiAgICAgIHJldHVybiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBwcmV2ID09IG51bGwgPyB2b2lkIDAgOiBwcmV2KCkpLCB7XG4gICAgICAgIHJlZjogaXRlbS5yZWdpc3RlckVsZW1lbnQsXG4gICAgICAgIHJvbGU6IFwidHJlZWl0ZW1cIixcbiAgICAgICAgXCJhcmlhLXNldHNpemVcIjogaXRlbU1ldGEuc2V0U2l6ZSxcbiAgICAgICAgXCJhcmlhLXBvc2luc2V0XCI6IGl0ZW1NZXRhLnBvc0luU2V0ICsgMSxcbiAgICAgICAgXCJhcmlhLXNlbGVjdGVkXCI6IFwiZmFsc2VcIixcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IGl0ZW0uZ2V0SXRlbU5hbWUoKSxcbiAgICAgICAgXCJhcmlhLWxldmVsXCI6IGl0ZW1NZXRhLmxldmVsICsgMSxcbiAgICAgICAgdGFiSW5kZXg6IGl0ZW0uaXNGb2N1c2VkKCkgPyAwIDogLTEsXG4gICAgICAgIG9uQ2xpY2s6IChlKSA9PiB7XG4gICAgICAgICAgaXRlbS5zZXRGb2N1c2VkKCk7XG4gICAgICAgICAgaXRlbS5wcmltYXJ5QWN0aW9uKCk7XG4gICAgICAgICAgaWYgKGUuY3RybEtleSB8fCBlLnNoaWZ0S2V5IHx8IGUubWV0YUtleSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWl0ZW0uaXNGb2xkZXIoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXRlbS5pc0V4cGFuZGVkKCkpIHtcbiAgICAgICAgICAgIGl0ZW0uY29sbGFwc2UoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlbS5leHBhbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZXhwYW5kOiAoeyB0cmVlLCBpdGVtLCBpdGVtSWQgfSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKCFpdGVtLmlzRm9sZGVyKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKChfYSA9IHRyZWUuZ2V0U3RhdGUoKS5sb2FkaW5nSXRlbUNoaWxkcmVucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKGl0ZW1JZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHJlZS5hcHBseVN1YlN0YXRlVXBkYXRlKFwiZXhwYW5kZWRJdGVtc1wiLCAoZXhwYW5kZWRJdGVtcykgPT4gW1xuICAgICAgICAuLi5leHBhbmRlZEl0ZW1zLFxuICAgICAgICBpdGVtSWRcbiAgICAgIF0pO1xuICAgICAgdHJlZS5yZWJ1aWxkVHJlZSgpO1xuICAgIH0sXG4gICAgY29sbGFwc2U6ICh7IHRyZWUsIGl0ZW0sIGl0ZW1JZCB9KSA9PiB7XG4gICAgICBpZiAoIWl0ZW0uaXNGb2xkZXIoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0cmVlLmFwcGx5U3ViU3RhdGVVcGRhdGUoXG4gICAgICAgIFwiZXhwYW5kZWRJdGVtc1wiLFxuICAgICAgICAoZXhwYW5kZWRJdGVtcykgPT4gZXhwYW5kZWRJdGVtcy5maWx0ZXIoKGlkKSA9PiBpZCAhPT0gaXRlbUlkKVxuICAgICAgKTtcbiAgICAgIHRyZWUucmVidWlsZFRyZWUoKTtcbiAgICB9LFxuICAgIGdldEl0ZW1EYXRhOiAoeyB0cmVlLCBpdGVtSWQgfSkgPT4gdHJlZS5yZXRyaWV2ZUl0ZW1EYXRhKGl0ZW1JZCksXG4gICAgZXF1YWxzOiAoeyBpdGVtIH0sIG90aGVyKSA9PiBpdGVtLmdldElkKCkgPT09IChvdGhlciA9PSBudWxsID8gdm9pZCAwIDogb3RoZXIuZ2V0SWQoKSksXG4gICAgaXNFeHBhbmRlZDogKHsgdHJlZSwgaXRlbUlkIH0pID0+IHRyZWUuZ2V0U3RhdGUoKS5leHBhbmRlZEl0ZW1zLmluY2x1ZGVzKGl0ZW1JZCksXG4gICAgaXNEZXNjZW5kZW50T2Y6ICh7IGl0ZW0gfSwgcGFyZW50SWQpID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IGl0ZW0uZ2V0UGFyZW50KCk7XG4gICAgICByZXR1cm4gQm9vbGVhbihcbiAgICAgICAgKHBhcmVudCA9PSBudWxsID8gdm9pZCAwIDogcGFyZW50LmdldElkKCkpID09PSBwYXJlbnRJZCB8fCAocGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwYXJlbnQuaXNEZXNjZW5kZW50T2YocGFyZW50SWQpKVxuICAgICAgKTtcbiAgICB9LFxuICAgIGlzRm9jdXNlZDogKHsgdHJlZSwgaXRlbSwgaXRlbUlkIH0pID0+IHRyZWUuZ2V0U3RhdGUoKS5mb2N1c2VkSXRlbSA9PT0gaXRlbUlkIHx8IHRyZWUuZ2V0U3RhdGUoKS5mb2N1c2VkSXRlbSA9PT0gbnVsbCAmJiBpdGVtLmdldEl0ZW1NZXRhKCkuaW5kZXggPT09IDAsXG4gICAgaXNGb2xkZXI6ICh7IHRyZWUsIGl0ZW0gfSkgPT4gaXRlbS5nZXRJdGVtTWV0YSgpLmxldmVsID09PSAtMSB8fCB0cmVlLmdldENvbmZpZygpLmlzSXRlbUZvbGRlcihpdGVtKSxcbiAgICBnZXRJdGVtTmFtZTogKHsgdHJlZSwgaXRlbSB9KSA9PiB7XG4gICAgICBjb25zdCBjb25maWcgPSB0cmVlLmdldENvbmZpZygpO1xuICAgICAgcmV0dXJuIGNvbmZpZy5nZXRJdGVtTmFtZShpdGVtKTtcbiAgICB9LFxuICAgIHNldEZvY3VzZWQ6ICh7IHRyZWUsIGl0ZW1JZCB9KSA9PiB7XG4gICAgICB0cmVlLmFwcGx5U3ViU3RhdGVVcGRhdGUoXCJmb2N1c2VkSXRlbVwiLCBpdGVtSWQpO1xuICAgIH0sXG4gICAgcHJpbWFyeUFjdGlvbjogKHsgdHJlZSwgaXRlbSB9KSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRyZWUuZ2V0Q29uZmlnKCkpLm9uUHJpbWFyeUFjdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGl0ZW0pO1xuICAgIH0sXG4gICAgZ2V0UGFyZW50OiAoeyB0cmVlLCBpdGVtIH0pID0+IGl0ZW0uZ2V0SXRlbU1ldGEoKS5wYXJlbnRJZCA/IHRyZWUuZ2V0SXRlbUluc3RhbmNlKGl0ZW0uZ2V0SXRlbU1ldGEoKS5wYXJlbnRJZCkgOiB2b2lkIDAsXG4gICAgZ2V0SW5kZXhJblBhcmVudDogKHsgaXRlbSB9KSA9PiBpdGVtLmdldEl0ZW1NZXRhKCkucG9zSW5TZXQsXG4gICAgZ2V0Q2hpbGRyZW46ICh7IHRyZWUsIGl0ZW1JZCB9KSA9PiB0cmVlLnJldHJpZXZlQ2hpbGRyZW5JZHMoaXRlbUlkKS5tYXAoKGlkKSA9PiB0cmVlLmdldEl0ZW1JbnN0YW5jZShpZCkpLFxuICAgIGdldFRyZWU6ICh7IHRyZWUgfSkgPT4gdHJlZSxcbiAgICBnZXRJdGVtQWJvdmU6ICh7IHRyZWUsIGl0ZW0gfSkgPT4gdHJlZS5nZXRJdGVtcygpW2l0ZW0uZ2V0SXRlbU1ldGEoKS5pbmRleCAtIDFdLFxuICAgIGdldEl0ZW1CZWxvdzogKHsgdHJlZSwgaXRlbSB9KSA9PiB0cmVlLmdldEl0ZW1zKClbaXRlbS5nZXRJdGVtTWV0YSgpLmluZGV4ICsgMV1cbiAgfSxcbiAgaG90a2V5czoge1xuICAgIGZvY3VzTmV4dEl0ZW06IHtcbiAgICAgIGhvdGtleTogXCJBcnJvd0Rvd25cIixcbiAgICAgIGNhblJlcGVhdDogdHJ1ZSxcbiAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlLFxuICAgICAgaXNFbmFibGVkOiAodHJlZSkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gISgoX2IgPSAoX2EgPSB0cmVlLmlzU2VhcmNoT3BlbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwodHJlZSkpICE9IG51bGwgPyBfYiA6IGZhbHNlKSAmJiAhdHJlZS5nZXRTdGF0ZSgpLmRuZDtcbiAgICAgIH0sXG4gICAgICAvLyBUT0RPIHdoYXQgaGFwcGVucyB3aGVuIHRoZSBmZWF0dXJlIGRvZXNudCBleGlzdD8gcHJveHkgbWV0aG9kIHN0aWxsIGNsYWltcyB0byBleGlzdFxuICAgICAgaGFuZGxlcjogKGUsIHRyZWUpID0+IHtcbiAgICAgICAgdHJlZS5mb2N1c05leHRJdGVtKCk7XG4gICAgICAgIHRyZWUudXBkYXRlRG9tRm9jdXMoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGZvY3VzUHJldmlvdXNJdGVtOiB7XG4gICAgICBob3RrZXk6IFwiQXJyb3dVcFwiLFxuICAgICAgY2FuUmVwZWF0OiB0cnVlLFxuICAgICAgcHJldmVudERlZmF1bHQ6IHRydWUsXG4gICAgICBpc0VuYWJsZWQ6ICh0cmVlKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAhKChfYiA9IChfYSA9IHRyZWUuaXNTZWFyY2hPcGVuKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbCh0cmVlKSkgIT0gbnVsbCA/IF9iIDogZmFsc2UpICYmICF0cmVlLmdldFN0YXRlKCkuZG5kO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZXI6IChlLCB0cmVlKSA9PiB7XG4gICAgICAgIHRyZWUuZm9jdXNQcmV2aW91c0l0ZW0oKTtcbiAgICAgICAgdHJlZS51cGRhdGVEb21Gb2N1cygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZXhwYW5kT3JEb3duOiB7XG4gICAgICBob3RrZXk6IFwiQXJyb3dSaWdodFwiLFxuICAgICAgY2FuUmVwZWF0OiB0cnVlLFxuICAgICAgaGFuZGxlcjogKGUsIHRyZWUpID0+IHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRyZWUuZ2V0Rm9jdXNlZEl0ZW0oKTtcbiAgICAgICAgaWYgKGl0ZW0uaXNFeHBhbmRlZCgpIHx8ICFpdGVtLmlzRm9sZGVyKCkpIHtcbiAgICAgICAgICB0cmVlLmZvY3VzTmV4dEl0ZW0oKTtcbiAgICAgICAgICB0cmVlLnVwZGF0ZURvbUZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbS5leHBhbmQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY29sbGFwc2VPclVwOiB7XG4gICAgICBob3RrZXk6IFwiQXJyb3dMZWZ0XCIsXG4gICAgICBjYW5SZXBlYXQ6IHRydWUsXG4gICAgICBoYW5kbGVyOiAoZSwgdHJlZSkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0cmVlLmdldEZvY3VzZWRJdGVtKCk7XG4gICAgICAgIGlmICgoIWl0ZW0uaXNFeHBhbmRlZCgpIHx8ICFpdGVtLmlzRm9sZGVyKCkpICYmIGl0ZW0uZ2V0SXRlbU1ldGEoKS5sZXZlbCAhPT0gMCkge1xuICAgICAgICAgIChfYSA9IGl0ZW0uZ2V0UGFyZW50KCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zZXRGb2N1c2VkKCk7XG4gICAgICAgICAgdHJlZS51cGRhdGVEb21Gb2N1cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW0uY29sbGFwc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZm9jdXNGaXJzdEl0ZW06IHtcbiAgICAgIGhvdGtleTogXCJIb21lXCIsXG4gICAgICBoYW5kbGVyOiAoZSwgdHJlZSkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRyZWUuZ2V0SXRlbXMoKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNldEZvY3VzZWQoKTtcbiAgICAgICAgdHJlZS51cGRhdGVEb21Gb2N1cygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZm9jdXNMYXN0SXRlbToge1xuICAgICAgaG90a2V5OiBcIkVuZFwiLFxuICAgICAgaGFuZGxlcjogKGUsIHRyZWUpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0cmVlLmdldEl0ZW1zKClbdHJlZS5nZXRJdGVtcygpLmxlbmd0aCAtIDFdKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2V0Rm9jdXNlZCgpO1xuICAgICAgICB0cmVlLnVwZGF0ZURvbUZvY3VzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvY29yZS9idWlsZC1zdGF0aWMtaW5zdGFuY2UudHNcbnZhciBidWlsZFN0YXRpY0luc3RhbmNlID0gKGZlYXR1cmVzLCBpbnN0YW5jZVR5cGUsIGJ1aWxkT3B0cykgPT4ge1xuICBjb25zdCBpbnN0YW5jZSA9IHt9O1xuICBjb25zdCBmaW5hbGl6ZSA9ICgpID0+IHtcbiAgICBjb25zdCBvcHRzID0gYnVpbGRPcHRzKGluc3RhbmNlKTtcbiAgICBmZWF0dXJlTG9vcDogZm9yIChsZXQgaSA9IDA7IGkgPCBmZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IGZlYXR1cmVzW2ldW2luc3RhbmNlVHlwZV07XG4gICAgICBpZiAoIWRlZmluaXRpb24pIGNvbnRpbnVlIGZlYXR1cmVMb29wO1xuICAgICAgbWV0aG9kTG9vcDogZm9yIChjb25zdCBba2V5LCBtZXRob2RdIG9mIE9iamVjdC5lbnRyaWVzKGRlZmluaXRpb24pKSB7XG4gICAgICAgIGlmICghbWV0aG9kKSBjb250aW51ZSBtZXRob2RMb29wO1xuICAgICAgICBjb25zdCBwcmV2ID0gaW5zdGFuY2Vba2V5XTtcbiAgICAgICAgaW5zdGFuY2Vba2V5XSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIG1ldGhvZChfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRzKSwgeyBwcmV2IH0pLCAuLi5hcmdzKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBbaW5zdGFuY2UsIGZpbmFsaXplXTtcbn07XG5cbi8vIHNyYy9jb3JlL2NyZWF0ZS10cmVlLnRzXG52YXIgdmVyaWZ5RmVhdHVyZXMgPSAoZmVhdHVyZXMpID0+IHtcbiAgdmFyIF9hO1xuICBjb25zdCBsb2FkZWRGZWF0dXJlcyA9IGZlYXR1cmVzID09IG51bGwgPyB2b2lkIDAgOiBmZWF0dXJlcy5tYXAoKGZlYXR1cmUpID0+IGZlYXR1cmUua2V5KTtcbiAgZm9yIChjb25zdCBmZWF0dXJlIG9mIGZlYXR1cmVzICE9IG51bGwgPyBmZWF0dXJlcyA6IFtdKSB7XG4gICAgY29uc3QgbWlzc2luZ0RlcGVuZGVuY3kgPSAoX2EgPSBmZWF0dXJlLmRlcHMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5maW5kKFxuICAgICAgKGRlcCkgPT4gIShsb2FkZWRGZWF0dXJlcyA9PSBudWxsID8gdm9pZCAwIDogbG9hZGVkRmVhdHVyZXMuaW5jbHVkZXMoZGVwKSlcbiAgICApO1xuICAgIGlmIChtaXNzaW5nRGVwZW5kZW5jeSkge1xuICAgICAgdGhyb3cgdGhyb3dFcnJvcihgJHtmZWF0dXJlLmtleX0gbmVlZHMgJHttaXNzaW5nRGVwZW5kZW5jeX1gKTtcbiAgICB9XG4gIH1cbn07XG52YXIgZXhoYXVzdGl2ZVNvcnQgPSAoYXJyLCBjb21wYXJlRm4pID0+IHtcbiAgY29uc3QgbiA9IGFyci5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgbjsgaisrKSB7XG4gICAgICBpZiAoY29tcGFyZUZuKGFycltqXSwgYXJyW2ldKSA8IDApIHtcbiAgICAgICAgW2FycltpXSwgYXJyW2pdXSA9IFthcnJbal0sIGFycltpXV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnI7XG59O1xudmFyIGNvbXBhcmVGZWF0dXJlcyA9IChvcmlnaW5hbE9yZGVyKSA9PiAoZmVhdHVyZTEsIGZlYXR1cmUyKSA9PiB7XG4gIHZhciBfYSwgX2I7XG4gIGlmIChmZWF0dXJlMi5rZXkgJiYgKChfYSA9IGZlYXR1cmUxLm92ZXJ3cml0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcyhmZWF0dXJlMi5rZXkpKSkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIGlmIChmZWF0dXJlMS5rZXkgJiYgKChfYiA9IGZlYXR1cmUyLm92ZXJ3cml0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5pbmNsdWRlcyhmZWF0dXJlMS5rZXkpKSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICByZXR1cm4gb3JpZ2luYWxPcmRlci5pbmRleE9mKGZlYXR1cmUxKSAtIG9yaWdpbmFsT3JkZXIuaW5kZXhPZihmZWF0dXJlMik7XG59O1xudmFyIHNvcnRGZWF0dXJlcyA9IChmZWF0dXJlcyA9IFtdKSA9PiBleGhhdXN0aXZlU29ydChmZWF0dXJlcywgY29tcGFyZUZlYXR1cmVzKGZlYXR1cmVzKSk7XG52YXIgY3JlYXRlVHJlZSA9IChpbml0aWFsQ29uZmlnKSA9PiB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgY29uc3QgYnVpbGRJbnN0YW5jZSA9IChfYSA9IGluaXRpYWxDb25maWcuaW5zdGFuY2VCdWlsZGVyKSAhPSBudWxsID8gX2EgOiBidWlsZFN0YXRpY0luc3RhbmNlO1xuICBjb25zdCBhZGRpdGlvbmFsRmVhdHVyZXMgPSBbXG4gICAgdHJlZUZlYXR1cmUsXG4gICAgLi4uc29ydEZlYXR1cmVzKGluaXRpYWxDb25maWcuZmVhdHVyZXMpXG4gIF07XG4gIHZlcmlmeUZlYXR1cmVzKGFkZGl0aW9uYWxGZWF0dXJlcyk7XG4gIGNvbnN0IGZlYXR1cmVzID0gWy4uLmFkZGl0aW9uYWxGZWF0dXJlc107XG4gIGNvbnN0IFt0cmVlSW5zdGFuY2UsIGZpbmFsaXplVHJlZV0gPSBidWlsZEluc3RhbmNlKFxuICAgIGZlYXR1cmVzLFxuICAgIFwidHJlZUluc3RhbmNlXCIsXG4gICAgKHRyZWUpID0+ICh7IHRyZWUgfSlcbiAgKTtcbiAgbGV0IHN0YXRlID0gYWRkaXRpb25hbEZlYXR1cmVzLnJlZHVjZShcbiAgICAoYWNjLCBmZWF0dXJlKSA9PiB7XG4gICAgICB2YXIgX2EyLCBfYjI7XG4gICAgICByZXR1cm4gKF9iMiA9IChfYTIgPSBmZWF0dXJlLmdldEluaXRpYWxTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jYWxsKGZlYXR1cmUsIGFjYywgdHJlZUluc3RhbmNlKSkgIT0gbnVsbCA/IF9iMiA6IGFjYztcbiAgICB9LFxuICAgIChfYyA9IChfYiA9IGluaXRpYWxDb25maWcuaW5pdGlhbFN0YXRlKSAhPSBudWxsID8gX2IgOiBpbml0aWFsQ29uZmlnLnN0YXRlKSAhPSBudWxsID8gX2MgOiB7fVxuICApO1xuICBsZXQgY29uZmlnID0gYWRkaXRpb25hbEZlYXR1cmVzLnJlZHVjZShcbiAgICAoYWNjLCBmZWF0dXJlKSA9PiB7XG4gICAgICB2YXIgX2EyLCBfYjI7XG4gICAgICByZXR1cm4gKF9iMiA9IChfYTIgPSBmZWF0dXJlLmdldERlZmF1bHRDb25maWcpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY2FsbChmZWF0dXJlLCBhY2MsIHRyZWVJbnN0YW5jZSkpICE9IG51bGwgPyBfYjIgOiBhY2M7XG4gICAgfSxcbiAgICBpbml0aWFsQ29uZmlnXG4gICk7XG4gIGNvbnN0IHN0YXRlSGFuZGxlck5hbWVzID0gYWRkaXRpb25hbEZlYXR1cmVzLnJlZHVjZShcbiAgICAoYWNjLCBmZWF0dXJlKSA9PiBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgYWNjKSwgZmVhdHVyZS5zdGF0ZUhhbmRsZXJOYW1lcyksXG4gICAge31cbiAgKTtcbiAgbGV0IHRyZWVFbGVtZW50O1xuICBjb25zdCB0cmVlRGF0YVJlZiA9IHsgY3VycmVudDoge30gfTtcbiAgY29uc3QgaXRlbUluc3RhbmNlc01hcCA9IHt9O1xuICBsZXQgaXRlbUluc3RhbmNlcyA9IFtdO1xuICBjb25zdCBpdGVtRWxlbWVudHNNYXAgPSB7fTtcbiAgY29uc3QgaXRlbURhdGFSZWZzID0ge307XG4gIGxldCBpdGVtTWV0YU1hcCA9IHt9O1xuICBjb25zdCBob3RrZXlQcmVzZXRzID0ge307XG4gIGNvbnN0IHJlYnVpbGRJdGVtTWV0YSA9ICgpID0+IHtcbiAgICBpdGVtSW5zdGFuY2VzID0gW107XG4gICAgaXRlbU1ldGFNYXAgPSB7fTtcbiAgICBjb25zdCBbcm9vdEluc3RhbmNlLCBmaW5hbGl6ZVJvb3RJbnN0YW5jZV0gPSBidWlsZEluc3RhbmNlKFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBcIml0ZW1JbnN0YW5jZVwiLFxuICAgICAgKGl0ZW0pID0+ICh7IGl0ZW0sIHRyZWU6IHRyZWVJbnN0YW5jZSwgaXRlbUlkOiBjb25maWcucm9vdEl0ZW1JZCB9KVxuICAgICk7XG4gICAgZmluYWxpemVSb290SW5zdGFuY2UoKTtcbiAgICBpdGVtSW5zdGFuY2VzTWFwW2NvbmZpZy5yb290SXRlbUlkXSA9IHJvb3RJbnN0YW5jZTtcbiAgICBpdGVtTWV0YU1hcFtjb25maWcucm9vdEl0ZW1JZF0gPSB7XG4gICAgICBpdGVtSWQ6IGNvbmZpZy5yb290SXRlbUlkLFxuICAgICAgaW5kZXg6IC0xLFxuICAgICAgcGFyZW50SWQ6IG51bGwsXG4gICAgICBsZXZlbDogLTEsXG4gICAgICBwb3NJblNldDogMCxcbiAgICAgIHNldFNpemU6IDFcbiAgICB9O1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0cmVlSW5zdGFuY2UuZ2V0SXRlbXNNZXRhKCkpIHtcbiAgICAgIGl0ZW1NZXRhTWFwW2l0ZW0uaXRlbUlkXSA9IGl0ZW07XG4gICAgICBpZiAoIWl0ZW1JbnN0YW5jZXNNYXBbaXRlbS5pdGVtSWRdKSB7XG4gICAgICAgIGNvbnN0IFtpbnN0YW5jZSwgZmluYWxpemVJbnN0YW5jZV0gPSBidWlsZEluc3RhbmNlKFxuICAgICAgICAgIGZlYXR1cmVzLFxuICAgICAgICAgIFwiaXRlbUluc3RhbmNlXCIsXG4gICAgICAgICAgKGluc3RhbmNlMikgPT4gKHtcbiAgICAgICAgICAgIGl0ZW06IGluc3RhbmNlMixcbiAgICAgICAgICAgIHRyZWU6IHRyZWVJbnN0YW5jZSxcbiAgICAgICAgICAgIGl0ZW1JZDogaXRlbS5pdGVtSWRcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBmaW5hbGl6ZUluc3RhbmNlKCk7XG4gICAgICAgIGl0ZW1JbnN0YW5jZXNNYXBbaXRlbS5pdGVtSWRdID0gaW5zdGFuY2U7XG4gICAgICAgIGl0ZW1JbnN0YW5jZXMucHVzaChpbnN0YW5jZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVtSW5zdGFuY2VzLnB1c2goaXRlbUluc3RhbmNlc01hcFtpdGVtLml0ZW1JZF0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgZWFjaEZlYXR1cmUgPSAoZm4pID0+IHtcbiAgICBmb3IgKGNvbnN0IGZlYXR1cmUgb2YgYWRkaXRpb25hbEZlYXR1cmVzKSB7XG4gICAgICBmbihmZWF0dXJlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1haW5GZWF0dXJlID0ge1xuICAgIGtleTogXCJtYWluXCIsXG4gICAgdHJlZUluc3RhbmNlOiB7XG4gICAgICBnZXRTdGF0ZTogKCkgPT4gc3RhdGUsXG4gICAgICBzZXRTdGF0ZTogKHt9LCB1cGRhdGVyKSA9PiB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIChfYTIgPSBjb25maWcuc2V0U3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY2FsbChjb25maWcsIHN0YXRlKTtcbiAgICAgIH0sXG4gICAgICBhcHBseVN1YlN0YXRlVXBkYXRlOiAoe30sIHN0YXRlTmFtZSwgdXBkYXRlcikgPT4ge1xuICAgICAgICBzdGF0ZVtzdGF0ZU5hbWVdID0gdHlwZW9mIHVwZGF0ZXIgPT09IFwiZnVuY3Rpb25cIiA/IHVwZGF0ZXIoc3RhdGVbc3RhdGVOYW1lXSkgOiB1cGRhdGVyO1xuICAgICAgICBjb25zdCBleHRlcm5hbFN0YXRlU2V0dGVyID0gY29uZmlnW3N0YXRlSGFuZGxlck5hbWVzW3N0YXRlTmFtZV1dO1xuICAgICAgICBleHRlcm5hbFN0YXRlU2V0dGVyID09IG51bGwgPyB2b2lkIDAgOiBleHRlcm5hbFN0YXRlU2V0dGVyKHN0YXRlW3N0YXRlTmFtZV0pO1xuICAgICAgfSxcbiAgICAgIC8vIFRPRE8gcmVidWlsZFN1YlRyZWU6IChpdGVtSWQ6IHN0cmluZykgPT4gdm9pZDtcbiAgICAgIHJlYnVpbGRUcmVlOiAoKSA9PiB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIHJlYnVpbGRJdGVtTWV0YSgpO1xuICAgICAgICAoX2EyID0gY29uZmlnLnNldFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNhbGwoY29uZmlnLCBzdGF0ZSk7XG4gICAgICB9LFxuICAgICAgZ2V0Q29uZmlnOiAoKSA9PiBjb25maWcsXG4gICAgICBzZXRDb25maWc6IChfLCB1cGRhdGVyKSA9PiB7XG4gICAgICAgIHZhciBfYTIsIF9iMiwgX2MyO1xuICAgICAgICBjb25zdCBuZXdDb25maWcgPSB0eXBlb2YgdXBkYXRlciA9PT0gXCJmdW5jdGlvblwiID8gdXBkYXRlcihjb25maWcpIDogdXBkYXRlcjtcbiAgICAgICAgY29uc3QgaGFzQ2hhbmdlZEV4cGFuZGVkSXRlbXMgPSAoKF9hMiA9IG5ld0NvbmZpZy5zdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5leHBhbmRlZEl0ZW1zKSAmJiAoKF9iMiA9IG5ld0NvbmZpZy5zdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5leHBhbmRlZEl0ZW1zKSAhPT0gc3RhdGUuZXhwYW5kZWRJdGVtcztcbiAgICAgICAgY29uZmlnID0gbmV3Q29uZmlnO1xuICAgICAgICBpZiAobmV3Q29uZmlnLnN0YXRlKSB7XG4gICAgICAgICAgc3RhdGUgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgc3RhdGUpLCBuZXdDb25maWcuc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNDaGFuZ2VkRXhwYW5kZWRJdGVtcykge1xuICAgICAgICAgIHJlYnVpbGRJdGVtTWV0YSgpO1xuICAgICAgICAgIChfYzIgPSBjb25maWcuc2V0U3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfYzIuY2FsbChjb25maWcsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdldEl0ZW1JbnN0YW5jZTogKHt9LCBpdGVtSWQpID0+IHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdJbnN0YW5jZSA9IGl0ZW1JbnN0YW5jZXNNYXBbaXRlbUlkXTtcbiAgICAgICAgaWYgKCFleGlzdGluZ0luc3RhbmNlKSB7XG4gICAgICAgICAgY29uc3QgW2luc3RhbmNlLCBmaW5hbGl6ZUluc3RhbmNlXSA9IGJ1aWxkSW5zdGFuY2UoXG4gICAgICAgICAgICBmZWF0dXJlcyxcbiAgICAgICAgICAgIFwiaXRlbUluc3RhbmNlXCIsXG4gICAgICAgICAgICAoaW5zdGFuY2UyKSA9PiAoe1xuICAgICAgICAgICAgICBpdGVtOiBpbnN0YW5jZTIsXG4gICAgICAgICAgICAgIHRyZWU6IHRyZWVJbnN0YW5jZSxcbiAgICAgICAgICAgICAgaXRlbUlkXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgZmluYWxpemVJbnN0YW5jZSgpO1xuICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhpc3RpbmdJbnN0YW5jZTtcbiAgICAgIH0sXG4gICAgICBnZXRJdGVtczogKCkgPT4gaXRlbUluc3RhbmNlcyxcbiAgICAgIHJlZ2lzdGVyRWxlbWVudDogKHt9LCBlbGVtZW50KSA9PiB7XG4gICAgICAgIGlmICh0cmVlRWxlbWVudCA9PT0gZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJlZUVsZW1lbnQgJiYgIWVsZW1lbnQpIHtcbiAgICAgICAgICBlYWNoRmVhdHVyZShcbiAgICAgICAgICAgIChmZWF0dXJlKSA9PiB7XG4gICAgICAgICAgICAgIHZhciBfYTI7XG4gICAgICAgICAgICAgIHJldHVybiAoX2EyID0gZmVhdHVyZS5vblRyZWVVbm1vdW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNhbGwoZmVhdHVyZSwgdHJlZUluc3RhbmNlLCB0cmVlRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICghdHJlZUVsZW1lbnQgJiYgZWxlbWVudCkge1xuICAgICAgICAgIGVhY2hGZWF0dXJlKFxuICAgICAgICAgICAgKGZlYXR1cmUpID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgICAgICAgcmV0dXJuIChfYTIgPSBmZWF0dXJlLm9uVHJlZU1vdW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNhbGwoZmVhdHVyZSwgdHJlZUluc3RhbmNlLCBlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRyZWVFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIH0sXG4gICAgICBnZXRFbGVtZW50OiAoKSA9PiB0cmVlRWxlbWVudCxcbiAgICAgIGdldERhdGFSZWY6ICgpID0+IHRyZWVEYXRhUmVmLFxuICAgICAgZ2V0SG90a2V5UHJlc2V0czogKCkgPT4gaG90a2V5UHJlc2V0c1xuICAgIH0sXG4gICAgaXRlbUluc3RhbmNlOiB7XG4gICAgICByZWdpc3RlckVsZW1lbnQ6ICh7IGl0ZW1JZCwgaXRlbSB9LCBlbGVtZW50KSA9PiB7XG4gICAgICAgIGlmIChpdGVtRWxlbWVudHNNYXBbaXRlbUlkXSA9PT0gZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRFbGVtZW50ID0gaXRlbUVsZW1lbnRzTWFwW2l0ZW1JZF07XG4gICAgICAgIGlmIChvbGRFbGVtZW50ICYmICFlbGVtZW50KSB7XG4gICAgICAgICAgZWFjaEZlYXR1cmUoXG4gICAgICAgICAgICAoZmVhdHVyZSkgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2EyO1xuICAgICAgICAgICAgICByZXR1cm4gKF9hMiA9IGZlYXR1cmUub25JdGVtVW5tb3VudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jYWxsKGZlYXR1cmUsIGl0ZW0sIG9sZEVsZW1lbnQsIHRyZWVJbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICghb2xkRWxlbWVudCAmJiBlbGVtZW50KSB7XG4gICAgICAgICAgZWFjaEZlYXR1cmUoXG4gICAgICAgICAgICAoZmVhdHVyZSkgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2EyO1xuICAgICAgICAgICAgICByZXR1cm4gKF9hMiA9IGZlYXR1cmUub25JdGVtTW91bnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY2FsbChmZWF0dXJlLCBpdGVtLCBlbGVtZW50LCB0cmVlSW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaXRlbUVsZW1lbnRzTWFwW2l0ZW1JZF0gPSBlbGVtZW50O1xuICAgICAgfSxcbiAgICAgIGdldEVsZW1lbnQ6ICh7IGl0ZW1JZCB9KSA9PiBpdGVtRWxlbWVudHNNYXBbaXRlbUlkXSxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXR1cm4tYXNzaWduXG4gICAgICBnZXREYXRhUmVmOiAoeyBpdGVtSWQgfSkgPT4ge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICByZXR1cm4gKF9hMiA9IGl0ZW1EYXRhUmVmc1tpdGVtSWRdKSAhPSBudWxsID8gX2EyIDogaXRlbURhdGFSZWZzW2l0ZW1JZF0gPSB7IGN1cnJlbnQ6IHt9IH07XG4gICAgICB9LFxuICAgICAgZ2V0SXRlbU1ldGE6ICh7IGl0ZW1JZCB9KSA9PiB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIHJldHVybiAoX2EyID0gaXRlbU1ldGFNYXBbaXRlbUlkXSkgIT0gbnVsbCA/IF9hMiA6IHtcbiAgICAgICAgICBpdGVtSWQsXG4gICAgICAgICAgcGFyZW50SWQ6IG51bGwsXG4gICAgICAgICAgbGV2ZWw6IC0xLFxuICAgICAgICAgIGluZGV4OiAtMSxcbiAgICAgICAgICBwb3NJblNldDogMCxcbiAgICAgICAgICBzZXRTaXplOiAxXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBmZWF0dXJlcy51bnNoaWZ0KG1haW5GZWF0dXJlKTtcbiAgZm9yIChjb25zdCBmZWF0dXJlIG9mIGZlYXR1cmVzKSB7XG4gICAgT2JqZWN0LmFzc2lnbihob3RrZXlQcmVzZXRzLCAoX2QgPSBmZWF0dXJlLmhvdGtleXMpICE9IG51bGwgPyBfZCA6IHt9KTtcbiAgfVxuICBmaW5hbGl6ZVRyZWUoKTtcbiAgcmV0dXJuIHRyZWVJbnN0YW5jZTtcbn07XG5cbi8vIHNyYy9mZWF0dXJlcy9kcmFnLWFuZC1kcm9wL3R5cGVzLnRzXG52YXIgRHJhZ1RhcmdldFBvc2l0aW9uID0gLyogQF9fUFVSRV9fICovICgoRHJhZ1RhcmdldFBvc2l0aW9uMikgPT4ge1xuICBEcmFnVGFyZ2V0UG9zaXRpb24yW1wiVG9wXCJdID0gXCJ0b3BcIjtcbiAgRHJhZ1RhcmdldFBvc2l0aW9uMltcIkJvdHRvbVwiXSA9IFwiYm90dG9tXCI7XG4gIERyYWdUYXJnZXRQb3NpdGlvbjJbXCJJdGVtXCJdID0gXCJpdGVtXCI7XG4gIHJldHVybiBEcmFnVGFyZ2V0UG9zaXRpb24yO1xufSkoRHJhZ1RhcmdldFBvc2l0aW9uIHx8IHt9KTtcblxuLy8gc3JjL2ZlYXR1cmVzL2tleWJvYXJkLWRyYWctYW5kLWRyb3AvdHlwZXMudHNcbnZhciBBc3Npc3RpdmVEbmRTdGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEFzc2lzdGl2ZURuZFN0YXRlMikgPT4ge1xuICBBc3Npc3RpdmVEbmRTdGF0ZTJbQXNzaXN0aXZlRG5kU3RhdGUyW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gIEFzc2lzdGl2ZURuZFN0YXRlMltBc3Npc3RpdmVEbmRTdGF0ZTJbXCJTdGFydGVkXCJdID0gMV0gPSBcIlN0YXJ0ZWRcIjtcbiAgQXNzaXN0aXZlRG5kU3RhdGUyW0Fzc2lzdGl2ZURuZFN0YXRlMltcIkRyYWdnaW5nXCJdID0gMl0gPSBcIkRyYWdnaW5nXCI7XG4gIEFzc2lzdGl2ZURuZFN0YXRlMltBc3Npc3RpdmVEbmRTdGF0ZTJbXCJDb21wbGV0ZWRcIl0gPSAzXSA9IFwiQ29tcGxldGVkXCI7XG4gIEFzc2lzdGl2ZURuZFN0YXRlMltBc3Npc3RpdmVEbmRTdGF0ZTJbXCJBYm9ydGVkXCJdID0gNF0gPSBcIkFib3J0ZWRcIjtcbiAgcmV0dXJuIEFzc2lzdGl2ZURuZFN0YXRlMjtcbn0pKEFzc2lzdGl2ZURuZFN0YXRlIHx8IHt9KTtcblxuLy8gc3JjL2ZlYXR1cmVzL2NoZWNrYm94ZXMvdHlwZXMudHNcbnZhciBDaGVja2VkU3RhdGUgPSAvKiBAX19QVVJFX18gKi8gKChDaGVja2VkU3RhdGUyKSA9PiB7XG4gIENoZWNrZWRTdGF0ZTJbXCJDaGVja2VkXCJdID0gXCJjaGVja2VkXCI7XG4gIENoZWNrZWRTdGF0ZTJbXCJVbmNoZWNrZWRcIl0gPSBcInVuY2hlY2tlZFwiO1xuICBDaGVja2VkU3RhdGUyW1wiSW5kZXRlcm1pbmF0ZVwiXSA9IFwiaW5kZXRlcm1pbmF0ZVwiO1xuICByZXR1cm4gQ2hlY2tlZFN0YXRlMjtcbn0pKENoZWNrZWRTdGF0ZSB8fCB7fSk7XG5cbi8vIHNyYy9mZWF0dXJlcy9zZWxlY3Rpb24vZmVhdHVyZS50c1xudmFyIHNlbGVjdGlvbkZlYXR1cmUgPSB7XG4gIGtleTogXCJzZWxlY3Rpb25cIixcbiAgZ2V0SW5pdGlhbFN0YXRlOiAoaW5pdGlhbFN0YXRlKSA9PiBfX3NwcmVhZFZhbHVlcyh7XG4gICAgc2VsZWN0ZWRJdGVtczogW11cbiAgfSwgaW5pdGlhbFN0YXRlKSxcbiAgZ2V0RGVmYXVsdENvbmZpZzogKGRlZmF1bHRDb25maWcsIHRyZWUpID0+IF9fc3ByZWFkVmFsdWVzKHtcbiAgICBzZXRTZWxlY3RlZEl0ZW1zOiBtYWtlU3RhdGVVcGRhdGVyKFwic2VsZWN0ZWRJdGVtc1wiLCB0cmVlKVxuICB9LCBkZWZhdWx0Q29uZmlnKSxcbiAgc3RhdGVIYW5kbGVyTmFtZXM6IHtcbiAgICBzZWxlY3RlZEl0ZW1zOiBcInNldFNlbGVjdGVkSXRlbXNcIlxuICB9LFxuICB0cmVlSW5zdGFuY2U6IHtcbiAgICBzZXRTZWxlY3RlZEl0ZW1zOiAoeyB0cmVlIH0sIHNlbGVjdGVkSXRlbXMpID0+IHtcbiAgICAgIHRyZWUuYXBwbHlTdWJTdGF0ZVVwZGF0ZShcInNlbGVjdGVkSXRlbXNcIiwgc2VsZWN0ZWRJdGVtcyk7XG4gICAgfSxcbiAgICBnZXRTZWxlY3RlZEl0ZW1zOiAoeyB0cmVlIH0pID0+IHtcbiAgICAgIHJldHVybiB0cmVlLmdldFN0YXRlKCkuc2VsZWN0ZWRJdGVtcy5tYXAodHJlZS5nZXRJdGVtSW5zdGFuY2UpO1xuICAgIH1cbiAgfSxcbiAgaXRlbUluc3RhbmNlOiB7XG4gICAgc2VsZWN0OiAoeyB0cmVlLCBpdGVtSWQgfSkgPT4ge1xuICAgICAgY29uc3QgeyBzZWxlY3RlZEl0ZW1zIH0gPSB0cmVlLmdldFN0YXRlKCk7XG4gICAgICB0cmVlLnNldFNlbGVjdGVkSXRlbXMoXG4gICAgICAgIHNlbGVjdGVkSXRlbXMuaW5jbHVkZXMoaXRlbUlkKSA/IHNlbGVjdGVkSXRlbXMgOiBbLi4uc2VsZWN0ZWRJdGVtcywgaXRlbUlkXVxuICAgICAgKTtcbiAgICB9LFxuICAgIGRlc2VsZWN0OiAoeyB0cmVlLCBpdGVtSWQgfSkgPT4ge1xuICAgICAgY29uc3QgeyBzZWxlY3RlZEl0ZW1zIH0gPSB0cmVlLmdldFN0YXRlKCk7XG4gICAgICB0cmVlLnNldFNlbGVjdGVkSXRlbXMoc2VsZWN0ZWRJdGVtcy5maWx0ZXIoKGlkKSA9PiBpZCAhPT0gaXRlbUlkKSk7XG4gICAgfSxcbiAgICBpc1NlbGVjdGVkOiAoeyB0cmVlLCBpdGVtSWQgfSkgPT4ge1xuICAgICAgY29uc3QgeyBzZWxlY3RlZEl0ZW1zIH0gPSB0cmVlLmdldFN0YXRlKCk7XG4gICAgICByZXR1cm4gc2VsZWN0ZWRJdGVtcy5pbmNsdWRlcyhpdGVtSWQpO1xuICAgIH0sXG4gICAgc2VsZWN0VXBUbzogKHsgdHJlZSwgaXRlbSB9LCBjdHJsKSA9PiB7XG4gICAgICBjb25zdCBpbmRleEEgPSBpdGVtLmdldEl0ZW1NZXRhKCkuaW5kZXg7XG4gICAgICBjb25zdCBpbmRleEIgPSB0cmVlLmdldEZvY3VzZWRJdGVtKCkuZ2V0SXRlbU1ldGEoKS5pbmRleDtcbiAgICAgIGNvbnN0IFthLCBiXSA9IGluZGV4QSA8IGluZGV4QiA/IFtpbmRleEEsIGluZGV4Ql0gOiBbaW5kZXhCLCBpbmRleEFdO1xuICAgICAgY29uc3QgbmV3U2VsZWN0ZWRJdGVtcyA9IHRyZWUuZ2V0SXRlbXMoKS5zbGljZShhLCBiICsgMSkubWFwKCh0cmVlSXRlbSkgPT4gdHJlZUl0ZW0uZ2V0SXRlbU1ldGEoKS5pdGVtSWQpO1xuICAgICAgaWYgKCFjdHJsKSB7XG4gICAgICAgIHRyZWUuc2V0U2VsZWN0ZWRJdGVtcyhuZXdTZWxlY3RlZEl0ZW1zKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBzZWxlY3RlZEl0ZW1zIH0gPSB0cmVlLmdldFN0YXRlKCk7XG4gICAgICBjb25zdCB1bmlxdWVTZWxlY3RlZEl0ZW1zID0gW1xuICAgICAgICAuLi4vKiBAX19QVVJFX18gKi8gbmV3IFNldChbLi4uc2VsZWN0ZWRJdGVtcywgLi4ubmV3U2VsZWN0ZWRJdGVtc10pXG4gICAgICBdO1xuICAgICAgdHJlZS5zZXRTZWxlY3RlZEl0ZW1zKHVuaXF1ZVNlbGVjdGVkSXRlbXMpO1xuICAgIH0sXG4gICAgdG9nZ2xlU2VsZWN0OiAoeyBpdGVtIH0pID0+IHtcbiAgICAgIGlmIChpdGVtLmlzU2VsZWN0ZWQoKSkge1xuICAgICAgICBpdGVtLmRlc2VsZWN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVtLnNlbGVjdCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0UHJvcHM6ICh7IHRyZWUsIGl0ZW0sIHByZXYgfSkgPT4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgcHJldiA9PSBudWxsID8gdm9pZCAwIDogcHJldigpKSwge1xuICAgICAgXCJhcmlhLXNlbGVjdGVkXCI6IGl0ZW0uaXNTZWxlY3RlZCgpID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIsXG4gICAgICBvbkNsaWNrOiAoZSkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgICAgIGl0ZW0uc2VsZWN0VXBUbyhlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KTtcbiAgICAgICAgfSBlbHNlIGlmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSB7XG4gICAgICAgICAgaXRlbS50b2dnbGVTZWxlY3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cmVlLnNldFNlbGVjdGVkSXRlbXMoW2l0ZW0uZ2V0SXRlbU1ldGEoKS5pdGVtSWRdKTtcbiAgICAgICAgfVxuICAgICAgICAoX2IgPSAoX2EgPSBwcmV2ID09IG51bGwgPyB2b2lkIDAgOiBwcmV2KCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5vbkNsaWNrKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgZSk7XG4gICAgICB9XG4gICAgfSlcbiAgfSxcbiAgaG90a2V5czoge1xuICAgIC8vIHNldFNlbGVjdGVkSXRlbToge1xuICAgIC8vICAgaG90a2V5OiBcInNwYWNlXCIsXG4gICAgLy8gICBoYW5kbGVyOiAoZSwgdHJlZSkgPT4ge1xuICAgIC8vICAgICB0cmVlLnNldFNlbGVjdGVkSXRlbXMoW3RyZWUuZ2V0Rm9jdXNlZEl0ZW0oKS5nZXRJZCgpXSk7XG4gICAgLy8gICB9LFxuICAgIC8vIH0sXG4gICAgdG9nZ2xlU2VsZWN0ZWRJdGVtOiB7XG4gICAgICBob3RrZXk6IFwiQ29udHJvbCtTcGFjZVwiLFxuICAgICAgcHJldmVudERlZmF1bHQ6IHRydWUsXG4gICAgICBoYW5kbGVyOiAoXywgdHJlZSkgPT4ge1xuICAgICAgICB0cmVlLmdldEZvY3VzZWRJdGVtKCkudG9nZ2xlU2VsZWN0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZWxlY3RVcHdhcmRzOiB7XG4gICAgICBob3RrZXk6IFwiU2hpZnQrQXJyb3dVcFwiLFxuICAgICAgaGFuZGxlcjogKGUsIHRyZWUpID0+IHtcbiAgICAgICAgY29uc3QgZm9jdXNlZCA9IHRyZWUuZ2V0Rm9jdXNlZEl0ZW0oKTtcbiAgICAgICAgY29uc3QgYWJvdmUgPSBmb2N1c2VkLmdldEl0ZW1BYm92ZSgpO1xuICAgICAgICBpZiAoIWFib3ZlKSByZXR1cm47XG4gICAgICAgIGlmIChmb2N1c2VkLmlzU2VsZWN0ZWQoKSAmJiBhYm92ZS5pc1NlbGVjdGVkKCkpIHtcbiAgICAgICAgICBmb2N1c2VkLmRlc2VsZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWJvdmUuc2VsZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgYWJvdmUuc2V0Rm9jdXNlZCgpO1xuICAgICAgICB0cmVlLnVwZGF0ZURvbUZvY3VzKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZWxlY3REb3dud2FyZHM6IHtcbiAgICAgIGhvdGtleTogXCJTaGlmdCtBcnJvd0Rvd25cIixcbiAgICAgIGhhbmRsZXI6IChlLCB0cmVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGZvY3VzZWQgPSB0cmVlLmdldEZvY3VzZWRJdGVtKCk7XG4gICAgICAgIGNvbnN0IGJlbG93ID0gZm9jdXNlZC5nZXRJdGVtQmVsb3coKTtcbiAgICAgICAgaWYgKCFiZWxvdykgcmV0dXJuO1xuICAgICAgICBpZiAoZm9jdXNlZC5pc1NlbGVjdGVkKCkgJiYgYmVsb3cuaXNTZWxlY3RlZCgpKSB7XG4gICAgICAgICAgZm9jdXNlZC5kZXNlbGVjdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJlbG93LnNlbGVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGJlbG93LnNldEZvY3VzZWQoKTtcbiAgICAgICAgdHJlZS51cGRhdGVEb21Gb2N1cygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2VsZWN0QWxsOiB7XG4gICAgICBob3RrZXk6IFwiQ29udHJvbCtLZXlBXCIsXG4gICAgICBwcmV2ZW50RGVmYXVsdDogdHJ1ZSxcbiAgICAgIGhhbmRsZXI6IChlLCB0cmVlKSA9PiB7XG4gICAgICAgIHRyZWUuc2V0U2VsZWN0ZWRJdGVtcyh0cmVlLmdldEl0ZW1zKCkubWFwKChpdGVtKSA9PiBpdGVtLmdldElkKCkpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9mZWF0dXJlcy9jaGVja2JveGVzL2ZlYXR1cmUudHNcbnZhciBnZXRBbGxMb2FkZWREZXNjZW5kYW50cyA9ICh0cmVlLCBpdGVtSWQsIGluY2x1ZGVGb2xkZXJzID0gZmFsc2UpID0+IHtcbiAgaWYgKCF0cmVlLmdldENvbmZpZygpLmlzSXRlbUZvbGRlcih0cmVlLmdldEl0ZW1JbnN0YW5jZShpdGVtSWQpKSkge1xuICAgIHJldHVybiBbaXRlbUlkXTtcbiAgfVxuICBjb25zdCBkZXNjZW5kYW50cyA9IHRyZWUucmV0cmlldmVDaGlsZHJlbklkcyhpdGVtSWQpLm1hcCgoY2hpbGQpID0+IGdldEFsbExvYWRlZERlc2NlbmRhbnRzKHRyZWUsIGNoaWxkLCBpbmNsdWRlRm9sZGVycykpLmZsYXQoKTtcbiAgcmV0dXJuIGluY2x1ZGVGb2xkZXJzID8gW2l0ZW1JZCwgLi4uZGVzY2VuZGFudHNdIDogZGVzY2VuZGFudHM7XG59O1xudmFyIGNoZWNrYm94ZXNGZWF0dXJlID0ge1xuICBrZXk6IFwiY2hlY2tib3hlc1wiLFxuICBvdmVyd3JpdGVzOiBbXCJzZWxlY3Rpb25cIl0sXG4gIGdldEluaXRpYWxTdGF0ZTogKGluaXRpYWxTdGF0ZSkgPT4gX19zcHJlYWRWYWx1ZXMoe1xuICAgIGNoZWNrZWRJdGVtczogW11cbiAgfSwgaW5pdGlhbFN0YXRlKSxcbiAgZ2V0RGVmYXVsdENvbmZpZzogKGRlZmF1bHRDb25maWcsIHRyZWUpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBoYXNBc3luY0xvYWRlciA9IChfYSA9IGRlZmF1bHRDb25maWcuZmVhdHVyZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zb21lKFxuICAgICAgKGYpID0+IGYua2V5ID09PSBcImFzeW5jLWRhdGEtbG9hZGVyXCJcbiAgICApO1xuICAgIGlmIChoYXNBc3luY0xvYWRlciAmJiBkZWZhdWx0Q29uZmlnLnByb3BhZ2F0ZUNoZWNrZWRTdGF0ZSkge1xuICAgICAgdGhyb3dFcnJvcihgcHJvcGFnYXRlQ2hlY2tlZFN0YXRlIG5vdCBzdXBwb3J0ZWQgd2l0aCBhc3luYyB0cmVlc2ApO1xuICAgIH1cbiAgICBjb25zdCBwcm9wYWdhdGVDaGVja2VkU3RhdGUgPSAoX2IgPSBkZWZhdWx0Q29uZmlnLnByb3BhZ2F0ZUNoZWNrZWRTdGF0ZSkgIT0gbnVsbCA/IF9iIDogIWhhc0FzeW5jTG9hZGVyO1xuICAgIGNvbnN0IGNhbkNoZWNrRm9sZGVycyA9IChfYyA9IGRlZmF1bHRDb25maWcuY2FuQ2hlY2tGb2xkZXJzKSAhPSBudWxsID8gX2MgOiAhcHJvcGFnYXRlQ2hlY2tlZFN0YXRlO1xuICAgIHJldHVybiBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBzZXRDaGVja2VkSXRlbXM6IG1ha2VTdGF0ZVVwZGF0ZXIoXCJjaGVja2VkSXRlbXNcIiwgdHJlZSksXG4gICAgICBwcm9wYWdhdGVDaGVja2VkU3RhdGUsXG4gICAgICBjYW5DaGVja0ZvbGRlcnNcbiAgICB9LCBkZWZhdWx0Q29uZmlnKTtcbiAgfSxcbiAgc3RhdGVIYW5kbGVyTmFtZXM6IHtcbiAgICBjaGVja2VkSXRlbXM6IFwic2V0Q2hlY2tlZEl0ZW1zXCJcbiAgfSxcbiAgdHJlZUluc3RhbmNlOiB7XG4gICAgc2V0Q2hlY2tlZEl0ZW1zOiAoeyB0cmVlIH0sIGNoZWNrZWRJdGVtcykgPT4ge1xuICAgICAgdHJlZS5hcHBseVN1YlN0YXRlVXBkYXRlKFwiY2hlY2tlZEl0ZW1zXCIsIGNoZWNrZWRJdGVtcyk7XG4gICAgfVxuICB9LFxuICBpdGVtSW5zdGFuY2U6IHtcbiAgICBnZXRDaGVja2JveFByb3BzOiAoeyBpdGVtIH0pID0+IHtcbiAgICAgIGNvbnN0IGNoZWNrZWRTdGF0ZSA9IGl0ZW0uZ2V0Q2hlY2tlZFN0YXRlKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvbkNoYW5nZTogaXRlbS50b2dnbGVDaGVja2VkU3RhdGUsXG4gICAgICAgIGNoZWNrZWQ6IGNoZWNrZWRTdGF0ZSA9PT0gXCJjaGVja2VkXCIgLyogQ2hlY2tlZCAqLyxcbiAgICAgICAgcmVmOiAocikgPT4ge1xuICAgICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICByLmluZGV0ZXJtaW5hdGUgPSBjaGVja2VkU3RhdGUgPT09IFwiaW5kZXRlcm1pbmF0ZVwiIC8qIEluZGV0ZXJtaW5hdGUgKi87XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgdG9nZ2xlQ2hlY2tlZFN0YXRlOiAoeyBpdGVtIH0pID0+IHtcbiAgICAgIGlmIChpdGVtLmdldENoZWNrZWRTdGF0ZSgpID09PSBcImNoZWNrZWRcIiAvKiBDaGVja2VkICovKSB7XG4gICAgICAgIGl0ZW0uc2V0VW5jaGVja2VkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVtLnNldENoZWNrZWQoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldENoZWNrZWRTdGF0ZTogKHsgaXRlbSwgdHJlZSB9KSA9PiB7XG4gICAgICBjb25zdCB7IGNoZWNrZWRJdGVtcyB9ID0gdHJlZS5nZXRTdGF0ZSgpO1xuICAgICAgY29uc3QgeyBwcm9wYWdhdGVDaGVja2VkU3RhdGUgfSA9IHRyZWUuZ2V0Q29uZmlnKCk7XG4gICAgICBjb25zdCBpdGVtSWQgPSBpdGVtLmdldElkKCk7XG4gICAgICBpZiAoY2hlY2tlZEl0ZW1zLmluY2x1ZGVzKGl0ZW1JZCkpIHtcbiAgICAgICAgcmV0dXJuIFwiY2hlY2tlZFwiIC8qIENoZWNrZWQgKi87XG4gICAgICB9XG4gICAgICBpZiAoaXRlbS5pc0ZvbGRlcigpICYmIHByb3BhZ2F0ZUNoZWNrZWRTdGF0ZSkge1xuICAgICAgICBjb25zdCBkZXNjZW5kYW50cyA9IGdldEFsbExvYWRlZERlc2NlbmRhbnRzKHRyZWUsIGl0ZW1JZCk7XG4gICAgICAgIGlmIChkZXNjZW5kYW50cy5ldmVyeSgoZCkgPT4gY2hlY2tlZEl0ZW1zLmluY2x1ZGVzKGQpKSkge1xuICAgICAgICAgIHJldHVybiBcImNoZWNrZWRcIiAvKiBDaGVja2VkICovO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXNjZW5kYW50cy5zb21lKChkKSA9PiBjaGVja2VkSXRlbXMuaW5jbHVkZXMoZCkpKSB7XG4gICAgICAgICAgcmV0dXJuIFwiaW5kZXRlcm1pbmF0ZVwiIC8qIEluZGV0ZXJtaW5hdGUgKi87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBcInVuY2hlY2tlZFwiIC8qIFVuY2hlY2tlZCAqLztcbiAgICB9LFxuICAgIHNldENoZWNrZWQ6ICh7IGl0ZW0sIHRyZWUsIGl0ZW1JZCB9KSA9PiB7XG4gICAgICBjb25zdCB7IHByb3BhZ2F0ZUNoZWNrZWRTdGF0ZSwgY2FuQ2hlY2tGb2xkZXJzIH0gPSB0cmVlLmdldENvbmZpZygpO1xuICAgICAgaWYgKGl0ZW0uaXNGb2xkZXIoKSAmJiBwcm9wYWdhdGVDaGVja2VkU3RhdGUpIHtcbiAgICAgICAgdHJlZS5hcHBseVN1YlN0YXRlVXBkYXRlKFwiY2hlY2tlZEl0ZW1zXCIsIChpdGVtcykgPT4gW1xuICAgICAgICAgIC4uLml0ZW1zLFxuICAgICAgICAgIC4uLmdldEFsbExvYWRlZERlc2NlbmRhbnRzKHRyZWUsIGl0ZW1JZCwgY2FuQ2hlY2tGb2xkZXJzKVxuICAgICAgICBdKTtcbiAgICAgIH0gZWxzZSBpZiAoIWl0ZW0uaXNGb2xkZXIoKSB8fCBjYW5DaGVja0ZvbGRlcnMpIHtcbiAgICAgICAgdHJlZS5hcHBseVN1YlN0YXRlVXBkYXRlKFwiY2hlY2tlZEl0ZW1zXCIsIChpdGVtcykgPT4gWy4uLml0ZW1zLCBpdGVtSWRdKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldFVuY2hlY2tlZDogKHsgaXRlbSwgdHJlZSwgaXRlbUlkIH0pID0+IHtcbiAgICAgIGNvbnN0IHsgcHJvcGFnYXRlQ2hlY2tlZFN0YXRlLCBjYW5DaGVja0ZvbGRlcnMgfSA9IHRyZWUuZ2V0Q29uZmlnKCk7XG4gICAgICBpZiAoaXRlbS5pc0ZvbGRlcigpICYmIHByb3BhZ2F0ZUNoZWNrZWRTdGF0ZSkge1xuICAgICAgICBjb25zdCBkZXNjZW5kYW50cyA9IGdldEFsbExvYWRlZERlc2NlbmRhbnRzKFxuICAgICAgICAgIHRyZWUsXG4gICAgICAgICAgaXRlbUlkLFxuICAgICAgICAgIGNhbkNoZWNrRm9sZGVyc1xuICAgICAgICApO1xuICAgICAgICB0cmVlLmFwcGx5U3ViU3RhdGVVcGRhdGUoXG4gICAgICAgICAgXCJjaGVja2VkSXRlbXNcIixcbiAgICAgICAgICAoaXRlbXMpID0+IGl0ZW1zLmZpbHRlcigoaWQpID0+ICFkZXNjZW5kYW50cy5pbmNsdWRlcyhpZCkgJiYgaWQgIT09IGl0ZW1JZClcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyZWUuYXBwbHlTdWJTdGF0ZVVwZGF0ZShcbiAgICAgICAgICBcImNoZWNrZWRJdGVtc1wiLFxuICAgICAgICAgIChpdGVtcykgPT4gaXRlbXMuZmlsdGVyKChpZCkgPT4gaWQgIT09IGl0ZW1JZClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9mZWF0dXJlcy9ob3RrZXlzLWNvcmUvZmVhdHVyZS50c1xudmFyIHNwZWNpYWxLZXlzID0ge1xuICAvLyBUT0RPOmJyZWFraW5nIGRlcHJlY2F0ZSBhdXRvLWxvd2VyY2FzZVxuICBsZXR0ZXI6IC9eS2V5W0EtWl0kLyxcbiAgbGV0dGVyb3JudW1iZXI6IC9eKEtleVtBLVpdfERpZ2l0WzAtOV0pJC8sXG4gIHBsdXM6IC9eKE51bXBhZEFkZHxQbHVzKSQvLFxuICBtaW51czogL14oTnVtcGFkU3VidHJhY3R8TWludXMpJC8sXG4gIGNvbnRyb2w6IC9eKENvbnRyb2xMZWZ0fENvbnRyb2xSaWdodCkkLyxcbiAgc2hpZnQ6IC9eKFNoaWZ0TGVmdHxTaGlmdFJpZ2h0KSQvXG59O1xudmFyIHRlc3RIb3RrZXlNYXRjaCA9IChwcmVzc2VkS2V5cywgdHJlZSwgaG90a2V5KSA9PiB7XG4gIGNvbnN0IHN1cHBvc2VkS2V5cyA9IGhvdGtleS5ob3RrZXkudG9Mb3dlckNhc2UoKS5zcGxpdChcIitcIik7XG4gIGNvbnN0IGRvS2V5c01hdGNoID0gc3VwcG9zZWRLZXlzLmV2ZXJ5KChrZXkpID0+IHtcbiAgICBpZiAoa2V5IGluIHNwZWNpYWxLZXlzKSB7XG4gICAgICByZXR1cm4gWy4uLnByZXNzZWRLZXlzXS5zb21lKFxuICAgICAgICAocHJlc3NlZEtleSkgPT4gc3BlY2lhbEtleXNba2V5XS50ZXN0KHByZXNzZWRLZXkpXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBwcmVzc2VkS2V5c0xvd2VyQ2FzZSA9IFsuLi5wcmVzc2VkS2V5c10ubWFwKChrKSA9PiBrLnRvTG93ZXJDYXNlKCkpO1xuICAgIGlmIChwcmVzc2VkS2V5c0xvd2VyQ2FzZS5pbmNsdWRlcyhrZXkudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAocHJlc3NlZEtleXNMb3dlckNhc2UuaW5jbHVkZXMoYGtleSR7a2V5LnRvTG93ZXJDYXNlKCl9YCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xuICBjb25zdCBpc0VuYWJsZWQgPSAhaG90a2V5LmlzRW5hYmxlZCB8fCBob3RrZXkuaXNFbmFibGVkKHRyZWUpO1xuICBjb25zdCBlcXVhbENvdW50cyA9IHByZXNzZWRLZXlzLnNpemUgPT09IHN1cHBvc2VkS2V5cy5sZW5ndGg7XG4gIHJldHVybiBkb0tleXNNYXRjaCAmJiBpc0VuYWJsZWQgJiYgZXF1YWxDb3VudHM7XG59O1xudmFyIGZpbmRIb3RrZXlNYXRjaCA9IChwcmVzc2VkS2V5cywgdHJlZSwgY29uZmlnMSwgY29uZmlnMikgPT4ge1xuICB2YXIgX2E7XG4gIHJldHVybiAoX2EgPSBPYmplY3QuZW50cmllcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgY29uZmlnMSksIGNvbmZpZzIpKS5maW5kKFxuICAgIChbLCBob3RrZXldKSA9PiB0ZXN0SG90a2V5TWF0Y2gocHJlc3NlZEtleXMsIHRyZWUsIGhvdGtleSlcbiAgKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hWzBdO1xufTtcbnZhciBob3RrZXlzQ29yZUZlYXR1cmUgPSB7XG4gIGtleTogXCJob3RrZXlzLWNvcmVcIixcbiAgb25UcmVlTW91bnQ6ICh0cmVlLCBlbGVtZW50KSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IHRyZWUuZ2V0RGF0YVJlZigpO1xuICAgIGNvbnN0IGtleWRvd24gPSAoZSkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGNvbnN0IHsgaWdub3JlSG90a2V5c09uSW5wdXRzLCBvblRyZWVIb3RrZXksIGhvdGtleXMgfSA9IHRyZWUuZ2V0Q29uZmlnKCk7XG4gICAgICBpZiAoZS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50ICYmIGlnbm9yZUhvdGtleXNPbklucHV0cykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAoX2IgPSAoX2EgPSBkYXRhLmN1cnJlbnQpLnByZXNzZWRLZXlzKSAhPSBudWxsID8gX2IgOiBfYS5wcmVzc2VkS2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICBjb25zdCBuZXdNYXRjaCA9ICFkYXRhLmN1cnJlbnQucHJlc3NlZEtleXMuaGFzKGUuY29kZSk7XG4gICAgICBkYXRhLmN1cnJlbnQucHJlc3NlZEtleXMuYWRkKGUuY29kZSk7XG4gICAgICBjb25zdCBob3RrZXlOYW1lID0gZmluZEhvdGtleU1hdGNoKFxuICAgICAgICBkYXRhLmN1cnJlbnQucHJlc3NlZEtleXMsXG4gICAgICAgIHRyZWUsXG4gICAgICAgIHRyZWUuZ2V0SG90a2V5UHJlc2V0cygpLFxuICAgICAgICBob3RrZXlzXG4gICAgICApO1xuICAgICAgaWYgKGUudGFyZ2V0IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCkge1xuICAgICAgICBkYXRhLmN1cnJlbnQucHJlc3NlZEtleXMuZGVsZXRlKGUuY29kZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWhvdGtleU5hbWUpIHJldHVybjtcbiAgICAgIGNvbnN0IGhvdGtleUNvbmZpZyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCB0cmVlLmdldEhvdGtleVByZXNldHMoKVtob3RrZXlOYW1lXSksIGhvdGtleXMgPT0gbnVsbCA/IHZvaWQgMCA6IGhvdGtleXNbaG90a2V5TmFtZV0pO1xuICAgICAgaWYgKCFob3RrZXlDb25maWcpIHJldHVybjtcbiAgICAgIGlmICghaG90a2V5Q29uZmlnLmFsbG93V2hlbklucHV0Rm9jdXNlZCAmJiBlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICghaG90a2V5Q29uZmlnLmNhblJlcGVhdCAmJiAhbmV3TWF0Y2gpIHJldHVybjtcbiAgICAgIGlmIChob3RrZXlDb25maWcucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGhvdGtleUNvbmZpZy5oYW5kbGVyKGUsIHRyZWUpO1xuICAgICAgb25UcmVlSG90a2V5ID09IG51bGwgPyB2b2lkIDAgOiBvblRyZWVIb3RrZXkoaG90a2V5TmFtZSwgZSk7XG4gICAgfTtcbiAgICBjb25zdCBrZXl1cCA9IChlKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgKF9iID0gKF9hID0gZGF0YS5jdXJyZW50KS5wcmVzc2VkS2V5cykgIT0gbnVsbCA/IF9iIDogX2EucHJlc3NlZEtleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgZGF0YS5jdXJyZW50LnByZXNzZWRLZXlzLmRlbGV0ZShlLmNvZGUpO1xuICAgIH07XG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICBkYXRhLmN1cnJlbnQucHJlc3NlZEtleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIH07XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBrZXlkb3duKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwga2V5dXApO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgcmVzZXQpO1xuICAgIGRhdGEuY3VycmVudC5rZXlkb3duSGFuZGxlciA9IGtleWRvd247XG4gICAgZGF0YS5jdXJyZW50LmtleXVwSGFuZGxlciA9IGtleXVwO1xuICAgIGRhdGEuY3VycmVudC5yZXNldEhhbmRsZXIgPSByZXNldDtcbiAgfSxcbiAgb25UcmVlVW5tb3VudDogKHRyZWUsIGVsZW1lbnQpID0+IHtcbiAgICBjb25zdCBkYXRhID0gdHJlZS5nZXREYXRhUmVmKCk7XG4gICAgaWYgKGRhdGEuY3VycmVudC5rZXl1cEhhbmRsZXIpIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBkYXRhLmN1cnJlbnQua2V5dXBIYW5kbGVyKTtcbiAgICAgIGRlbGV0ZSBkYXRhLmN1cnJlbnQua2V5dXBIYW5kbGVyO1xuICAgIH1cbiAgICBpZiAoZGF0YS5jdXJyZW50LmtleWRvd25IYW5kbGVyKSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGRhdGEuY3VycmVudC5rZXlkb3duSGFuZGxlcik7XG4gICAgICBkZWxldGUgZGF0YS5jdXJyZW50LmtleWRvd25IYW5kbGVyO1xuICAgIH1cbiAgICBpZiAoZGF0YS5jdXJyZW50LnJlc2V0SGFuZGxlcikge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBkYXRhLmN1cnJlbnQucmVzZXRIYW5kbGVyKTtcbiAgICAgIGRlbGV0ZSBkYXRhLmN1cnJlbnQucmVzZXRIYW5kbGVyO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2ZlYXR1cmVzL2FzeW5jLWRhdGEtbG9hZGVyL2ZlYXR1cmUudHNcbnZhciBnZXREYXRhUmVmID0gKHRyZWUpID0+IHtcbiAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICBjb25zdCBkYXRhUmVmID0gdHJlZS5nZXREYXRhUmVmKCk7XG4gIChfYiA9IChfYSA9IGRhdGFSZWYuY3VycmVudCkuaXRlbURhdGEpICE9IG51bGwgPyBfYiA6IF9hLml0ZW1EYXRhID0ge307XG4gIChfZCA9IChfYyA9IGRhdGFSZWYuY3VycmVudCkuY2hpbGRyZW5JZHMpICE9IG51bGwgPyBfZCA6IF9jLmNoaWxkcmVuSWRzID0ge307XG4gIHJldHVybiBkYXRhUmVmO1xufTtcbnZhciBsb2FkSXRlbURhdGEgPSAodHJlZSwgaXRlbUlkKSA9PiBfX2FzeW5jKG51bGwsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgY29uZmlnID0gdHJlZS5nZXRDb25maWcoKTtcbiAgY29uc3QgZGF0YVJlZiA9IGdldERhdGFSZWYodHJlZSk7XG4gIGNvbnN0IGl0ZW0gPSB5aWVsZCBjb25maWcuZGF0YUxvYWRlci5nZXRJdGVtKGl0ZW1JZCk7XG4gIGRhdGFSZWYuY3VycmVudC5pdGVtRGF0YVtpdGVtSWRdID0gaXRlbTtcbiAgKF9hID0gY29uZmlnLm9uTG9hZGVkSXRlbSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoY29uZmlnLCBpdGVtSWQsIGl0ZW0pO1xuICB0cmVlLmFwcGx5U3ViU3RhdGVVcGRhdGUoXG4gICAgXCJsb2FkaW5nSXRlbURhdGFcIixcbiAgICAobG9hZGluZ0l0ZW1EYXRhKSA9PiBsb2FkaW5nSXRlbURhdGEuZmlsdGVyKChpZCkgPT4gaWQgIT09IGl0ZW1JZClcbiAgKTtcbiAgcmV0dXJuIGl0ZW07XG59KTtcbnZhciBsb2FkQ2hpbGRyZW5JZHMgPSAodHJlZSwgaXRlbUlkKSA9PiBfX2FzeW5jKG51bGwsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IGNvbmZpZyA9IHRyZWUuZ2V0Q29uZmlnKCk7XG4gIGNvbnN0IGRhdGFSZWYgPSBnZXREYXRhUmVmKHRyZWUpO1xuICBsZXQgY2hpbGRyZW5JZHM7XG4gIGlmIChcImdldENoaWxkcmVuV2l0aERhdGFcIiBpbiBjb25maWcuZGF0YUxvYWRlcikge1xuICAgIGNvbnN0IGNoaWxkcmVuID0geWllbGQgY29uZmlnLmRhdGFMb2FkZXIuZ2V0Q2hpbGRyZW5XaXRoRGF0YShpdGVtSWQpO1xuICAgIGNoaWxkcmVuSWRzID0gY2hpbGRyZW4ubWFwKChjKSA9PiBjLmlkKTtcbiAgICBkYXRhUmVmLmN1cnJlbnQuY2hpbGRyZW5JZHNbaXRlbUlkXSA9IGNoaWxkcmVuSWRzO1xuICAgIGNoaWxkcmVuLmZvckVhY2goKHsgaWQsIGRhdGEgfSkgPT4ge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIGRhdGFSZWYuY3VycmVudC5pdGVtRGF0YVtpZF0gPSBkYXRhO1xuICAgICAgKF9hMiA9IGNvbmZpZy5vbkxvYWRlZEl0ZW0pID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY2FsbChjb25maWcsIGlkLCBkYXRhKTtcbiAgICB9KTtcbiAgICAoX2EgPSBjb25maWcub25Mb2FkZWRDaGlsZHJlbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoY29uZmlnLCBpdGVtSWQsIGNoaWxkcmVuSWRzKTtcbiAgICB0cmVlLnJlYnVpbGRUcmVlKCk7XG4gICAgdHJlZS5hcHBseVN1YlN0YXRlVXBkYXRlKFxuICAgICAgXCJsb2FkaW5nSXRlbURhdGFcIixcbiAgICAgIChsb2FkaW5nSXRlbURhdGEpID0+IGxvYWRpbmdJdGVtRGF0YS5maWx0ZXIoKGlkKSA9PiAhY2hpbGRyZW5JZHMuaW5jbHVkZXMoaWQpKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgY2hpbGRyZW5JZHMgPSB5aWVsZCBjb25maWcuZGF0YUxvYWRlci5nZXRDaGlsZHJlbihpdGVtSWQpO1xuICAgIGRhdGFSZWYuY3VycmVudC5jaGlsZHJlbklkc1tpdGVtSWRdID0gY2hpbGRyZW5JZHM7XG4gICAgKF9iID0gY29uZmlnLm9uTG9hZGVkQ2hpbGRyZW4pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKGNvbmZpZywgaXRlbUlkLCBjaGlsZHJlbklkcyk7XG4gICAgdHJlZS5yZWJ1aWxkVHJlZSgpO1xuICB9XG4gIHRyZWUuYXBwbHlTdWJTdGF0ZVVwZGF0ZShcbiAgICBcImxvYWRpbmdJdGVtQ2hpbGRyZW5zXCIsXG4gICAgKGxvYWRpbmdJdGVtQ2hpbGRyZW5zKSA9PiBsb2FkaW5nSXRlbUNoaWxkcmVucy5maWx0ZXIoKGlkKSA9PiBpZCAhPT0gaXRlbUlkKVxuICApO1xuICByZXR1cm4gY2hpbGRyZW5JZHM7XG59KTtcbnZhciBhc3luY0RhdGFMb2FkZXJGZWF0dXJlID0ge1xuICBrZXk6IFwiYXN5bmMtZGF0YS1sb2FkZXJcIixcbiAgZ2V0SW5pdGlhbFN0YXRlOiAoaW5pdGlhbFN0YXRlKSA9PiBfX3NwcmVhZFZhbHVlcyh7XG4gICAgbG9hZGluZ0l0ZW1EYXRhOiBbXSxcbiAgICBsb2FkaW5nSXRlbUNoaWxkcmVuczogW11cbiAgfSwgaW5pdGlhbFN0YXRlKSxcbiAgZ2V0RGVmYXVsdENvbmZpZzogKGRlZmF1bHRDb25maWcsIHRyZWUpID0+IF9fc3ByZWFkVmFsdWVzKHtcbiAgICBzZXRMb2FkaW5nSXRlbURhdGE6IG1ha2VTdGF0ZVVwZGF0ZXIoXCJsb2FkaW5nSXRlbURhdGFcIiwgdHJlZSksXG4gICAgc2V0TG9hZGluZ0l0ZW1DaGlsZHJlbnM6IG1ha2VTdGF0ZVVwZGF0ZXIoXCJsb2FkaW5nSXRlbUNoaWxkcmVuc1wiLCB0cmVlKVxuICB9LCBkZWZhdWx0Q29uZmlnKSxcbiAgc3RhdGVIYW5kbGVyTmFtZXM6IHtcbiAgICBsb2FkaW5nSXRlbURhdGE6IFwic2V0TG9hZGluZ0l0ZW1EYXRhXCIsXG4gICAgbG9hZGluZ0l0ZW1DaGlsZHJlbnM6IFwic2V0TG9hZGluZ0l0ZW1DaGlsZHJlbnNcIlxuICB9LFxuICB0cmVlSW5zdGFuY2U6IHtcbiAgICB3YWl0Rm9ySXRlbURhdGFMb2FkZWQ6ICh7IHRyZWUgfSwgaXRlbUlkKSA9PiB0cmVlLmxvYWRJdGVtRGF0YShpdGVtSWQpLFxuICAgIHdhaXRGb3JJdGVtQ2hpbGRyZW5Mb2FkZWQ6ICh7IHRyZWUgfSwgaXRlbUlkKSA9PiB0cmVlLmxvYWRDaGlsZHJlbklkcyhpdGVtSWQpLFxuICAgIGxvYWRJdGVtRGF0YTogKF8wLCBfMSkgPT4gX19hc3luYyhudWxsLCBbXzAsIF8xXSwgZnVuY3Rpb24qICh7IHRyZWUgfSwgaXRlbUlkKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gKF9hID0gZ2V0RGF0YVJlZih0cmVlKS5jdXJyZW50Lml0ZW1EYXRhW2l0ZW1JZF0pICE9IG51bGwgPyBfYSA6IHlpZWxkIGxvYWRJdGVtRGF0YSh0cmVlLCBpdGVtSWQpO1xuICAgIH0pLFxuICAgIGxvYWRDaGlsZHJlbklkczogKF8wLCBfMSkgPT4gX19hc3luYyhudWxsLCBbXzAsIF8xXSwgZnVuY3Rpb24qICh7IHRyZWUgfSwgaXRlbUlkKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gKF9hID0gZ2V0RGF0YVJlZih0cmVlKS5jdXJyZW50LmNoaWxkcmVuSWRzW2l0ZW1JZF0pICE9IG51bGwgPyBfYSA6IHlpZWxkIGxvYWRDaGlsZHJlbklkcyh0cmVlLCBpdGVtSWQpO1xuICAgIH0pLFxuICAgIHJldHJpZXZlSXRlbURhdGE6ICh7IHRyZWUgfSwgaXRlbUlkLCBza2lwRmV0Y2ggPSBmYWxzZSkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHRyZWUuZ2V0Q29uZmlnKCk7XG4gICAgICBjb25zdCBkYXRhUmVmID0gZ2V0RGF0YVJlZih0cmVlKTtcbiAgICAgIGlmIChkYXRhUmVmLmN1cnJlbnQuaXRlbURhdGFbaXRlbUlkXSkge1xuICAgICAgICByZXR1cm4gZGF0YVJlZi5jdXJyZW50Lml0ZW1EYXRhW2l0ZW1JZF07XG4gICAgICB9XG4gICAgICBpZiAoIXRyZWUuZ2V0U3RhdGUoKS5sb2FkaW5nSXRlbURhdGEuaW5jbHVkZXMoaXRlbUlkKSAmJiAhc2tpcEZldGNoKSB7XG4gICAgICAgIHRyZWUuYXBwbHlTdWJTdGF0ZVVwZGF0ZShcImxvYWRpbmdJdGVtRGF0YVwiLCAobG9hZGluZ0l0ZW1EYXRhKSA9PiBbXG4gICAgICAgICAgLi4ubG9hZGluZ0l0ZW1EYXRhLFxuICAgICAgICAgIGl0ZW1JZFxuICAgICAgICBdKTtcbiAgICAgICAgbG9hZEl0ZW1EYXRhKHRyZWUsIGl0ZW1JZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKF9iID0gKF9hID0gY29uZmlnLmNyZWF0ZUxvYWRpbmdJdGVtRGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoY29uZmlnKSkgIT0gbnVsbCA/IF9iIDogbnVsbDtcbiAgICB9LFxuICAgIHJldHJpZXZlQ2hpbGRyZW5JZHM6ICh7IHRyZWUgfSwgaXRlbUlkLCBza2lwRmV0Y2ggPSBmYWxzZSkgPT4ge1xuICAgICAgY29uc3QgZGF0YVJlZiA9IGdldERhdGFSZWYodHJlZSk7XG4gICAgICBpZiAoZGF0YVJlZi5jdXJyZW50LmNoaWxkcmVuSWRzW2l0ZW1JZF0pIHtcbiAgICAgICAgcmV0dXJuIGRhdGFSZWYuY3VycmVudC5jaGlsZHJlbklkc1tpdGVtSWRdO1xuICAgICAgfVxuICAgICAgaWYgKHRyZWUuZ2V0U3RhdGUoKS5sb2FkaW5nSXRlbUNoaWxkcmVucy5pbmNsdWRlcyhpdGVtSWQpIHx8IHNraXBGZXRjaCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB0cmVlLmFwcGx5U3ViU3RhdGVVcGRhdGUoXG4gICAgICAgIFwibG9hZGluZ0l0ZW1DaGlsZHJlbnNcIixcbiAgICAgICAgKGxvYWRpbmdJdGVtQ2hpbGRyZW5zKSA9PiBbLi4ubG9hZGluZ0l0ZW1DaGlsZHJlbnMsIGl0ZW1JZF1cbiAgICAgICk7XG4gICAgICBsb2FkQ2hpbGRyZW5JZHModHJlZSwgaXRlbUlkKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH0sXG4gIGl0ZW1JbnN0YW5jZToge1xuICAgIGlzTG9hZGluZzogKHsgdHJlZSwgaXRlbSB9KSA9PiB0cmVlLmdldFN0YXRlKCkubG9hZGluZ0l0ZW1EYXRhLmluY2x1ZGVzKGl0ZW0uZ2V0SXRlbU1ldGEoKS5pdGVtSWQpIHx8IHRyZWUuZ2V0U3RhdGUoKS5sb2FkaW5nSXRlbUNoaWxkcmVucy5pbmNsdWRlcyhpdGVtLmdldEl0ZW1NZXRhKCkuaXRlbUlkKSxcbiAgICBpbnZhbGlkYXRlSXRlbURhdGE6IChfMCwgXzEpID0+IF9fYXN5bmMobnVsbCwgW18wLCBfMV0sIGZ1bmN0aW9uKiAoeyB0cmVlLCBpdGVtSWQgfSwgb3B0aW1pc3RpYykge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKCFvcHRpbWlzdGljKSB7XG4gICAgICAgIChfYSA9IGdldERhdGFSZWYodHJlZSkuY3VycmVudC5pdGVtRGF0YSkgPT0gbnVsbCA/IHRydWUgOiBkZWxldGUgX2FbaXRlbUlkXTtcbiAgICAgICAgdHJlZS5hcHBseVN1YlN0YXRlVXBkYXRlKFwibG9hZGluZ0l0ZW1EYXRhXCIsIChsb2FkaW5nSXRlbURhdGEpID0+IFtcbiAgICAgICAgICAuLi5sb2FkaW5nSXRlbURhdGEsXG4gICAgICAgICAgaXRlbUlkXG4gICAgICAgIF0pO1xuICAgICAgfVxuICAgICAgeWllbGQgbG9hZEl0ZW1EYXRhKHRyZWUsIGl0ZW1JZCk7XG4gICAgfSksXG4gICAgaW52YWxpZGF0ZUNoaWxkcmVuSWRzOiAoXzAsIF8xKSA9PiBfX2FzeW5jKG51bGwsIFtfMCwgXzFdLCBmdW5jdGlvbiogKHsgdHJlZSwgaXRlbUlkIH0sIG9wdGltaXN0aWMpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICghb3B0aW1pc3RpYykge1xuICAgICAgICAoX2EgPSBnZXREYXRhUmVmKHRyZWUpLmN1cnJlbnQuY2hpbGRyZW5JZHMpID09IG51bGwgPyB0cnVlIDogZGVsZXRlIF9hW2l0ZW1JZF07XG4gICAgICAgIHRyZWUuYXBwbHlTdWJTdGF0ZVVwZGF0ZShcbiAgICAgICAgICBcImxvYWRpbmdJdGVtQ2hpbGRyZW5zXCIsXG4gICAgICAgICAgKGxvYWRpbmdJdGVtQ2hpbGRyZW5zKSA9PiBbLi4ubG9hZGluZ0l0ZW1DaGlsZHJlbnMsIGl0ZW1JZF1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIGxvYWRDaGlsZHJlbklkcyh0cmVlLCBpdGVtSWQpO1xuICAgIH0pLFxuICAgIHVwZGF0ZUNhY2hlZENoaWxkcmVuSWRzOiAoeyB0cmVlLCBpdGVtSWQgfSwgY2hpbGRyZW5JZHMpID0+IHtcbiAgICAgIGNvbnN0IGRhdGFSZWYgPSB0cmVlLmdldERhdGFSZWYoKTtcbiAgICAgIGRhdGFSZWYuY3VycmVudC5jaGlsZHJlbklkc1tpdGVtSWRdID0gY2hpbGRyZW5JZHM7XG4gICAgICB0cmVlLnJlYnVpbGRUcmVlKCk7XG4gICAgfSxcbiAgICB1cGRhdGVDYWNoZWREYXRhOiAoeyB0cmVlLCBpdGVtSWQgfSwgZGF0YSkgPT4ge1xuICAgICAgY29uc3QgZGF0YVJlZiA9IHRyZWUuZ2V0RGF0YVJlZigpO1xuICAgICAgZGF0YVJlZi5jdXJyZW50Lml0ZW1EYXRhW2l0ZW1JZF0gPSBkYXRhO1xuICAgICAgdHJlZS5yZWJ1aWxkVHJlZSgpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2ZlYXR1cmVzL3N5bmMtZGF0YS1sb2FkZXIvZmVhdHVyZS50c1xudmFyIHVuZGVmRXJyb3JNZXNzYWdlID0gXCJzeW5jIGRhdGFMb2FkZXIgcmV0dXJuZWQgdW5kZWZpbmVkXCI7XG52YXIgcHJvbWlzZUVycm9yTWVzc2FnZSA9IFwic3luYyBkYXRhTG9hZGVyIHJldHVybmVkIHByb21pc2VcIjtcbnZhciB1bnByb21pc2UgPSAoZGF0YSkgPT4ge1xuICBpZiAoIWRhdGEpIHtcbiAgICB0aHJvdyB0aHJvd0Vycm9yKHVuZGVmRXJyb3JNZXNzYWdlKTtcbiAgfVxuICBpZiAodHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIgJiYgXCJ0aGVuXCIgaW4gZGF0YSkge1xuICAgIHRocm93IHRocm93RXJyb3IocHJvbWlzZUVycm9yTWVzc2FnZSk7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59O1xudmFyIHN5bmNEYXRhTG9hZGVyRmVhdHVyZSA9IHtcbiAga2V5OiBcInN5bmMtZGF0YS1sb2FkZXJcIixcbiAgZ2V0SW5pdGlhbFN0YXRlOiAoaW5pdGlhbFN0YXRlKSA9PiBfX3NwcmVhZFZhbHVlcyh7XG4gICAgbG9hZGluZ0l0ZW1EYXRhOiBbXSxcbiAgICBsb2FkaW5nSXRlbUNoaWxkcmVuczogW11cbiAgfSwgaW5pdGlhbFN0YXRlKSxcbiAgZ2V0RGVmYXVsdENvbmZpZzogKGRlZmF1bHRDb25maWcsIHRyZWUpID0+IF9fc3ByZWFkVmFsdWVzKHtcbiAgICBzZXRMb2FkaW5nSXRlbURhdGE6IG1ha2VTdGF0ZVVwZGF0ZXIoXCJsb2FkaW5nSXRlbURhdGFcIiwgdHJlZSksXG4gICAgc2V0TG9hZGluZ0l0ZW1DaGlsZHJlbnM6IG1ha2VTdGF0ZVVwZGF0ZXIoXCJsb2FkaW5nSXRlbUNoaWxkcmVuc1wiLCB0cmVlKVxuICB9LCBkZWZhdWx0Q29uZmlnKSxcbiAgc3RhdGVIYW5kbGVyTmFtZXM6IHtcbiAgICBsb2FkaW5nSXRlbURhdGE6IFwic2V0TG9hZGluZ0l0ZW1EYXRhXCIsXG4gICAgbG9hZGluZ0l0ZW1DaGlsZHJlbnM6IFwic2V0TG9hZGluZ0l0ZW1DaGlsZHJlbnNcIlxuICB9LFxuICB0cmVlSW5zdGFuY2U6IHtcbiAgICB3YWl0Rm9ySXRlbURhdGFMb2FkZWQ6ICgpID0+IF9fYXN5bmMobnVsbCwgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICB9KSxcbiAgICB3YWl0Rm9ySXRlbUNoaWxkcmVuTG9hZGVkOiAoKSA9PiBfX2FzeW5jKG51bGwsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgfSksXG4gICAgcmV0cmlldmVJdGVtRGF0YTogKHsgdHJlZSB9LCBpdGVtSWQpID0+IHtcbiAgICAgIHJldHVybiB1bnByb21pc2UodHJlZS5nZXRDb25maWcoKS5kYXRhTG9hZGVyLmdldEl0ZW0oaXRlbUlkKSk7XG4gICAgfSxcbiAgICByZXRyaWV2ZUNoaWxkcmVuSWRzOiAoeyB0cmVlIH0sIGl0ZW1JZCkgPT4ge1xuICAgICAgY29uc3QgeyBkYXRhTG9hZGVyIH0gPSB0cmVlLmdldENvbmZpZygpO1xuICAgICAgaWYgKFwiZ2V0Q2hpbGRyZW5cIiBpbiBkYXRhTG9hZGVyKSB7XG4gICAgICAgIHJldHVybiB1bnByb21pc2UoZGF0YUxvYWRlci5nZXRDaGlsZHJlbihpdGVtSWQpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bnByb21pc2UoZGF0YUxvYWRlci5nZXRDaGlsZHJlbldpdGhEYXRhKGl0ZW1JZCkpLm1hcChcbiAgICAgICAgKGMpID0+IGMuZGF0YVxuICAgICAgKTtcbiAgICB9LFxuICAgIGxvYWRJdGVtRGF0YTogKHsgdHJlZSB9LCBpdGVtSWQpID0+IHRyZWUucmV0cmlldmVJdGVtRGF0YShpdGVtSWQpLFxuICAgIGxvYWRDaGlsZHJlbklkczogKHsgdHJlZSB9LCBpdGVtSWQpID0+IHRyZWUucmV0cmlldmVDaGlsZHJlbklkcyhpdGVtSWQpXG4gIH0sXG4gIGl0ZW1JbnN0YW5jZToge1xuICAgIGlzTG9hZGluZzogKCkgPT4gZmFsc2VcbiAgfVxufTtcblxuLy8gc3JjL2ZlYXR1cmVzL2RyYWctYW5kLWRyb3AvdXRpbHMudHNcbnZhciBpc09yZGVyZWREcmFnVGFyZ2V0ID0gKGRyYWdUYXJnZXQpID0+IFwiY2hpbGRJbmRleFwiIGluIGRyYWdUYXJnZXQ7XG52YXIgY2FuRHJvcCA9IChkYXRhVHJhbnNmZXIsIHRhcmdldCwgdHJlZSkgPT4ge1xuICB2YXIgX2EsIF9iLCBfYztcbiAgY29uc3QgZHJhZ2dlZEl0ZW1zID0gKF9hID0gdHJlZS5nZXRTdGF0ZSgpLmRuZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRyYWdnZWRJdGVtcztcbiAgY29uc3QgY29uZmlnID0gdHJlZS5nZXRDb25maWcoKTtcbiAgaWYgKGRyYWdnZWRJdGVtcyAmJiAhKChfYyA9IChfYiA9IGNvbmZpZy5jYW5Ecm9wKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChjb25maWcsIGRyYWdnZWRJdGVtcywgdGFyZ2V0KSkgIT0gbnVsbCA/IF9jIDogdHJ1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGRyYWdnZWRJdGVtcyAmJiBkcmFnZ2VkSXRlbXMuc29tZShcbiAgICAoZHJhZ2dlZEl0ZW0pID0+IHRhcmdldC5pdGVtLmdldElkKCkgPT09IGRyYWdnZWRJdGVtLmdldElkKCkgfHwgdGFyZ2V0Lml0ZW0uaXNEZXNjZW5kZW50T2YoZHJhZ2dlZEl0ZW0uZ2V0SWQoKSlcbiAgKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIWRyYWdnZWRJdGVtcyAmJiBkYXRhVHJhbnNmZXIgJiYgY29uZmlnLmNhbkRyb3BGb3JlaWduRHJhZ09iamVjdCAmJiAhY29uZmlnLmNhbkRyb3BGb3JlaWduRHJhZ09iamVjdChkYXRhVHJhbnNmZXIsIHRhcmdldCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIGdldEl0ZW1Ecm9wQ2F0ZWdvcnkgPSAoaXRlbSkgPT4ge1xuICBpZiAoaXRlbS5pc0V4cGFuZGVkKCkpIHtcbiAgICByZXR1cm4gMSAvKiBFeHBhbmRlZEZvbGRlciAqLztcbiAgfVxuICBjb25zdCBwYXJlbnQgPSBpdGVtLmdldFBhcmVudCgpO1xuICBpZiAocGFyZW50ICYmIGl0ZW0uZ2V0SW5kZXhJblBhcmVudCgpID09PSBpdGVtLmdldEl0ZW1NZXRhKCkuc2V0U2l6ZSAtIDEpIHtcbiAgICByZXR1cm4gMiAvKiBMYXN0SW5Hcm91cCAqLztcbiAgfVxuICByZXR1cm4gMCAvKiBJdGVtICovO1xufTtcbnZhciBnZXRJbnNlcnRpb25JbmRleCA9IChjaGlsZHJlbiwgY2hpbGRJbmRleCwgZHJhZ2dlZEl0ZW1zKSA9PiB7XG4gIHZhciBfYTtcbiAgY29uc3QgbnVtYmVyT2ZEcmFnSXRlbXNCZWZvcmVUYXJnZXQgPSAoX2EgPSBjaGlsZHJlbi5zbGljZSgwLCBjaGlsZEluZGV4KS5yZWR1Y2UoXG4gICAgKGNvdW50ZXIsIGNoaWxkKSA9PiBjaGlsZCAmJiAoZHJhZ2dlZEl0ZW1zID09IG51bGwgPyB2b2lkIDAgOiBkcmFnZ2VkSXRlbXMuc29tZSgoaSkgPT4gaS5nZXRJZCgpID09PSBjaGlsZC5nZXRJZCgpKSkgPyArK2NvdW50ZXIgOiBjb3VudGVyLFxuICAgIDBcbiAgKSkgIT0gbnVsbCA/IF9hIDogMDtcbiAgcmV0dXJuIGNoaWxkSW5kZXggLSBudW1iZXJPZkRyYWdJdGVtc0JlZm9yZVRhcmdldDtcbn07XG52YXIgZ2V0VGFyZ2V0UGxhY2VtZW50ID0gKGUsIGl0ZW0sIHRyZWUsIGNhbk1ha2VDaGlsZCkgPT4ge1xuICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICBjb25zdCBjb25maWcgPSB0cmVlLmdldENvbmZpZygpO1xuICBpZiAoIWNvbmZpZy5jYW5SZW9yZGVyKSB7XG4gICAgcmV0dXJuIGNhbk1ha2VDaGlsZCA/IHsgdHlwZTogMiAvKiBNYWtlQ2hpbGQgKi8gfSA6IHsgdHlwZTogMSAvKiBSZW9yZGVyQmVsb3cgKi8gfTtcbiAgfVxuICBjb25zdCBiYiA9IChfYSA9IGl0ZW0uZ2V0RWxlbWVudCgpKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IHRvcFBlcmNlbnQgPSBiYiA/IChlLmNsaWVudFkgLSBiYi50b3ApIC8gYmIuaGVpZ2h0IDogMC41O1xuICBjb25zdCBsZWZ0UGl4ZWxzID0gYmIgPyBlLmNsaWVudFggLSBiYi5sZWZ0IDogMDtcbiAgY29uc3QgdGFyZ2V0RHJvcENhdGVnb3J5ID0gZ2V0SXRlbURyb3BDYXRlZ29yeShpdGVtKTtcbiAgY29uc3QgcmVvcmRlckFyZWFQZXJjZW50YWdlID0gIWNhbk1ha2VDaGlsZCA/IDAuNSA6IChfYiA9IGNvbmZpZy5yZW9yZGVyQXJlYVBlcmNlbnRhZ2UpICE9IG51bGwgPyBfYiA6IDAuMztcbiAgY29uc3QgaW5kZW50ID0gKF9jID0gY29uZmlnLmluZGVudCkgIT0gbnVsbCA/IF9jIDogMjA7XG4gIGNvbnN0IG1ha2VDaGlsZFR5cGUgPSBjYW5NYWtlQ2hpbGQgPyAyIC8qIE1ha2VDaGlsZCAqLyA6IDEgLyogUmVvcmRlckJlbG93ICovO1xuICBpZiAodGFyZ2V0RHJvcENhdGVnb3J5ID09PSAxIC8qIEV4cGFuZGVkRm9sZGVyICovKSB7XG4gICAgaWYgKHRvcFBlcmNlbnQgPCByZW9yZGVyQXJlYVBlcmNlbnRhZ2UpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IDAgLyogUmVvcmRlckFib3ZlICovIH07XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IG1ha2VDaGlsZFR5cGUgfTtcbiAgfVxuICBpZiAodGFyZ2V0RHJvcENhdGVnb3J5ID09PSAyIC8qIExhc3RJbkdyb3VwICovKSB7XG4gICAgaWYgKGxlZnRQaXhlbHMgPCBpdGVtLmdldEl0ZW1NZXRhKCkubGV2ZWwgKiBpbmRlbnQpIHtcbiAgICAgIGlmICh0b3BQZXJjZW50IDwgMC41KSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IDAgLyogUmVvcmRlckFib3ZlICovIH07XG4gICAgICB9XG4gICAgICBjb25zdCBtaW5MZXZlbCA9IChfZSA9IChfZCA9IGl0ZW0uZ2V0SXRlbUJlbG93KCkpID09IG51bGwgPyB2b2lkIDAgOiBfZC5nZXRJdGVtTWV0YSgpLmxldmVsKSAhPSBudWxsID8gX2UgOiAwO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMyAvKiBSZXBhcmVudCAqLyxcbiAgICAgICAgcmVwYXJlbnRMZXZlbDogTWF0aC5tYXgobWluTGV2ZWwsIE1hdGguZmxvb3IobGVmdFBpeGVscyAvIGluZGVudCkpXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBpZiAodG9wUGVyY2VudCA8IHJlb3JkZXJBcmVhUGVyY2VudGFnZSkge1xuICAgIHJldHVybiB7IHR5cGU6IDAgLyogUmVvcmRlckFib3ZlICovIH07XG4gIH1cbiAgaWYgKHRvcFBlcmNlbnQgPiAxIC0gcmVvcmRlckFyZWFQZXJjZW50YWdlKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogMSAvKiBSZW9yZGVyQmVsb3cgKi8gfTtcbiAgfVxuICByZXR1cm4geyB0eXBlOiBtYWtlQ2hpbGRUeXBlIH07XG59O1xudmFyIGdldERyYWdDb2RlID0gKGl0ZW0sIHBsYWNlbWVudCkgPT4ge1xuICByZXR1cm4gW1xuICAgIGl0ZW0uZ2V0SWQoKSxcbiAgICBwbGFjZW1lbnQudHlwZSxcbiAgICBwbGFjZW1lbnQudHlwZSA9PT0gMyAvKiBSZXBhcmVudCAqLyA/IHBsYWNlbWVudC5yZXBhcmVudExldmVsIDogMFxuICBdLmpvaW4oXCJfX1wiKTtcbn07XG52YXIgZ2V0TnRoUGFyZW50ID0gKGl0ZW0sIG4pID0+IHtcbiAgaWYgKG4gPT09IGl0ZW0uZ2V0SXRlbU1ldGEoKS5sZXZlbCkge1xuICAgIHJldHVybiBpdGVtO1xuICB9XG4gIHJldHVybiBnZXROdGhQYXJlbnQoaXRlbS5nZXRQYXJlbnQoKSwgbik7XG59O1xudmFyIGdldFJlcGFyZW50VGFyZ2V0ID0gKGl0ZW0sIHJlcGFyZW50TGV2ZWwsIGRyYWdnZWRJdGVtcykgPT4ge1xuICBjb25zdCBpdGVtTWV0YSA9IGl0ZW0uZ2V0SXRlbU1ldGEoKTtcbiAgY29uc3QgcmVwYXJlbnRlZFRhcmdldCA9IGdldE50aFBhcmVudChpdGVtLCByZXBhcmVudExldmVsIC0gMSk7XG4gIGNvbnN0IHRhcmdldEl0ZW1BYm92ZSA9IGdldE50aFBhcmVudChpdGVtLCByZXBhcmVudExldmVsKTtcbiAgY29uc3QgdGFyZ2V0SW5kZXggPSB0YXJnZXRJdGVtQWJvdmUuZ2V0SW5kZXhJblBhcmVudCgpICsgMTtcbiAgcmV0dXJuIHtcbiAgICBpdGVtOiByZXBhcmVudGVkVGFyZ2V0LFxuICAgIGNoaWxkSW5kZXg6IHRhcmdldEluZGV4LFxuICAgIGluc2VydGlvbkluZGV4OiBnZXRJbnNlcnRpb25JbmRleChcbiAgICAgIHJlcGFyZW50ZWRUYXJnZXQuZ2V0Q2hpbGRyZW4oKSxcbiAgICAgIHRhcmdldEluZGV4LFxuICAgICAgZHJhZ2dlZEl0ZW1zXG4gICAgKSxcbiAgICBkcmFnTGluZUluZGV4OiBpdGVtTWV0YS5pbmRleCArIDEsXG4gICAgZHJhZ0xpbmVMZXZlbDogcmVwYXJlbnRMZXZlbFxuICB9O1xufTtcbnZhciBnZXREcmFnVGFyZ2V0ID0gKGUsIGl0ZW0sIHRyZWUsIGNhblJlb3JkZXIgPSB0cmVlLmdldENvbmZpZygpLmNhblJlb3JkZXIpID0+IHtcbiAgdmFyIF9hO1xuICBjb25zdCBkcmFnZ2VkSXRlbXMgPSAoX2EgPSB0cmVlLmdldFN0YXRlKCkuZG5kKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZHJhZ2dlZEl0ZW1zO1xuICBjb25zdCBpdGVtTWV0YSA9IGl0ZW0uZ2V0SXRlbU1ldGEoKTtcbiAgY29uc3QgcGFyZW50ID0gaXRlbS5nZXRQYXJlbnQoKTtcbiAgY29uc3QgaXRlbVRhcmdldCA9IHsgaXRlbSB9O1xuICBjb25zdCBwYXJlbnRUYXJnZXQgPSBwYXJlbnQgPyB7IGl0ZW06IHBhcmVudCB9IDogbnVsbDtcbiAgY29uc3QgY2FuQmVjb21lU2libGluZyA9IHBhcmVudFRhcmdldCAmJiBjYW5Ecm9wKGUuZGF0YVRyYW5zZmVyLCBwYXJlbnRUYXJnZXQsIHRyZWUpO1xuICBjb25zdCBjYW5NYWtlQ2hpbGQgPSBjYW5Ecm9wKGUuZGF0YVRyYW5zZmVyLCBpdGVtVGFyZ2V0LCB0cmVlKTtcbiAgY29uc3QgcGxhY2VtZW50ID0gZ2V0VGFyZ2V0UGxhY2VtZW50KGUsIGl0ZW0sIHRyZWUsIGNhbk1ha2VDaGlsZCk7XG4gIGlmICghY2FuUmVvcmRlciAmJiBwYXJlbnQgJiYgY2FuQmVjb21lU2libGluZyAmJiBwbGFjZW1lbnQudHlwZSAhPT0gMiAvKiBNYWtlQ2hpbGQgKi8pIHtcbiAgICBpZiAoZHJhZ2dlZEl0ZW1zID09IG51bGwgPyB2b2lkIDAgOiBkcmFnZ2VkSXRlbXMuc29tZSgoaXRlbTIpID0+IGl0ZW0yLmlzRGVzY2VuZGVudE9mKHBhcmVudC5nZXRJZCgpKSkpIHtcbiAgICAgIHJldHVybiBpdGVtVGFyZ2V0O1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50VGFyZ2V0O1xuICB9XG4gIGlmICghY2FuUmVvcmRlciAmJiBwYXJlbnQgJiYgIWNhbkJlY29tZVNpYmxpbmcpIHtcbiAgICByZXR1cm4gZ2V0RHJhZ1RhcmdldChlLCBwYXJlbnQsIHRyZWUsIGZhbHNlKTtcbiAgfVxuICBpZiAoIXBhcmVudCkge1xuICAgIHJldHVybiBpdGVtVGFyZ2V0O1xuICB9XG4gIGlmIChwbGFjZW1lbnQudHlwZSA9PT0gMiAvKiBNYWtlQ2hpbGQgKi8pIHtcbiAgICByZXR1cm4gaXRlbVRhcmdldDtcbiAgfVxuICBpZiAoIWNhbkJlY29tZVNpYmxpbmcpIHtcbiAgICByZXR1cm4gZ2V0RHJhZ1RhcmdldChlLCBwYXJlbnQsIHRyZWUsIGZhbHNlKTtcbiAgfVxuICBpZiAocGxhY2VtZW50LnR5cGUgPT09IDMgLyogUmVwYXJlbnQgKi8pIHtcbiAgICByZXR1cm4gZ2V0UmVwYXJlbnRUYXJnZXQoaXRlbSwgcGxhY2VtZW50LnJlcGFyZW50TGV2ZWwsIGRyYWdnZWRJdGVtcyk7XG4gIH1cbiAgY29uc3QgbWF5YmVBZGRPbmVGb3JCZWxvdyA9IHBsYWNlbWVudC50eXBlID09PSAwIC8qIFJlb3JkZXJBYm92ZSAqLyA/IDAgOiAxO1xuICBjb25zdCBjaGlsZEluZGV4ID0gaXRlbS5nZXRJbmRleEluUGFyZW50KCkgKyBtYXliZUFkZE9uZUZvckJlbG93O1xuICByZXR1cm4ge1xuICAgIGl0ZW06IHBhcmVudCxcbiAgICBkcmFnTGluZUluZGV4OiBpdGVtTWV0YS5pbmRleCArIG1heWJlQWRkT25lRm9yQmVsb3csXG4gICAgZHJhZ0xpbmVMZXZlbDogaXRlbU1ldGEubGV2ZWwsXG4gICAgY2hpbGRJbmRleCxcbiAgICAvLyBUT0RPIHBlcmZvcm1hbmNlIGNvdWxkIGJlIGltcHJvdmVkIGJ5IGNvbXB1dGluZyB0aGlzIG9ubHkgd2hlbiBkcmFnY29kZSBjaGFuZ2VkXG4gICAgaW5zZXJ0aW9uSW5kZXg6IGdldEluc2VydGlvbkluZGV4KFxuICAgICAgcGFyZW50LmdldENoaWxkcmVuKCksXG4gICAgICBjaGlsZEluZGV4LFxuICAgICAgZHJhZ2dlZEl0ZW1zXG4gICAgKVxuICB9O1xufTtcblxuLy8gc3JjL2ZlYXR1cmVzL2RyYWctYW5kLWRyb3AvZmVhdHVyZS50c1xudmFyIGhhbmRsZUF1dG9PcGVuRm9sZGVyID0gKGRhdGFSZWYsIHRyZWUsIGl0ZW0sIHBsYWNlbWVudCkgPT4ge1xuICBjb25zdCB7IG9wZW5PbkRyb3BEZWxheSB9ID0gdHJlZS5nZXRDb25maWcoKTtcbiAgY29uc3QgZHJhZ0NvZGUgPSBkYXRhUmVmLmN1cnJlbnQubGFzdERyYWdDb2RlO1xuICBpZiAoIW9wZW5PbkRyb3BEZWxheSB8fCAhaXRlbS5pc0ZvbGRlcigpIHx8IGl0ZW0uaXNFeHBhbmRlZCgpIHx8IHBsYWNlbWVudC50eXBlICE9PSAyIC8qIE1ha2VDaGlsZCAqLykge1xuICAgIHJldHVybjtcbiAgfVxuICBjbGVhclRpbWVvdXQoZGF0YVJlZi5jdXJyZW50LmF1dG9FeHBhbmRUaW1lb3V0KTtcbiAgZGF0YVJlZi5jdXJyZW50LmF1dG9FeHBhbmRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgaWYgKGRyYWdDb2RlICE9PSBkYXRhUmVmLmN1cnJlbnQubGFzdERyYWdDb2RlIHx8ICFkYXRhUmVmLmN1cnJlbnQubGFzdEFsbG93RHJvcClcbiAgICAgIHJldHVybjtcbiAgICBpdGVtLmV4cGFuZCgpO1xuICB9LCBvcGVuT25Ecm9wRGVsYXkpO1xufTtcbnZhciBkZWZhdWx0Q2FuRHJvcEZvcmVpZ25EcmFnT2JqZWN0ID0gKCkgPT4gZmFsc2U7XG52YXIgZHJhZ0FuZERyb3BGZWF0dXJlID0ge1xuICBrZXk6IFwiZHJhZy1hbmQtZHJvcFwiLFxuICBnZXREZWZhdWx0Q29uZmlnOiAoZGVmYXVsdENvbmZpZywgdHJlZSkgPT4gX19zcHJlYWRWYWx1ZXMoe1xuICAgIGNhbkRyb3A6IChfLCB0YXJnZXQpID0+IHRhcmdldC5pdGVtLmlzRm9sZGVyKCksXG4gICAgY2FuRHJvcEZvcmVpZ25EcmFnT2JqZWN0OiBkZWZhdWx0Q2FuRHJvcEZvcmVpZ25EcmFnT2JqZWN0LFxuICAgIGNhbkRyYWdGb3JlaWduRHJhZ09iamVjdE92ZXI6IGRlZmF1bHRDb25maWcuY2FuRHJvcEZvcmVpZ25EcmFnT2JqZWN0ICE9PSBkZWZhdWx0Q2FuRHJvcEZvcmVpZ25EcmFnT2JqZWN0ID8gKGRhdGFUcmFuc2ZlcikgPT4gZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgIT09IFwibm9uZVwiIDogKCkgPT4gZmFsc2UsXG4gICAgc2V0RG5kU3RhdGU6IG1ha2VTdGF0ZVVwZGF0ZXIoXCJkbmRcIiwgdHJlZSksXG4gICAgY2FuUmVvcmRlcjogdHJ1ZSxcbiAgICBvcGVuT25Ecm9wRGVsYXk6IDgwMFxuICB9LCBkZWZhdWx0Q29uZmlnKSxcbiAgc3RhdGVIYW5kbGVyTmFtZXM6IHtcbiAgICBkbmQ6IFwic2V0RG5kU3RhdGVcIlxuICB9LFxuICBvblRyZWVNb3VudDogKHRyZWUpID0+IHtcbiAgICBjb25zdCBsaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgIHRyZWUuYXBwbHlTdWJTdGF0ZVVwZGF0ZShcImRuZFwiLCBudWxsKTtcbiAgICB9O1xuICAgIHRyZWUuZ2V0RGF0YVJlZigpLmN1cnJlbnQud2luZG93RHJhZ0VuZExpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnZW5kXCIsIGxpc3RlbmVyKTtcbiAgfSxcbiAgb25UcmVlVW5tb3VudDogKHRyZWUpID0+IHtcbiAgICBjb25zdCB7IHdpbmRvd0RyYWdFbmRMaXN0ZW5lciB9ID0gdHJlZS5nZXREYXRhUmVmKCkuY3VycmVudDtcbiAgICBpZiAoIXdpbmRvd0RyYWdFbmRMaXN0ZW5lcikgcmV0dXJuO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZHJhZ2VuZFwiLCB3aW5kb3dEcmFnRW5kTGlzdGVuZXIpO1xuICB9LFxuICB0cmVlSW5zdGFuY2U6IHtcbiAgICBnZXREcmFnVGFyZ2V0OiAoeyB0cmVlIH0pID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICByZXR1cm4gKF9iID0gKF9hID0gdHJlZS5nZXRTdGF0ZSgpLmRuZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRyYWdUYXJnZXQpICE9IG51bGwgPyBfYiA6IG51bGw7XG4gICAgfSxcbiAgICBnZXREcmFnTGluZURhdGE6ICh7IHRyZWUgfSkgPT4ge1xuICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0cmVlLmdldERyYWdUYXJnZXQoKTtcbiAgICAgIGNvbnN0IGluZGVudCA9ICgoX2EgPSB0YXJnZXQgPT0gbnVsbCA/IHZvaWQgMCA6IHRhcmdldC5pdGVtLmdldEl0ZW1NZXRhKCkubGV2ZWwpICE9IG51bGwgPyBfYSA6IDApICsgMTtcbiAgICAgIGNvbnN0IHRyZWVCYiA9IChfYiA9IHRyZWUuZ2V0RWxlbWVudCgpKSA9PSBudWxsID8gdm9pZCAwIDogX2IuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBpZiAoIXRhcmdldCB8fCAhdHJlZUJiIHx8ICFpc09yZGVyZWREcmFnVGFyZ2V0KHRhcmdldCkpIHJldHVybiBudWxsO1xuICAgICAgY29uc3QgbGVmdE9mZnNldCA9IHRhcmdldC5kcmFnTGluZUxldmVsICogKChfYyA9IHRyZWUuZ2V0Q29uZmlnKCkuaW5kZW50KSAhPSBudWxsID8gX2MgOiAxKTtcbiAgICAgIGNvbnN0IHRhcmdldEl0ZW0gPSB0cmVlLmdldEl0ZW1zKClbdGFyZ2V0LmRyYWdMaW5lSW5kZXhdO1xuICAgICAgaWYgKCF0YXJnZXRJdGVtKSB7XG4gICAgICAgIGNvbnN0IGJiMiA9IChfZSA9IChfZCA9IHRyZWUuZ2V0SXRlbXMoKVt0YXJnZXQuZHJhZ0xpbmVJbmRleCAtIDFdKSA9PSBudWxsID8gdm9pZCAwIDogX2QuZ2V0RWxlbWVudCgpKSA9PSBudWxsID8gdm9pZCAwIDogX2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChiYjIpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5kZW50LFxuICAgICAgICAgICAgdG9wOiBiYjIuYm90dG9tIC0gdHJlZUJiLnRvcCxcbiAgICAgICAgICAgIGxlZnQ6IGJiMi5sZWZ0ICsgbGVmdE9mZnNldCAtIHRyZWVCYi5sZWZ0LFxuICAgICAgICAgICAgd2lkdGg6IGJiMi53aWR0aCAtIGxlZnRPZmZzZXRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBiYiA9IChfZiA9IHRhcmdldEl0ZW0gPT0gbnVsbCA/IHZvaWQgMCA6IHRhcmdldEl0ZW0uZ2V0RWxlbWVudCgpKSA9PSBudWxsID8gdm9pZCAwIDogX2YuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBpZiAoYmIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpbmRlbnQsXG4gICAgICAgICAgdG9wOiBiYi50b3AgLSB0cmVlQmIudG9wLFxuICAgICAgICAgIGxlZnQ6IGJiLmxlZnQgKyBsZWZ0T2Zmc2V0IC0gdHJlZUJiLmxlZnQsXG4gICAgICAgICAgd2lkdGg6IGJiLndpZHRoIC0gbGVmdE9mZnNldFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBnZXREcmFnTGluZVN0eWxlOiAoeyB0cmVlIH0sIHRvcE9mZnNldCA9IC0xLCBsZWZ0T2Zmc2V0ID0gLTgpID0+IHtcbiAgICAgIGNvbnN0IGRyYWdMaW5lID0gdHJlZS5nZXREcmFnTGluZURhdGEoKTtcbiAgICAgIHJldHVybiBkcmFnTGluZSA/IHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgdG9wOiBgJHtkcmFnTGluZS50b3AgKyB0b3BPZmZzZXR9cHhgLFxuICAgICAgICBsZWZ0OiBgJHtkcmFnTGluZS5sZWZ0ICsgbGVmdE9mZnNldH1weGAsXG4gICAgICAgIHdpZHRoOiBgJHtkcmFnTGluZS53aWR0aCAtIGxlZnRPZmZzZXR9cHhgLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIlxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gcHJldmVudCBjYXB0dXJpbmcgZHJhZyBldmVudHNcbiAgICAgIH0gOiB7IGRpc3BsYXk6IFwibm9uZVwiIH07XG4gICAgfSxcbiAgICBnZXRDb250YWluZXJQcm9wczogKHsgcHJldiwgdHJlZSB9LCB0cmVlTGFiZWwpID0+IHtcbiAgICAgIGNvbnN0IHByZXZQcm9wcyA9IHByZXYgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXYodHJlZUxhYmVsKTtcbiAgICAgIHJldHVybiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBwcmV2UHJvcHMpLCB7XG4gICAgICAgIG9uRHJhZ092ZXI6IChlKSA9PiB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9LFxuICAgICAgICBvbkRyb3A6IChlKSA9PiBfX2FzeW5jKG51bGwsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgY29uc3QgZGF0YVJlZiA9IHRyZWUuZ2V0RGF0YVJlZigpO1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHsgaXRlbTogdHJlZS5nZXRSb290SXRlbSgpIH07XG4gICAgICAgICAgaWYgKCFjYW5Ecm9wKGUuZGF0YVRyYW5zZmVyLCB0YXJnZXQsIHRyZWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBjb25zdCBjb25maWcgPSB0cmVlLmdldENvbmZpZygpO1xuICAgICAgICAgIGNvbnN0IGRyYWdnZWRJdGVtcyA9IChfYSA9IHRyZWUuZ2V0U3RhdGUoKS5kbmQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5kcmFnZ2VkSXRlbXM7XG4gICAgICAgICAgZGF0YVJlZi5jdXJyZW50Lmxhc3REcmFnQ29kZSA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAoZHJhZ2dlZEl0ZW1zKSB7XG4gICAgICAgICAgICB5aWVsZCAoX2IgPSBjb25maWcub25Ecm9wKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChjb25maWcsIGRyYWdnZWRJdGVtcywgdGFyZ2V0KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgICAgICB5aWVsZCAoX2MgPSBjb25maWcub25Ecm9wRm9yZWlnbkRyYWdPYmplY3QpID09IG51bGwgPyB2b2lkIDAgOiBfYy5jYWxsKGNvbmZpZywgZS5kYXRhVHJhbnNmZXIsIHRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgc3R5bGU6IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHByZXZQcm9wcyA9PSBudWxsID8gdm9pZCAwIDogcHJldlByb3BzLnN0eWxlKSwge1xuICAgICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCJcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgaXRlbUluc3RhbmNlOiB7XG4gICAgZ2V0UHJvcHM6ICh7IHRyZWUsIGl0ZW0sIHByZXYgfSkgPT4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgcHJldiA9PSBudWxsID8gdm9pZCAwIDogcHJldigpKSwge1xuICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAgICAgb25EcmFnRW50ZXI6IChlKSA9PiBlLnByZXZlbnREZWZhdWx0KCksXG4gICAgICBvbkRyYWdTdGFydDogKGUpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBjb25zdCBzZWxlY3RlZEl0ZW1zID0gdHJlZS5nZXRTZWxlY3RlZEl0ZW1zID8gdHJlZS5nZXRTZWxlY3RlZEl0ZW1zKCkgOiBbdHJlZS5nZXRGb2N1c2VkSXRlbSgpXTtcbiAgICAgICAgY29uc3QgaXRlbXMgPSBzZWxlY3RlZEl0ZW1zLmluY2x1ZGVzKGl0ZW0pID8gc2VsZWN0ZWRJdGVtcyA6IFtpdGVtXTtcbiAgICAgICAgY29uc3QgY29uZmlnID0gdHJlZS5nZXRDb25maWcoKTtcbiAgICAgICAgaWYgKCFzZWxlY3RlZEl0ZW1zLmluY2x1ZGVzKGl0ZW0pKSB7XG4gICAgICAgICAgKF9hID0gdHJlZS5zZXRTZWxlY3RlZEl0ZW1zKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbCh0cmVlLCBbaXRlbS5nZXRJdGVtTWV0YSgpLml0ZW1JZF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKChfYyA9IChfYiA9IGNvbmZpZy5jYW5EcmFnKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChjb25maWcsIGl0ZW1zKSkgIT0gbnVsbCA/IF9jIDogdHJ1ZSkpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcuc2V0RHJhZ0ltYWdlKSB7XG4gICAgICAgICAgY29uc3QgeyBpbWdFbGVtZW50LCB4T2Zmc2V0LCB5T2Zmc2V0IH0gPSBjb25maWcuc2V0RHJhZ0ltYWdlKGl0ZW1zKTtcbiAgICAgICAgICAoX2QgPSBlLmRhdGFUcmFuc2ZlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLnNldERyYWdJbWFnZShpbWdFbGVtZW50LCB4T2Zmc2V0ICE9IG51bGwgPyB4T2Zmc2V0IDogMCwgeU9mZnNldCAhPSBudWxsID8geU9mZnNldCA6IDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcuY3JlYXRlRm9yZWlnbkRyYWdPYmplY3QgJiYgZS5kYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgICBjb25zdCB7IGZvcm1hdCwgZGF0YSwgZHJvcEVmZmVjdCwgZWZmZWN0QWxsb3dlZCB9ID0gY29uZmlnLmNyZWF0ZUZvcmVpZ25EcmFnT2JqZWN0KGl0ZW1zKTtcbiAgICAgICAgICBlLmRhdGFUcmFuc2Zlci5zZXREYXRhKGZvcm1hdCwgZGF0YSk7XG4gICAgICAgICAgaWYgKGRyb3BFZmZlY3QpIGUuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSBkcm9wRWZmZWN0O1xuICAgICAgICAgIGlmIChlZmZlY3RBbGxvd2VkKSBlLmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gZWZmZWN0QWxsb3dlZDtcbiAgICAgICAgfVxuICAgICAgICB0cmVlLmFwcGx5U3ViU3RhdGVVcGRhdGUoXCJkbmRcIiwge1xuICAgICAgICAgIGRyYWdnZWRJdGVtczogaXRlbXMsXG4gICAgICAgICAgZHJhZ2dpbmdPdmVySXRlbTogdHJlZS5nZXRGb2N1c2VkSXRlbSgpXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIG9uRHJhZ092ZXI6IChlKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBjb25zdCBkYXRhUmVmID0gdHJlZS5nZXREYXRhUmVmKCk7XG4gICAgICAgIGNvbnN0IHBsYWNlbWVudCA9IGdldFRhcmdldFBsYWNlbWVudChlLCBpdGVtLCB0cmVlLCB0cnVlKTtcbiAgICAgICAgY29uc3QgbmV4dERyYWdDb2RlID0gZ2V0RHJhZ0NvZGUoaXRlbSwgcGxhY2VtZW50KTtcbiAgICAgICAgaWYgKG5leHREcmFnQ29kZSA9PT0gZGF0YVJlZi5jdXJyZW50Lmxhc3REcmFnQ29kZSkge1xuICAgICAgICAgIGlmIChkYXRhUmVmLmN1cnJlbnQubGFzdEFsbG93RHJvcCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVJlZi5jdXJyZW50Lmxhc3REcmFnQ29kZSA9IG5leHREcmFnQ29kZTtcbiAgICAgICAgZGF0YVJlZi5jdXJyZW50Lmxhc3REcmFnRW50ZXIgPSBEYXRlLm5vdygpO1xuICAgICAgICBoYW5kbGVBdXRvT3BlbkZvbGRlcihkYXRhUmVmLCB0cmVlLCBpdGVtLCBwbGFjZW1lbnQpO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXREcmFnVGFyZ2V0KGUsIGl0ZW0sIHRyZWUpO1xuICAgICAgICBpZiAoISgoX2EgPSB0cmVlLmdldFN0YXRlKCkuZG5kKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZHJhZ2dlZEl0ZW1zKSAmJiAoIWUuZGF0YVRyYW5zZmVyIHx8ICEoKF9jID0gKF9iID0gdHJlZS5nZXRDb25maWcoKSkuY2FuRHJhZ0ZvcmVpZ25EcmFnT2JqZWN0T3ZlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IsIGUuZGF0YVRyYW5zZmVyLCB0YXJnZXQpKSkpIHtcbiAgICAgICAgICBkYXRhUmVmLmN1cnJlbnQubGFzdEFsbG93RHJvcCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNhbkRyb3AoZS5kYXRhVHJhbnNmZXIsIHRhcmdldCwgdHJlZSkpIHtcbiAgICAgICAgICBkYXRhUmVmLmN1cnJlbnQubGFzdEFsbG93RHJvcCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmVlLmFwcGx5U3ViU3RhdGVVcGRhdGUoXCJkbmRcIiwgKHN0YXRlKSA9PiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBzdGF0ZSksIHtcbiAgICAgICAgICBkcmFnVGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgZHJhZ2dpbmdPdmVySXRlbTogaXRlbVxuICAgICAgICB9KSk7XG4gICAgICAgIGRhdGFSZWYuY3VycmVudC5sYXN0QWxsb3dEcm9wID0gdHJ1ZTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSxcbiAgICAgIG9uRHJhZ0xlYXZlOiAoKSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICBjb25zdCBkYXRhUmVmID0gdHJlZS5nZXREYXRhUmVmKCk7XG4gICAgICAgICAgaWYgKCgoX2EgPSBkYXRhUmVmLmN1cnJlbnQubGFzdERyYWdFbnRlcikgIT0gbnVsbCA/IF9hIDogMCkgKyAxMDAgPj0gRGF0ZS5ub3coKSkgcmV0dXJuO1xuICAgICAgICAgIGRhdGFSZWYuY3VycmVudC5sYXN0RHJhZ0NvZGUgPSBcIm5vLWRyYWdcIjtcbiAgICAgICAgICB0cmVlLmFwcGx5U3ViU3RhdGVVcGRhdGUoXCJkbmRcIiwgKHN0YXRlKSA9PiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBzdGF0ZSksIHtcbiAgICAgICAgICAgIGRyYWdnaW5nT3Zlckl0ZW06IHZvaWQgMCxcbiAgICAgICAgICAgIGRyYWdUYXJnZXQ6IHZvaWQgMFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICAgIH0sXG4gICAgICBvbkRyYWdFbmQ6IChlKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHsgb25Db21wbGV0ZUZvcmVpZ25Ecm9wLCBjYW5EcmFnRm9yZWlnbkRyYWdPYmplY3RPdmVyIH0gPSB0cmVlLmdldENvbmZpZygpO1xuICAgICAgICBjb25zdCBkcmFnZ2VkSXRlbXMgPSAoX2EgPSB0cmVlLmdldFN0YXRlKCkuZG5kKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZHJhZ2dlZEl0ZW1zO1xuICAgICAgICBpZiAoKChfYiA9IGUuZGF0YVRyYW5zZmVyKSA9PSBudWxsID8gdm9pZCAwIDogX2IuZHJvcEVmZmVjdCkgPT09IFwibm9uZVwiIHx8ICFkcmFnZ2VkSXRlbXMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0RHJhZ1RhcmdldChlLCBpdGVtLCB0cmVlKTtcbiAgICAgICAgaWYgKGNhbkRyYWdGb3JlaWduRHJhZ09iamVjdE92ZXIgJiYgZS5kYXRhVHJhbnNmZXIgJiYgIWNhbkRyYWdGb3JlaWduRHJhZ09iamVjdE92ZXIoZS5kYXRhVHJhbnNmZXIsIHRhcmdldCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb25Db21wbGV0ZUZvcmVpZ25Ecm9wID09IG51bGwgPyB2b2lkIDAgOiBvbkNvbXBsZXRlRm9yZWlnbkRyb3AoZHJhZ2dlZEl0ZW1zKTtcbiAgICAgIH0sXG4gICAgICBvbkRyb3A6IChlKSA9PiBfX2FzeW5jKG51bGwsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBjb25zdCBkYXRhUmVmID0gdHJlZS5nZXREYXRhUmVmKCk7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldERyYWdUYXJnZXQoZSwgaXRlbSwgdHJlZSk7XG4gICAgICAgIGNvbnN0IGRyYWdnZWRJdGVtcyA9IChfYSA9IHRyZWUuZ2V0U3RhdGUoKS5kbmQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5kcmFnZ2VkSXRlbXM7XG4gICAgICAgIGNvbnN0IGlzVmFsaWREcm9wID0gY2FuRHJvcChlLmRhdGFUcmFuc2ZlciwgdGFyZ2V0LCB0cmVlKTtcbiAgICAgICAgdHJlZS5hcHBseVN1YlN0YXRlVXBkYXRlKFwiZG5kXCIsIHtcbiAgICAgICAgICBkcmFnZ2VkSXRlbXM6IHZvaWQgMCxcbiAgICAgICAgICBkcmFnZ2luZ092ZXJJdGVtOiB2b2lkIDAsXG4gICAgICAgICAgZHJhZ1RhcmdldDogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWlzVmFsaWREcm9wKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY29uc3QgY29uZmlnID0gdHJlZS5nZXRDb25maWcoKTtcbiAgICAgICAgZGF0YVJlZi5jdXJyZW50Lmxhc3REcmFnQ29kZSA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGRyYWdnZWRJdGVtcykge1xuICAgICAgICAgIHlpZWxkIChfYiA9IGNvbmZpZy5vbkRyb3ApID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKGNvbmZpZywgZHJhZ2dlZEl0ZW1zLCB0YXJnZXQpO1xuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgICAgeWllbGQgKF9jID0gY29uZmlnLm9uRHJvcEZvcmVpZ25EcmFnT2JqZWN0KSA9PSBudWxsID8gdm9pZCAwIDogX2MuY2FsbChjb25maWcsIGUuZGF0YVRyYW5zZmVyLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pLFxuICAgIGlzRHJhZ1RhcmdldDogKHsgdHJlZSwgaXRlbSB9KSA9PiB7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0cmVlLmdldERyYWdUYXJnZXQoKTtcbiAgICAgIHJldHVybiB0YXJnZXQgPyB0YXJnZXQuaXRlbS5nZXRJZCgpID09PSBpdGVtLmdldElkKCkgOiBmYWxzZTtcbiAgICB9LFxuICAgIGlzRHJhZ1RhcmdldEFib3ZlOiAoeyB0cmVlLCBpdGVtIH0pID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRyZWUuZ2V0RHJhZ1RhcmdldCgpO1xuICAgICAgaWYgKCF0YXJnZXQgfHwgIWlzT3JkZXJlZERyYWdUYXJnZXQodGFyZ2V0KSB8fCB0YXJnZXQuaXRlbSAhPT0gaXRlbS5nZXRQYXJlbnQoKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRhcmdldC5jaGlsZEluZGV4ID09PSBpdGVtLmdldEl0ZW1NZXRhKCkucG9zSW5TZXQ7XG4gICAgfSxcbiAgICBpc0RyYWdUYXJnZXRCZWxvdzogKHsgdHJlZSwgaXRlbSB9KSA9PiB7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0cmVlLmdldERyYWdUYXJnZXQoKTtcbiAgICAgIGlmICghdGFyZ2V0IHx8ICFpc09yZGVyZWREcmFnVGFyZ2V0KHRhcmdldCkgfHwgdGFyZ2V0Lml0ZW0gIT09IGl0ZW0uZ2V0UGFyZW50KCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0YXJnZXQuY2hpbGRJbmRleCAtIDEgPT09IGl0ZW0uZ2V0SXRlbU1ldGEoKS5wb3NJblNldDtcbiAgICB9LFxuICAgIGlzRHJhZ2dpbmdPdmVyOiAoeyB0cmVlLCBpdGVtIH0pID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICByZXR1cm4gKChfYiA9IChfYSA9IHRyZWUuZ2V0U3RhdGUoKS5kbmQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5kcmFnZ2luZ092ZXJJdGVtKSA9PSBudWxsID8gdm9pZCAwIDogX2IuZ2V0SWQoKSkgPT09IGl0ZW0uZ2V0SWQoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9mZWF0dXJlcy9rZXlib2FyZC1kcmFnLWFuZC1kcm9wL2ZlYXR1cmUudHNcbnZhciBnZXROZXh0RHJhZ1RhcmdldCA9ICh0cmVlLCBpc1VwLCBkcmFnVGFyZ2V0KSA9PiB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgY29uc3QgZGlyZWN0aW9uID0gaXNVcCA/IDAgOiAxO1xuICBjb25zdCBkcmFnZ2VkSXRlbXMgPSAoX2EgPSB0cmVlLmdldFN0YXRlKCkuZG5kKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZHJhZ2dlZEl0ZW1zO1xuICBpZiAoaXNPcmRlcmVkRHJhZ1RhcmdldChkcmFnVGFyZ2V0KSkge1xuICAgIGNvbnN0IHBhcmVudCA9IGRyYWdUYXJnZXQuaXRlbS5nZXRQYXJlbnQoKTtcbiAgICBjb25zdCB0YXJnZXRlZEl0ZW0gPSB0cmVlLmdldEl0ZW1zKClbZHJhZ1RhcmdldC5kcmFnTGluZUluZGV4IC0gMV07XG4gICAgY29uc3QgdGFyZ2V0Q2F0ZWdvcnkgPSB0YXJnZXRlZEl0ZW0gPyBnZXRJdGVtRHJvcENhdGVnb3J5KHRhcmdldGVkSXRlbSkgOiAwIC8qIEl0ZW0gKi87XG4gICAgY29uc3QgbWF4TGV2ZWwgPSAoX2IgPSB0YXJnZXRlZEl0ZW0gPT0gbnVsbCA/IHZvaWQgMCA6IHRhcmdldGVkSXRlbS5nZXRJdGVtTWV0YSgpLmxldmVsKSAhPSBudWxsID8gX2IgOiAwO1xuICAgIGNvbnN0IG1pbkxldmVsID0gKF9kID0gKF9jID0gdGFyZ2V0ZWRJdGVtID09IG51bGwgPyB2b2lkIDAgOiB0YXJnZXRlZEl0ZW0uZ2V0SXRlbUJlbG93KCkpID09IG51bGwgPyB2b2lkIDAgOiBfYy5nZXRJdGVtTWV0YSgpLmxldmVsKSAhPSBudWxsID8gX2QgOiAwO1xuICAgIGlmICh0YXJnZXRDYXRlZ29yeSA9PT0gMiAvKiBMYXN0SW5Hcm91cCAqLykge1xuICAgICAgaWYgKGlzVXAgJiYgZHJhZ1RhcmdldC5kcmFnTGluZUxldmVsIDwgbWF4TGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIGdldFJlcGFyZW50VGFyZ2V0KFxuICAgICAgICAgIHRhcmdldGVkSXRlbSxcbiAgICAgICAgICBkcmFnVGFyZ2V0LmRyYWdMaW5lTGV2ZWwgKyAxLFxuICAgICAgICAgIGRyYWdnZWRJdGVtc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKCFpc1VwICYmIGRyYWdUYXJnZXQuZHJhZ0xpbmVMZXZlbCA+IG1pbkxldmVsICYmIHBhcmVudCkge1xuICAgICAgICByZXR1cm4gZ2V0UmVwYXJlbnRUYXJnZXQoXG4gICAgICAgICAgdGFyZ2V0ZWRJdGVtLFxuICAgICAgICAgIGRyYWdUYXJnZXQuZHJhZ0xpbmVMZXZlbCAtIDEsXG4gICAgICAgICAgZHJhZ2dlZEl0ZW1zXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5ld0luZGV4ID0gZHJhZ1RhcmdldC5kcmFnTGluZUluZGV4IC0gMSArIGRpcmVjdGlvbjtcbiAgICBjb25zdCBpdGVtID0gdHJlZS5nZXRJdGVtcygpW25ld0luZGV4XTtcbiAgICByZXR1cm4gaXRlbSA/IHsgaXRlbSB9IDogdm9pZCAwO1xuICB9XG4gIGNvbnN0IHRhcmdldGluZ0V4cGFuZGVkRm9sZGVyID0gZ2V0SXRlbURyb3BDYXRlZ29yeShkcmFnVGFyZ2V0Lml0ZW0pID09PSAxIC8qIEV4cGFuZGVkRm9sZGVyICovO1xuICBpZiAodGFyZ2V0aW5nRXhwYW5kZWRGb2xkZXIgJiYgIWlzVXApIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXRlbTogZHJhZ1RhcmdldC5pdGVtLFxuICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgIGluc2VydGlvbkluZGV4OiBnZXRJbnNlcnRpb25JbmRleChcbiAgICAgICAgZHJhZ1RhcmdldC5pdGVtLmdldENoaWxkcmVuKCksXG4gICAgICAgIDAsXG4gICAgICAgIGRyYWdnZWRJdGVtc1xuICAgICAgKSxcbiAgICAgIGRyYWdMaW5lSW5kZXg6IGRyYWdUYXJnZXQuaXRlbS5nZXRJdGVtTWV0YSgpLmluZGV4ICsgZGlyZWN0aW9uLFxuICAgICAgZHJhZ0xpbmVMZXZlbDogZHJhZ1RhcmdldC5pdGVtLmdldEl0ZW1NZXRhKCkubGV2ZWwgKyAxXG4gICAgfTtcbiAgfVxuICBjb25zdCBjaGlsZEluZGV4ID0gZHJhZ1RhcmdldC5pdGVtLmdldEluZGV4SW5QYXJlbnQoKSArIGRpcmVjdGlvbjtcbiAgcmV0dXJuIHtcbiAgICBpdGVtOiBkcmFnVGFyZ2V0Lml0ZW0uZ2V0UGFyZW50KCksXG4gICAgY2hpbGRJbmRleCxcbiAgICBpbnNlcnRpb25JbmRleDogZ2V0SW5zZXJ0aW9uSW5kZXgoXG4gICAgICBkcmFnVGFyZ2V0Lml0ZW0uZ2V0UGFyZW50KCkuZ2V0Q2hpbGRyZW4oKSxcbiAgICAgIGNoaWxkSW5kZXgsXG4gICAgICBkcmFnZ2VkSXRlbXNcbiAgICApLFxuICAgIGRyYWdMaW5lSW5kZXg6IGRyYWdUYXJnZXQuaXRlbS5nZXRJdGVtTWV0YSgpLmluZGV4ICsgZGlyZWN0aW9uLFxuICAgIGRyYWdMaW5lTGV2ZWw6IGRyYWdUYXJnZXQuaXRlbS5nZXRJdGVtTWV0YSgpLmxldmVsXG4gIH07XG59O1xudmFyIGdldE5leHRWYWxpZERyYWdUYXJnZXQgPSAodHJlZSwgaXNVcCwgcHJldmlvdXNUYXJnZXQgPSAoKF9hKSA9PiAoX2EgPSB0cmVlLmdldFN0YXRlKCkuZG5kKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZHJhZ1RhcmdldCkoKSkgPT4ge1xuICB2YXIgX2EyO1xuICBpZiAoIXByZXZpb3VzVGFyZ2V0KSByZXR1cm4gdm9pZCAwO1xuICBjb25zdCBuZXh0VGFyZ2V0ID0gZ2V0TmV4dERyYWdUYXJnZXQodHJlZSwgaXNVcCwgcHJldmlvdXNUYXJnZXQpO1xuICBjb25zdCBkYXRhVHJhbnNmZXIgPSAoX2EyID0gdHJlZS5nZXREYXRhUmVmKCkuY3VycmVudC5rRG5kRGF0YVRyYW5zZmVyKSAhPSBudWxsID8gX2EyIDogbnVsbDtcbiAgaWYgKCFuZXh0VGFyZ2V0KSByZXR1cm4gdm9pZCAwO1xuICBpZiAoY2FuRHJvcChkYXRhVHJhbnNmZXIsIG5leHRUYXJnZXQsIHRyZWUpKSB7XG4gICAgcmV0dXJuIG5leHRUYXJnZXQ7XG4gIH1cbiAgcmV0dXJuIGdldE5leHRWYWxpZERyYWdUYXJnZXQodHJlZSwgaXNVcCwgbmV4dFRhcmdldCk7XG59O1xudmFyIHVwZGF0ZVNjcm9sbCA9ICh0cmVlKSA9PiB7XG4gIGNvbnN0IHN0YXRlID0gdHJlZS5nZXRTdGF0ZSgpLmRuZDtcbiAgaWYgKCEoc3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRlLmRyYWdUYXJnZXQpIHx8IGlzT3JkZXJlZERyYWdUYXJnZXQoc3RhdGUuZHJhZ1RhcmdldCkpIHJldHVybjtcbiAgc3RhdGUuZHJhZ1RhcmdldC5pdGVtLnNjcm9sbFRvKHsgYmxvY2s6IFwibmVhcmVzdFwiLCBpbmxpbmU6IFwibmVhcmVzdFwiIH0pO1xufTtcbnZhciBpbml0aWF0ZURyYWcgPSAodHJlZSwgZHJhZ2dlZEl0ZW1zLCBkYXRhVHJhbnNmZXIpID0+IHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgZm9jdXNlZEl0ZW0gPSB0cmVlLmdldEZvY3VzZWRJdGVtKCk7XG4gIGNvbnN0IHsgY2FuRHJhZyB9ID0gdHJlZS5nZXRDb25maWcoKTtcbiAgaWYgKGRyYWdnZWRJdGVtcyAmJiBjYW5EcmFnICYmICFjYW5EcmFnKGRyYWdnZWRJdGVtcykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGRyYWdnZWRJdGVtcykge1xuICAgIHRyZWUuYXBwbHlTdWJTdGF0ZVVwZGF0ZShcImRuZFwiLCB7IGRyYWdnZWRJdGVtcyB9KTtcbiAgICAoX2IgPSAoX2EgPSB0cmVlLmdldENvbmZpZygpKS5vblN0YXJ0S2V5Ym9hcmREcmFnKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgZHJhZ2dlZEl0ZW1zKTtcbiAgfSBlbHNlIGlmIChkYXRhVHJhbnNmZXIpIHtcbiAgICB0cmVlLmdldERhdGFSZWYoKS5jdXJyZW50LmtEbmREYXRhVHJhbnNmZXIgPSBkYXRhVHJhbnNmZXI7XG4gIH1cbiAgY29uc3QgZHJhZ1RhcmdldCA9IGdldE5leHRWYWxpZERyYWdUYXJnZXQodHJlZSwgZmFsc2UsIHtcbiAgICBpdGVtOiBmb2N1c2VkSXRlbVxuICB9KTtcbiAgaWYgKCFkcmFnVGFyZ2V0KSByZXR1cm47XG4gIHRyZWUuYXBwbHlTdWJTdGF0ZVVwZGF0ZShcImRuZFwiLCB7XG4gICAgZHJhZ2dlZEl0ZW1zLFxuICAgIGRyYWdUYXJnZXRcbiAgfSk7XG4gIHRyZWUuYXBwbHlTdWJTdGF0ZVVwZGF0ZShcImFzc2lzdGl2ZURuZFN0YXRlXCIsIDEgLyogU3RhcnRlZCAqLyk7XG4gIHVwZGF0ZVNjcm9sbCh0cmVlKTtcbn07XG52YXIgbW92ZURyYWdQb3NpdGlvbiA9ICh0cmVlLCBpc1VwKSA9PiB7XG4gIHZhciBfYTtcbiAgY29uc3QgZHJhZ1RhcmdldCA9IGdldE5leHRWYWxpZERyYWdUYXJnZXQodHJlZSwgaXNVcCk7XG4gIGlmICghZHJhZ1RhcmdldCkgcmV0dXJuO1xuICB0cmVlLmFwcGx5U3ViU3RhdGVVcGRhdGUoXCJkbmRcIiwge1xuICAgIGRyYWdnZWRJdGVtczogKF9hID0gdHJlZS5nZXRTdGF0ZSgpLmRuZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRyYWdnZWRJdGVtcyxcbiAgICBkcmFnVGFyZ2V0XG4gIH0pO1xuICB0cmVlLmFwcGx5U3ViU3RhdGVVcGRhdGUoXCJhc3Npc3RpdmVEbmRTdGF0ZVwiLCAyIC8qIERyYWdnaW5nICovKTtcbiAgaWYgKCFpc09yZGVyZWREcmFnVGFyZ2V0KGRyYWdUYXJnZXQpKSB7XG4gICAgZHJhZ1RhcmdldC5pdGVtLnNldEZvY3VzZWQoKTtcbiAgfVxuICB1cGRhdGVTY3JvbGwodHJlZSk7XG59O1xudmFyIGtleWJvYXJkRHJhZ0FuZERyb3BGZWF0dXJlID0ge1xuICBrZXk6IFwia2V5Ym9hcmQtZHJhZy1hbmQtZHJvcFwiLFxuICBkZXBzOiBbXCJkcmFnLWFuZC1kcm9wXCJdLFxuICBnZXREZWZhdWx0Q29uZmlnOiAoZGVmYXVsdENvbmZpZywgdHJlZSkgPT4gX19zcHJlYWRWYWx1ZXMoe1xuICAgIHNldEFzc2lzdGl2ZURuZFN0YXRlOiBtYWtlU3RhdGVVcGRhdGVyKFwiYXNzaXN0aXZlRG5kU3RhdGVcIiwgdHJlZSlcbiAgfSwgZGVmYXVsdENvbmZpZyksXG4gIHN0YXRlSGFuZGxlck5hbWVzOiB7XG4gICAgYXNzaXN0aXZlRG5kU3RhdGU6IFwic2V0QXNzaXN0aXZlRG5kU3RhdGVcIlxuICB9LFxuICB0cmVlSW5zdGFuY2U6IHtcbiAgICBzdGFydEtleWJvYXJkRHJhZzogKHsgdHJlZSB9LCBkcmFnZ2VkSXRlbXMpID0+IHtcbiAgICAgIGluaXRpYXRlRHJhZyh0cmVlLCBkcmFnZ2VkSXRlbXMsIHZvaWQgMCk7XG4gICAgfSxcbiAgICBzdGFydEtleWJvYXJkRHJhZ09uRm9yZWlnbk9iamVjdDogKHsgdHJlZSB9LCBkYXRhVHJhbnNmZXIpID0+IHtcbiAgICAgIGluaXRpYXRlRHJhZyh0cmVlLCB2b2lkIDAsIGRhdGFUcmFuc2Zlcik7XG4gICAgfSxcbiAgICBzdG9wS2V5Ym9hcmREcmFnOiAoeyB0cmVlIH0pID0+IHtcbiAgICAgIHRyZWUuZ2V0RGF0YVJlZigpLmN1cnJlbnQua0RuZERhdGFUcmFuc2ZlciA9IHZvaWQgMDtcbiAgICAgIHRyZWUuYXBwbHlTdWJTdGF0ZVVwZGF0ZShcImRuZFwiLCBudWxsKTtcbiAgICAgIHRyZWUuYXBwbHlTdWJTdGF0ZVVwZGF0ZShcImFzc2lzdGl2ZURuZFN0YXRlXCIsIDAgLyogTm9uZSAqLyk7XG4gICAgfVxuICB9LFxuICBob3RrZXlzOiB7XG4gICAgc3RhcnREcmFnOiB7XG4gICAgICBob3RrZXk6IFwiQ29udHJvbCtTaGlmdCtLZXlEXCIsXG4gICAgICBwcmV2ZW50RGVmYXVsdDogdHJ1ZSxcbiAgICAgIGlzRW5hYmxlZDogKHRyZWUpID0+ICF0cmVlLmdldFN0YXRlKCkuZG5kLFxuICAgICAgaGFuZGxlcjogKF8sIHRyZWUpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRJdGVtcyA9IChfYiA9IChfYSA9IHRyZWUuZ2V0U2VsZWN0ZWRJdGVtcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwodHJlZSkpICE9IG51bGwgPyBfYiA6IFtcbiAgICAgICAgICB0cmVlLmdldEZvY3VzZWRJdGVtKClcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgZm9jdXNlZEl0ZW0gPSB0cmVlLmdldEZvY3VzZWRJdGVtKCk7XG4gICAgICAgIHRyZWUuc3RhcnRLZXlib2FyZERyYWcoXG4gICAgICAgICAgc2VsZWN0ZWRJdGVtcy5pbmNsdWRlcyhmb2N1c2VkSXRlbSkgPyBzZWxlY3RlZEl0ZW1zIDogc2VsZWN0ZWRJdGVtcy5jb25jYXQoZm9jdXNlZEl0ZW0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkcmFnVXA6IHtcbiAgICAgIGhvdGtleTogXCJBcnJvd1VwXCIsXG4gICAgICBwcmV2ZW50RGVmYXVsdDogdHJ1ZSxcbiAgICAgIGlzRW5hYmxlZDogKHRyZWUpID0+ICEhdHJlZS5nZXRTdGF0ZSgpLmRuZCxcbiAgICAgIGhhbmRsZXI6IChfLCB0cmVlKSA9PiB7XG4gICAgICAgIG1vdmVEcmFnUG9zaXRpb24odHJlZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkcmFnRG93bjoge1xuICAgICAgaG90a2V5OiBcIkFycm93RG93blwiLFxuICAgICAgcHJldmVudERlZmF1bHQ6IHRydWUsXG4gICAgICBpc0VuYWJsZWQ6ICh0cmVlKSA9PiAhIXRyZWUuZ2V0U3RhdGUoKS5kbmQsXG4gICAgICBoYW5kbGVyOiAoXywgdHJlZSkgPT4ge1xuICAgICAgICBtb3ZlRHJhZ1Bvc2l0aW9uKHRyZWUsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNhbmNlbERyYWc6IHtcbiAgICAgIGhvdGtleTogXCJFc2NhcGVcIixcbiAgICAgIGlzRW5hYmxlZDogKHRyZWUpID0+ICEhdHJlZS5nZXRTdGF0ZSgpLmRuZCxcbiAgICAgIGhhbmRsZXI6IChfLCB0cmVlKSA9PiB7XG4gICAgICAgIHRyZWUuc3RvcEtleWJvYXJkRHJhZygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY29tcGxldGVEcmFnOiB7XG4gICAgICBob3RrZXk6IFwiRW50ZXJcIixcbiAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlLFxuICAgICAgaXNFbmFibGVkOiAodHJlZSkgPT4gISF0cmVlLmdldFN0YXRlKCkuZG5kLFxuICAgICAgaGFuZGxlcjogKGUsIHRyZWUpID0+IF9fYXN5bmMobnVsbCwgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBjb25zdCBkYXRhUmVmID0gdHJlZS5nZXREYXRhUmVmKCk7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRyZWUuZ2V0RHJhZ1RhcmdldCgpO1xuICAgICAgICBjb25zdCBkYXRhVHJhbnNmZXIgPSAoX2EgPSBkYXRhUmVmLmN1cnJlbnQua0RuZERhdGFUcmFuc2ZlcikgIT0gbnVsbCA/IF9hIDogbnVsbDtcbiAgICAgICAgaWYgKCF0YXJnZXQgfHwgIWNhbkRyb3AoZGF0YVRyYW5zZmVyLCB0YXJnZXQsIHRyZWUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHRyZWUuZ2V0Q29uZmlnKCk7XG4gICAgICAgIGNvbnN0IGRyYWdnZWRJdGVtcyA9IChfYiA9IHRyZWUuZ2V0U3RhdGUoKS5kbmQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5kcmFnZ2VkSXRlbXM7XG4gICAgICAgIGRhdGFSZWYuY3VycmVudC5sYXN0RHJhZ0NvZGUgPSB2b2lkIDA7XG4gICAgICAgIHRyZWUuYXBwbHlTdWJTdGF0ZVVwZGF0ZShcImRuZFwiLCBudWxsKTtcbiAgICAgICAgaWYgKGRyYWdnZWRJdGVtcykge1xuICAgICAgICAgIHlpZWxkIChfYyA9IGNvbmZpZy5vbkRyb3ApID09IG51bGwgPyB2b2lkIDAgOiBfYy5jYWxsKGNvbmZpZywgZHJhZ2dlZEl0ZW1zLCB0YXJnZXQpO1xuICAgICAgICAgIHRyZWUuZ2V0SXRlbUluc3RhbmNlKGRyYWdnZWRJdGVtc1swXS5nZXRJZCgpKS5zZXRGb2N1c2VkKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgICAgeWllbGQgKF9kID0gY29uZmlnLm9uRHJvcEZvcmVpZ25EcmFnT2JqZWN0KSA9PSBudWxsID8gdm9pZCAwIDogX2QuY2FsbChjb25maWcsIGRhdGFUcmFuc2ZlciwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICB0cmVlLmFwcGx5U3ViU3RhdGVVcGRhdGUoXG4gICAgICAgICAgXCJhc3Npc3RpdmVEbmRTdGF0ZVwiLFxuICAgICAgICAgIDMgLyogQ29tcGxldGVkICovXG4gICAgICAgICk7XG4gICAgICB9KVxuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2ZlYXR1cmVzL3NlYXJjaC9mZWF0dXJlLnRzXG52YXIgc2VhcmNoRmVhdHVyZSA9IHtcbiAga2V5OiBcInNlYXJjaFwiLFxuICBnZXRJbml0aWFsU3RhdGU6IChpbml0aWFsU3RhdGUpID0+IF9fc3ByZWFkVmFsdWVzKHtcbiAgICBzZWFyY2g6IG51bGxcbiAgfSwgaW5pdGlhbFN0YXRlKSxcbiAgZ2V0RGVmYXVsdENvbmZpZzogKGRlZmF1bHRDb25maWcsIHRyZWUpID0+IF9fc3ByZWFkVmFsdWVzKHtcbiAgICBzZXRTZWFyY2g6IG1ha2VTdGF0ZVVwZGF0ZXIoXCJzZWFyY2hcIiwgdHJlZSksXG4gICAgaXNTZWFyY2hNYXRjaGluZ0l0ZW06IChzZWFyY2gsIGl0ZW0pID0+IHNlYXJjaC5sZW5ndGggPiAwICYmIGl0ZW0uZ2V0SXRlbU5hbWUoKS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHNlYXJjaC50b0xvd2VyQ2FzZSgpKVxuICB9LCBkZWZhdWx0Q29uZmlnKSxcbiAgc3RhdGVIYW5kbGVyTmFtZXM6IHtcbiAgICBzZWFyY2g6IFwic2V0U2VhcmNoXCJcbiAgfSxcbiAgdHJlZUluc3RhbmNlOiB7XG4gICAgc2V0U2VhcmNoOiAoeyB0cmVlIH0sIHNlYXJjaCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgdHJlZS5hcHBseVN1YlN0YXRlVXBkYXRlKFwic2VhcmNoXCIsIHNlYXJjaCk7XG4gICAgICAoX2EgPSB0cmVlLmdldEl0ZW1zKCkuZmluZChcbiAgICAgICAgKGl0ZW0pID0+IHtcbiAgICAgICAgICB2YXIgX2EyLCBfYjtcbiAgICAgICAgICByZXR1cm4gKF9iID0gKF9hMiA9IHRyZWUuZ2V0Q29uZmlnKCkpLmlzU2VhcmNoTWF0Y2hpbmdJdGVtKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTIsIHRyZWUuZ2V0U2VhcmNoVmFsdWUoKSwgaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zZXRGb2N1c2VkKCk7XG4gICAgfSxcbiAgICBvcGVuU2VhcmNoOiAoeyB0cmVlIH0sIGluaXRpYWxWYWx1ZSA9IFwiXCIpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICB0cmVlLnNldFNlYXJjaChpbml0aWFsVmFsdWUpO1xuICAgICAgKF9iID0gKF9hID0gdHJlZS5nZXRDb25maWcoKSkub25PcGVuU2VhcmNoKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgKF9hMiA9IHRyZWUuZ2V0RGF0YVJlZigpLmN1cnJlbnQuc2VhcmNoSW5wdXQpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZm9jdXMoKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgY2xvc2VTZWFyY2g6ICh7IHRyZWUgfSkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIHRyZWUuc2V0U2VhcmNoKG51bGwpO1xuICAgICAgKF9iID0gKF9hID0gdHJlZS5nZXRDb25maWcoKSkub25DbG9zZVNlYXJjaCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgdHJlZS51cGRhdGVEb21Gb2N1cygpO1xuICAgIH0sXG4gICAgaXNTZWFyY2hPcGVuOiAoeyB0cmVlIH0pID0+IHRyZWUuZ2V0U3RhdGUoKS5zZWFyY2ggIT09IG51bGwsXG4gICAgZ2V0U2VhcmNoVmFsdWU6ICh7IHRyZWUgfSkgPT4gdHJlZS5nZXRTdGF0ZSgpLnNlYXJjaCB8fCBcIlwiLFxuICAgIHJlZ2lzdGVyU2VhcmNoSW5wdXRFbGVtZW50OiAoeyB0cmVlIH0sIGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IGRhdGFSZWYgPSB0cmVlLmdldERhdGFSZWYoKTtcbiAgICAgIGRhdGFSZWYuY3VycmVudC5zZWFyY2hJbnB1dCA9IGVsZW1lbnQ7XG4gICAgICBpZiAoZWxlbWVudCAmJiBkYXRhUmVmLmN1cnJlbnQua2V5ZG93bkhhbmRsZXIpIHtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBkYXRhUmVmLmN1cnJlbnQua2V5ZG93bkhhbmRsZXIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0U2VhcmNoSW5wdXRFbGVtZW50OiAoeyB0cmVlIH0pID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiAoX2EgPSB0cmVlLmdldERhdGFSZWYoKS5jdXJyZW50LnNlYXJjaElucHV0KSAhPSBudWxsID8gX2EgOiBudWxsO1xuICAgIH0sXG4gICAgLy8gVE9ETyBtZW1vaXplIHdpdGggcHJvcE1lbW9pemF0aW9uRmVhdHVyZVxuICAgIGdldFNlYXJjaElucHV0RWxlbWVudFByb3BzOiAoeyB0cmVlIH0pID0+ICh7XG4gICAgICB2YWx1ZTogdHJlZS5nZXRTZWFyY2hWYWx1ZSgpLFxuICAgICAgb25DaGFuZ2U6IChlKSA9PiB0cmVlLnNldFNlYXJjaChlLnRhcmdldC52YWx1ZSksXG4gICAgICBvbkJsdXI6ICgpID0+IHRyZWUuY2xvc2VTZWFyY2goKSxcbiAgICAgIHJlZjogdHJlZS5yZWdpc3RlclNlYXJjaElucHV0RWxlbWVudFxuICAgIH0pLFxuICAgIGdldFNlYXJjaE1hdGNoaW5nSXRlbXM6IG1lbW8oXG4gICAgICAoeyB0cmVlIH0pID0+IFtcbiAgICAgICAgdHJlZS5nZXRTZWFyY2hWYWx1ZSgpLFxuICAgICAgICB0cmVlLmdldEl0ZW1zKCksXG4gICAgICAgIHRyZWUuZ2V0Q29uZmlnKCkuaXNTZWFyY2hNYXRjaGluZ0l0ZW1cbiAgICAgIF0sXG4gICAgICAoc2VhcmNoLCBpdGVtcywgaXNTZWFyY2hNYXRjaGluZ0l0ZW0pID0+IGl0ZW1zLmZpbHRlcigoaXRlbSkgPT4gc2VhcmNoICYmIChpc1NlYXJjaE1hdGNoaW5nSXRlbSA9PSBudWxsID8gdm9pZCAwIDogaXNTZWFyY2hNYXRjaGluZ0l0ZW0oc2VhcmNoLCBpdGVtKSkpXG4gICAgKVxuICB9LFxuICBpdGVtSW5zdGFuY2U6IHtcbiAgICBpc01hdGNoaW5nU2VhcmNoOiAoeyB0cmVlLCBpdGVtIH0pID0+IHRyZWUuZ2V0U2VhcmNoTWF0Y2hpbmdJdGVtcygpLnNvbWUoKGkpID0+IGkuZ2V0SWQoKSA9PT0gaXRlbS5nZXRJZCgpKVxuICB9LFxuICBob3RrZXlzOiB7XG4gICAgb3BlblNlYXJjaDoge1xuICAgICAgaG90a2V5OiBcIkxldHRlck9yTnVtYmVyXCIsXG4gICAgICBwcmV2ZW50RGVmYXVsdDogdHJ1ZSxcbiAgICAgIC8vIFRPRE8gbWFrZSB0cnVlIGRlZmF1bHRcbiAgICAgIGlzRW5hYmxlZDogKHRyZWUpID0+ICF0cmVlLmlzU2VhcmNoT3BlbigpLFxuICAgICAgaGFuZGxlcjogKGUsIHRyZWUpID0+IHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdHJlZS5vcGVuU2VhcmNoKGUua2V5KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNsb3NlU2VhcmNoOiB7XG4gICAgICAvLyBUT0RPIGFsbG93IG11bHRpcGxlLCBpLmUuIEVudGVyXG4gICAgICBob3RrZXk6IFwiRXNjYXBlXCIsXG4gICAgICBhbGxvd1doZW5JbnB1dEZvY3VzZWQ6IHRydWUsXG4gICAgICBpc0VuYWJsZWQ6ICh0cmVlKSA9PiB0cmVlLmlzU2VhcmNoT3BlbigpLFxuICAgICAgaGFuZGxlcjogKGUsIHRyZWUpID0+IHtcbiAgICAgICAgdHJlZS5jbG9zZVNlYXJjaCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc3VibWl0U2VhcmNoOiB7XG4gICAgICBob3RrZXk6IFwiRW50ZXJcIixcbiAgICAgIGFsbG93V2hlbklucHV0Rm9jdXNlZDogdHJ1ZSxcbiAgICAgIGlzRW5hYmxlZDogKHRyZWUpID0+IHRyZWUuaXNTZWFyY2hPcGVuKCksXG4gICAgICBoYW5kbGVyOiAoZSwgdHJlZSkgPT4ge1xuICAgICAgICB0cmVlLmNsb3NlU2VhcmNoKCk7XG4gICAgICAgIHRyZWUuc2V0U2VsZWN0ZWRJdGVtcyhbdHJlZS5nZXRGb2N1c2VkSXRlbSgpLmdldElkKCldKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG5leHRTZWFyY2hJdGVtOiB7XG4gICAgICBob3RrZXk6IFwiQXJyb3dEb3duXCIsXG4gICAgICBhbGxvd1doZW5JbnB1dEZvY3VzZWQ6IHRydWUsXG4gICAgICBjYW5SZXBlYXQ6IHRydWUsXG4gICAgICBpc0VuYWJsZWQ6ICh0cmVlKSA9PiB0cmVlLmlzU2VhcmNoT3BlbigpLFxuICAgICAgaGFuZGxlcjogKGUsIHRyZWUpID0+IHtcbiAgICAgICAgY29uc3QgZm9jdXNJdGVtID0gdHJlZS5nZXRTZWFyY2hNYXRjaGluZ0l0ZW1zKCkuZmluZChcbiAgICAgICAgICAoaXRlbSkgPT4gaXRlbS5nZXRJdGVtTWV0YSgpLmluZGV4ID4gdHJlZS5nZXRGb2N1c2VkSXRlbSgpLmdldEl0ZW1NZXRhKCkuaW5kZXhcbiAgICAgICAgKTtcbiAgICAgICAgZm9jdXNJdGVtID09IG51bGwgPyB2b2lkIDAgOiBmb2N1c0l0ZW0uc2V0Rm9jdXNlZCgpO1xuICAgICAgICBmb2N1c0l0ZW0gPT0gbnVsbCA/IHZvaWQgMCA6IGZvY3VzSXRlbS5zY3JvbGxUbyh7IGJsb2NrOiBcIm5lYXJlc3RcIiwgaW5saW5lOiBcIm5lYXJlc3RcIiB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHByZXZpb3VzU2VhcmNoSXRlbToge1xuICAgICAgaG90a2V5OiBcIkFycm93VXBcIixcbiAgICAgIGFsbG93V2hlbklucHV0Rm9jdXNlZDogdHJ1ZSxcbiAgICAgIGNhblJlcGVhdDogdHJ1ZSxcbiAgICAgIGlzRW5hYmxlZDogKHRyZWUpID0+IHRyZWUuaXNTZWFyY2hPcGVuKCksXG4gICAgICBoYW5kbGVyOiAoZSwgdHJlZSkgPT4ge1xuICAgICAgICBjb25zdCBmb2N1c0l0ZW0gPSBbLi4udHJlZS5nZXRTZWFyY2hNYXRjaGluZ0l0ZW1zKCldLnJldmVyc2UoKS5maW5kKFxuICAgICAgICAgIChpdGVtKSA9PiBpdGVtLmdldEl0ZW1NZXRhKCkuaW5kZXggPCB0cmVlLmdldEZvY3VzZWRJdGVtKCkuZ2V0SXRlbU1ldGEoKS5pbmRleFxuICAgICAgICApO1xuICAgICAgICBmb2N1c0l0ZW0gPT0gbnVsbCA/IHZvaWQgMCA6IGZvY3VzSXRlbS5zZXRGb2N1c2VkKCk7XG4gICAgICAgIGZvY3VzSXRlbSA9PSBudWxsID8gdm9pZCAwIDogZm9jdXNJdGVtLnNjcm9sbFRvKHsgYmxvY2s6IFwibmVhcmVzdFwiLCBpbmxpbmU6IFwibmVhcmVzdFwiIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2ZlYXR1cmVzL3JlbmFtaW5nL2ZlYXR1cmUudHNcbnZhciByZW5hbWluZ0ZlYXR1cmUgPSB7XG4gIGtleTogXCJyZW5hbWluZ1wiLFxuICBvdmVyd3JpdGVzOiBbXCJkcmFnLWFuZC1kcm9wXCJdLFxuICBnZXREZWZhdWx0Q29uZmlnOiAoZGVmYXVsdENvbmZpZywgdHJlZSkgPT4gX19zcHJlYWRWYWx1ZXMoe1xuICAgIHNldFJlbmFtaW5nSXRlbTogbWFrZVN0YXRlVXBkYXRlcihcInJlbmFtaW5nSXRlbVwiLCB0cmVlKSxcbiAgICBzZXRSZW5hbWluZ1ZhbHVlOiBtYWtlU3RhdGVVcGRhdGVyKFwicmVuYW1pbmdWYWx1ZVwiLCB0cmVlKSxcbiAgICBjYW5SZW5hbWU6ICgpID0+IHRydWVcbiAgfSwgZGVmYXVsdENvbmZpZyksXG4gIHN0YXRlSGFuZGxlck5hbWVzOiB7XG4gICAgcmVuYW1pbmdJdGVtOiBcInNldFJlbmFtaW5nSXRlbVwiLFxuICAgIHJlbmFtaW5nVmFsdWU6IFwic2V0UmVuYW1pbmdWYWx1ZVwiXG4gIH0sXG4gIHRyZWVJbnN0YW5jZToge1xuICAgIGdldFJlbmFtaW5nSXRlbTogKHsgdHJlZSB9KSA9PiB7XG4gICAgICBjb25zdCBpdGVtSWQgPSB0cmVlLmdldFN0YXRlKCkucmVuYW1pbmdJdGVtO1xuICAgICAgcmV0dXJuIGl0ZW1JZCA/IHRyZWUuZ2V0SXRlbUluc3RhbmNlKGl0ZW1JZCkgOiBudWxsO1xuICAgIH0sXG4gICAgZ2V0UmVuYW1pbmdWYWx1ZTogKHsgdHJlZSB9KSA9PiB0cmVlLmdldFN0YXRlKCkucmVuYW1pbmdWYWx1ZSB8fCBcIlwiLFxuICAgIGFib3J0UmVuYW1pbmc6ICh7IHRyZWUgfSkgPT4ge1xuICAgICAgdHJlZS5hcHBseVN1YlN0YXRlVXBkYXRlKFwicmVuYW1pbmdJdGVtXCIsIG51bGwpO1xuICAgICAgdHJlZS51cGRhdGVEb21Gb2N1cygpO1xuICAgIH0sXG4gICAgY29tcGxldGVSZW5hbWluZzogKHsgdHJlZSB9KSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBjb25maWcgPSB0cmVlLmdldENvbmZpZygpO1xuICAgICAgY29uc3QgaXRlbSA9IHRyZWUuZ2V0UmVuYW1pbmdJdGVtKCk7XG4gICAgICBpZiAoaXRlbSkge1xuICAgICAgICAoX2EgPSBjb25maWcub25SZW5hbWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKGNvbmZpZywgaXRlbSwgdHJlZS5nZXRTdGF0ZSgpLnJlbmFtaW5nVmFsdWUgfHwgXCJcIik7XG4gICAgICB9XG4gICAgICB0cmVlLmFwcGx5U3ViU3RhdGVVcGRhdGUoXCJyZW5hbWluZ0l0ZW1cIiwgbnVsbCk7XG4gICAgICB0cmVlLnVwZGF0ZURvbUZvY3VzKCk7XG4gICAgfSxcbiAgICBpc1JlbmFtaW5nSXRlbTogKHsgdHJlZSB9KSA9PiAhIXRyZWUuZ2V0U3RhdGUoKS5yZW5hbWluZ0l0ZW1cbiAgfSxcbiAgaXRlbUluc3RhbmNlOiB7XG4gICAgc3RhcnRSZW5hbWluZzogKHsgdHJlZSwgaXRlbSwgaXRlbUlkIH0pID0+IHtcbiAgICAgIGlmICghaXRlbS5jYW5SZW5hbWUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0cmVlLmFwcGx5U3ViU3RhdGVVcGRhdGUoXCJyZW5hbWluZ0l0ZW1cIiwgaXRlbUlkKTtcbiAgICAgIHRyZWUuYXBwbHlTdWJTdGF0ZVVwZGF0ZShcInJlbmFtaW5nVmFsdWVcIiwgaXRlbS5nZXRJdGVtTmFtZSgpKTtcbiAgICB9LFxuICAgIGdldFJlbmFtZUlucHV0UHJvcHM6ICh7IHRyZWUgfSkgPT4gKHtcbiAgICAgIHJlZjogKHIpID0+IHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIuZm9jdXMoKSxcbiAgICAgIG9uQmx1cjogKCkgPT4gdHJlZS5hYm9ydFJlbmFtaW5nKCksXG4gICAgICB2YWx1ZTogdHJlZS5nZXRSZW5hbWluZ1ZhbHVlKCksXG4gICAgICBvbkNoYW5nZTogKGUpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0cmVlLmFwcGx5U3ViU3RhdGVVcGRhdGUoXCJyZW5hbWluZ1ZhbHVlXCIsIChfYSA9IGUudGFyZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX2EudmFsdWUpO1xuICAgICAgfVxuICAgIH0pLFxuICAgIGNhblJlbmFtZTogKHsgdHJlZSwgaXRlbSB9KSA9PiB7XG4gICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgIHJldHVybiAoX2MgPSAoX2IgPSAoX2EgPSB0cmVlLmdldENvbmZpZygpKS5jYW5SZW5hbWUpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBpdGVtKSkgIT0gbnVsbCA/IF9jIDogdHJ1ZTtcbiAgICB9LFxuICAgIGlzUmVuYW1pbmc6ICh7IHRyZWUsIGl0ZW0gfSkgPT4gaXRlbS5nZXRJZCgpID09PSB0cmVlLmdldFN0YXRlKCkucmVuYW1pbmdJdGVtLFxuICAgIGdldFByb3BzOiAoeyBwcmV2LCBpdGVtIH0pID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGlzUmVuYW1pbmcgPSBpdGVtLmlzUmVuYW1pbmcoKTtcbiAgICAgIGNvbnN0IHByZXZQcm9wcyA9IChfYSA9IHByZXYgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXYoKSkgIT0gbnVsbCA/IF9hIDoge307XG4gICAgICByZXR1cm4gaXNSZW5hbWluZyA/IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHByZXZQcm9wcyksIHtcbiAgICAgICAgZHJhZ2dhYmxlOiBmYWxzZSxcbiAgICAgICAgb25EcmFnU3RhcnQ6ICgpID0+IHtcbiAgICAgICAgfVxuICAgICAgfSkgOiBwcmV2UHJvcHM7XG4gICAgfVxuICB9LFxuICBob3RrZXlzOiB7XG4gICAgcmVuYW1lSXRlbToge1xuICAgICAgaG90a2V5OiBcIkYyXCIsXG4gICAgICBoYW5kbGVyOiAoZSwgdHJlZSkgPT4ge1xuICAgICAgICB0cmVlLmdldEZvY3VzZWRJdGVtKCkuc3RhcnRSZW5hbWluZygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYWJvcnRSZW5hbWluZzoge1xuICAgICAgaG90a2V5OiBcIkVzY2FwZVwiLFxuICAgICAgYWxsb3dXaGVuSW5wdXRGb2N1c2VkOiB0cnVlLFxuICAgICAgaXNFbmFibGVkOiAodHJlZSkgPT4gdHJlZS5pc1JlbmFtaW5nSXRlbSgpLFxuICAgICAgaGFuZGxlcjogKGUsIHRyZWUpID0+IHtcbiAgICAgICAgdHJlZS5hYm9ydFJlbmFtaW5nKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjb21wbGV0ZVJlbmFtaW5nOiB7XG4gICAgICBob3RrZXk6IFwiRW50ZXJcIixcbiAgICAgIGFsbG93V2hlbklucHV0Rm9jdXNlZDogdHJ1ZSxcbiAgICAgIGlzRW5hYmxlZDogKHRyZWUpID0+IHRyZWUuaXNSZW5hbWluZ0l0ZW0oKSxcbiAgICAgIGhhbmRsZXI6IChlLCB0cmVlKSA9PiB7XG4gICAgICAgIHRyZWUuY29tcGxldGVSZW5hbWluZygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2ZlYXR1cmVzL2V4cGFuZC1hbGwvZmVhdHVyZS50c1xudmFyIGV4cGFuZEFsbEZlYXR1cmUgPSB7XG4gIGtleTogXCJleHBhbmQtYWxsXCIsXG4gIHRyZWVJbnN0YW5jZToge1xuICAgIGV4cGFuZEFsbDogKF8wLCBfMSkgPT4gX19hc3luYyhudWxsLCBbXzAsIF8xXSwgZnVuY3Rpb24qICh7IHRyZWUgfSwgY2FuY2VsVG9rZW4pIHtcbiAgICAgIHlpZWxkIFByb21pc2UuYWxsKFxuICAgICAgICB0cmVlLmdldEl0ZW1zKCkubWFwKChpdGVtKSA9PiBpdGVtLmV4cGFuZEFsbChjYW5jZWxUb2tlbikpXG4gICAgICApO1xuICAgIH0pLFxuICAgIGNvbGxhcHNlQWxsOiAoeyB0cmVlIH0pID0+IHtcbiAgICAgIHRyZWUuYXBwbHlTdWJTdGF0ZVVwZGF0ZShcImV4cGFuZGVkSXRlbXNcIiwgW10pO1xuICAgICAgdHJlZS5yZWJ1aWxkVHJlZSgpO1xuICAgIH1cbiAgfSxcbiAgaXRlbUluc3RhbmNlOiB7XG4gICAgZXhwYW5kQWxsOiAoXzAsIF8xKSA9PiBfX2FzeW5jKG51bGwsIFtfMCwgXzFdLCBmdW5jdGlvbiogKHsgdHJlZSwgaXRlbSB9LCBjYW5jZWxUb2tlbikge1xuICAgICAgaWYgKGNhbmNlbFRva2VuID09IG51bGwgPyB2b2lkIDAgOiBjYW5jZWxUb2tlbi5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghaXRlbS5pc0ZvbGRlcigpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGl0ZW0uZXhwYW5kKCk7XG4gICAgICB5aWVsZCB0cmVlLndhaXRGb3JJdGVtQ2hpbGRyZW5Mb2FkZWQoaXRlbS5nZXRJZCgpKTtcbiAgICAgIHlpZWxkIFByb21pc2UuYWxsKFxuICAgICAgICBpdGVtLmdldENoaWxkcmVuKCkubWFwKChjaGlsZCkgPT4gX19hc3luYyhudWxsLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIHlpZWxkIHRyZWUud2FpdEZvckl0ZW1DaGlsZHJlbkxvYWRlZChpdGVtLmdldElkKCkpO1xuICAgICAgICAgIHlpZWxkIGNoaWxkID09IG51bGwgPyB2b2lkIDAgOiBjaGlsZC5leHBhbmRBbGwoY2FuY2VsVG9rZW4pO1xuICAgICAgICB9KSlcbiAgICAgICk7XG4gICAgfSksXG4gICAgY29sbGFwc2VBbGw6ICh7IGl0ZW0gfSkgPT4ge1xuICAgICAgaWYgKCFpdGVtLmlzRXhwYW5kZWQoKSkgcmV0dXJuO1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBpdGVtLmdldENoaWxkcmVuKCkpIHtcbiAgICAgICAgY2hpbGQgPT0gbnVsbCA/IHZvaWQgMCA6IGNoaWxkLmNvbGxhcHNlQWxsKCk7XG4gICAgICB9XG4gICAgICBpdGVtLmNvbGxhcHNlKCk7XG4gICAgfVxuICB9LFxuICBob3RrZXlzOiB7XG4gICAgZXhwYW5kU2VsZWN0ZWQ6IHtcbiAgICAgIGhvdGtleTogXCJDb250cm9sK1NoaWZ0K1BsdXNcIixcbiAgICAgIGhhbmRsZXI6IChfLCB0cmVlKSA9PiBfX2FzeW5jKG51bGwsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IGNhbmNlbFRva2VuID0geyBjdXJyZW50OiBmYWxzZSB9O1xuICAgICAgICBjb25zdCBjYW5jZWxIYW5kbGVyID0gKGUpID0+IHtcbiAgICAgICAgICBpZiAoZS5jb2RlID09PSBcIkVzY2FwZVwiKSB7XG4gICAgICAgICAgICBjYW5jZWxUb2tlbi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGNhbmNlbEhhbmRsZXIpO1xuICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChcbiAgICAgICAgICB0cmVlLmdldFNlbGVjdGVkSXRlbXMoKS5tYXAoKGl0ZW0pID0+IGl0ZW0uZXhwYW5kQWxsKGNhbmNlbFRva2VuKSlcbiAgICAgICAgKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgY2FuY2VsSGFuZGxlcik7XG4gICAgICB9KVxuICAgIH0sXG4gICAgY29sbGFwc2VTZWxlY3RlZDoge1xuICAgICAgaG90a2V5OiBcIkNvbnRyb2wrU2hpZnQrTWludXNcIixcbiAgICAgIGhhbmRsZXI6IChfLCB0cmVlKSA9PiB7XG4gICAgICAgIHRyZWUuZ2V0U2VsZWN0ZWRJdGVtcygpLmZvckVhY2goKGl0ZW0pID0+IGl0ZW0uY29sbGFwc2VBbGwoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZmVhdHVyZXMvcHJvcC1tZW1vaXphdGlvbi9mZWF0dXJlLnRzXG52YXIgbWVtb2l6ZSA9IChwcm9wcywgbWVtb2l6ZWRQcm9wcykgPT4ge1xuICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgIGlmICh0eXBlb2YgcHJvcHNba2V5XSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBpZiAobWVtb2l6ZWRQcm9wcyAmJiBrZXkgaW4gbWVtb2l6ZWRQcm9wcykge1xuICAgICAgICBwcm9wc1trZXldID0gbWVtb2l6ZWRQcm9wc1trZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVtb2l6ZWRQcm9wc1trZXldID0gcHJvcHNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb3BzO1xufTtcbnZhciBwcm9wTWVtb2l6YXRpb25GZWF0dXJlID0ge1xuICBrZXk6IFwicHJvcC1tZW1vaXphdGlvblwiLFxuICBvdmVyd3JpdGVzOiBbXG4gICAgXCJtYWluXCIsXG4gICAgXCJhc3luYy1kYXRhLWxvYWRlclwiLFxuICAgIFwic3luYy1kYXRhLWxvYWRlclwiLFxuICAgIFwiZHJhZy1hbmQtZHJvcFwiLFxuICAgIFwiZXhwYW5kLWFsbFwiLFxuICAgIFwiaG90a2V5cy1jb3JlXCIsXG4gICAgXCJyZW5hbWluZ1wiLFxuICAgIFwic2VhcmNoXCIsXG4gICAgXCJzZWxlY3Rpb25cIlxuICBdLFxuICB0cmVlSW5zdGFuY2U6IHtcbiAgICBnZXRDb250YWluZXJQcm9wczogKHsgdHJlZSwgcHJldiB9LCB0cmVlTGFiZWwpID0+IHtcbiAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICBjb25zdCBkYXRhUmVmID0gdHJlZS5nZXREYXRhUmVmKCk7XG4gICAgICBjb25zdCBwcm9wcyA9IChfYSA9IHByZXYgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXYodHJlZUxhYmVsKSkgIT0gbnVsbCA/IF9hIDoge307XG4gICAgICAoX2MgPSAoX2IgPSBkYXRhUmVmLmN1cnJlbnQpLm1lbW8pICE9IG51bGwgPyBfYyA6IF9iLm1lbW8gPSB7fTtcbiAgICAgIChfZSA9IChfZCA9IGRhdGFSZWYuY3VycmVudC5tZW1vKS50cmVlKSAhPSBudWxsID8gX2UgOiBfZC50cmVlID0ge307XG4gICAgICByZXR1cm4gbWVtb2l6ZShwcm9wcywgZGF0YVJlZi5jdXJyZW50Lm1lbW8udHJlZSk7XG4gICAgfSxcbiAgICBnZXRTZWFyY2hJbnB1dEVsZW1lbnRQcm9wczogKHsgdHJlZSwgcHJldiB9KSA9PiB7XG4gICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgY29uc3QgZGF0YVJlZiA9IHRyZWUuZ2V0RGF0YVJlZigpO1xuICAgICAgY29uc3QgcHJvcHMgPSAoX2EgPSBwcmV2ID09IG51bGwgPyB2b2lkIDAgOiBwcmV2KCkpICE9IG51bGwgPyBfYSA6IHt9O1xuICAgICAgKF9jID0gKF9iID0gZGF0YVJlZi5jdXJyZW50KS5tZW1vKSAhPSBudWxsID8gX2MgOiBfYi5tZW1vID0ge307XG4gICAgICAoX2UgPSAoX2QgPSBkYXRhUmVmLmN1cnJlbnQubWVtbykuc2VhcmNoKSAhPSBudWxsID8gX2UgOiBfZC5zZWFyY2ggPSB7fTtcbiAgICAgIHJldHVybiBtZW1vaXplKHByb3BzLCBkYXRhUmVmLmN1cnJlbnQubWVtby5zZWFyY2gpO1xuICAgIH1cbiAgfSxcbiAgaXRlbUluc3RhbmNlOiB7XG4gICAgZ2V0UHJvcHM6ICh7IGl0ZW0sIHByZXYgfSkgPT4ge1xuICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgIGNvbnN0IGRhdGFSZWYgPSBpdGVtLmdldERhdGFSZWYoKTtcbiAgICAgIGNvbnN0IHByb3BzID0gKF9hID0gcHJldiA9PSBudWxsID8gdm9pZCAwIDogcHJldigpKSAhPSBudWxsID8gX2EgOiB7fTtcbiAgICAgIChfYyA9IChfYiA9IGRhdGFSZWYuY3VycmVudCkubWVtbykgIT0gbnVsbCA/IF9jIDogX2IubWVtbyA9IHt9O1xuICAgICAgKF9lID0gKF9kID0gZGF0YVJlZi5jdXJyZW50Lm1lbW8pLml0ZW0pICE9IG51bGwgPyBfZSA6IF9kLml0ZW0gPSB7fTtcbiAgICAgIHJldHVybiBtZW1vaXplKHByb3BzLCBkYXRhUmVmLmN1cnJlbnQubWVtby5pdGVtKTtcbiAgICB9LFxuICAgIGdldFJlbmFtZUlucHV0UHJvcHM6ICh7IGl0ZW0sIHByZXYgfSkgPT4ge1xuICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgIGNvbnN0IGRhdGFSZWYgPSBpdGVtLmdldERhdGFSZWYoKTtcbiAgICAgIGNvbnN0IHByb3BzID0gKF9hID0gcHJldiA9PSBudWxsID8gdm9pZCAwIDogcHJldigpKSAhPSBudWxsID8gX2EgOiB7fTtcbiAgICAgIChfYyA9IChfYiA9IGRhdGFSZWYuY3VycmVudCkubWVtbykgIT0gbnVsbCA/IF9jIDogX2IubWVtbyA9IHt9O1xuICAgICAgKF9lID0gKF9kID0gZGF0YVJlZi5jdXJyZW50Lm1lbW8pLnJlbmFtZSkgIT0gbnVsbCA/IF9lIDogX2QucmVuYW1lID0ge307XG4gICAgICByZXR1cm4gbWVtb2l6ZShwcm9wcywgZGF0YVJlZi5jdXJyZW50Lm1lbW8ucmVuYW1lKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy91dGlsaXRpZXMvcmVtb3ZlLWl0ZW1zLWZyb20tcGFyZW50cy50c1xudmFyIHJlbW92ZUl0ZW1zRnJvbVBhcmVudHMgPSAobW92ZWRJdGVtcywgb25DaGFuZ2VDaGlsZHJlbikgPT4gX19hc3luYyhudWxsLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICBjb25zdCBtb3ZlZEl0ZW1zSWRzID0gbW92ZWRJdGVtcy5tYXAoKGl0ZW0pID0+IGl0ZW0uZ2V0SWQoKSk7XG4gIGNvbnN0IHVuaXF1ZVBhcmVudHMgPSBbXG4gICAgLi4ubmV3IFNldChtb3ZlZEl0ZW1zLm1hcCgoaXRlbSkgPT4gaXRlbS5nZXRQYXJlbnQoKSkpXG4gIF07XG4gIGZvciAoY29uc3QgcGFyZW50IG9mIHVuaXF1ZVBhcmVudHMpIHtcbiAgICBjb25zdCBzaWJsaW5ncyA9IHBhcmVudCA9PSBudWxsID8gdm9pZCAwIDogcGFyZW50LmdldENoaWxkcmVuKCk7XG4gICAgaWYgKHNpYmxpbmdzICYmIHBhcmVudCkge1xuICAgICAgY29uc3QgbmV3Q2hpbGRyZW4gPSBzaWJsaW5ncy5maWx0ZXIoKHNpYmxpbmcpID0+ICFtb3ZlZEl0ZW1zSWRzLmluY2x1ZGVzKHNpYmxpbmcuZ2V0SWQoKSkpLm1hcCgoaSkgPT4gaS5nZXRJZCgpKTtcbiAgICAgIHlpZWxkIG9uQ2hhbmdlQ2hpbGRyZW4ocGFyZW50LCBuZXdDaGlsZHJlbik7XG4gICAgICBpZiAocGFyZW50ICYmIFwidXBkYXRlQ2FjaGVkQ2hpbGRyZW5JZHNcIiBpbiBwYXJlbnQpIHtcbiAgICAgICAgcGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwYXJlbnQudXBkYXRlQ2FjaGVkQ2hpbGRyZW5JZHMobmV3Q2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBtb3ZlZEl0ZW1zWzBdLmdldFRyZWUoKS5yZWJ1aWxkVHJlZSgpO1xufSk7XG5cbi8vIHNyYy91dGlsaXRpZXMvaW5zZXJ0LWl0ZW1zLWF0LXRhcmdldC50c1xudmFyIGluc2VydEl0ZW1zQXRUYXJnZXQgPSAoaXRlbUlkcywgdGFyZ2V0LCBvbkNoYW5nZUNoaWxkcmVuKSA9PiBfX2FzeW5jKG51bGwsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gIHlpZWxkIHRhcmdldC5pdGVtLmdldFRyZWUoKS53YWl0Rm9ySXRlbUNoaWxkcmVuTG9hZGVkKHRhcmdldC5pdGVtLmdldElkKCkpO1xuICBjb25zdCBvbGRDaGlsZHJlbklkcyA9IHRhcmdldC5pdGVtLmdldFRyZWUoKS5yZXRyaWV2ZUNoaWxkcmVuSWRzKHRhcmdldC5pdGVtLmdldElkKCkpO1xuICBpZiAoIShcImNoaWxkSW5kZXhcIiBpbiB0YXJnZXQpKSB7XG4gICAgY29uc3QgbmV3Q2hpbGRyZW4yID0gWy4uLm9sZENoaWxkcmVuSWRzLCAuLi5pdGVtSWRzXTtcbiAgICB5aWVsZCBvbkNoYW5nZUNoaWxkcmVuKHRhcmdldC5pdGVtLCBuZXdDaGlsZHJlbjIpO1xuICAgIGlmICh0YXJnZXQuaXRlbSAmJiBcInVwZGF0ZUNhY2hlZENoaWxkcmVuSWRzXCIgaW4gdGFyZ2V0Lml0ZW0pIHtcbiAgICAgIHRhcmdldC5pdGVtLnVwZGF0ZUNhY2hlZENoaWxkcmVuSWRzKG5ld0NoaWxkcmVuMik7XG4gICAgfVxuICAgIHRhcmdldC5pdGVtLmdldFRyZWUoKS5yZWJ1aWxkVHJlZSgpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBuZXdDaGlsZHJlbiA9IFtcbiAgICAuLi5vbGRDaGlsZHJlbklkcy5zbGljZSgwLCB0YXJnZXQuaW5zZXJ0aW9uSW5kZXgpLFxuICAgIC4uLml0ZW1JZHMsXG4gICAgLi4ub2xkQ2hpbGRyZW5JZHMuc2xpY2UodGFyZ2V0Lmluc2VydGlvbkluZGV4KVxuICBdO1xuICB5aWVsZCBvbkNoYW5nZUNoaWxkcmVuKHRhcmdldC5pdGVtLCBuZXdDaGlsZHJlbik7XG4gIGlmICh0YXJnZXQuaXRlbSAmJiBcInVwZGF0ZUNhY2hlZENoaWxkcmVuSWRzXCIgaW4gdGFyZ2V0Lml0ZW0pIHtcbiAgICB0YXJnZXQuaXRlbS51cGRhdGVDYWNoZWRDaGlsZHJlbklkcyhuZXdDaGlsZHJlbik7XG4gIH1cbiAgdGFyZ2V0Lml0ZW0uZ2V0VHJlZSgpLnJlYnVpbGRUcmVlKCk7XG59KTtcblxuLy8gc3JjL3V0aWxpdGllcy9jcmVhdGUtb24tZHJvcC1oYW5kbGVyLnRzXG52YXIgY3JlYXRlT25Ecm9wSGFuZGxlciA9IChvbkNoYW5nZUNoaWxkcmVuKSA9PiAoaXRlbXMsIHRhcmdldCkgPT4gX19hc3luYyhudWxsLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICBjb25zdCBpdGVtSWRzID0gaXRlbXMubWFwKChpdGVtKSA9PiBpdGVtLmdldElkKCkpO1xuICB5aWVsZCByZW1vdmVJdGVtc0Zyb21QYXJlbnRzKGl0ZW1zLCBvbkNoYW5nZUNoaWxkcmVuKTtcbiAgeWllbGQgaW5zZXJ0SXRlbXNBdFRhcmdldChpdGVtSWRzLCB0YXJnZXQsIG9uQ2hhbmdlQ2hpbGRyZW4pO1xufSk7XG5cbi8vIHNyYy9jb3JlL2J1aWxkLXByb3hpZmllZC1pbnN0YW5jZS50c1xudmFyIG5vb3AgPSAoKSA9PiB7XG59O1xudmFyIGZpbmRQcmV2SW5zdGFuY2VNZXRob2QgPSAoZmVhdHVyZXMsIGluc3RhbmNlVHlwZSwgbWV0aG9kS2V5LCBmZWF0dXJlU2VhcmNoSW5kZXgpID0+IHtcbiAgdmFyIF9hO1xuICBmb3IgKGxldCBpID0gZmVhdHVyZVNlYXJjaEluZGV4OyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IGZlYXR1cmUgPSBmZWF0dXJlc1tpXTtcbiAgICBjb25zdCBpdGVtSW5zdGFuY2VNZXRob2QgPSAoX2EgPSBmZWF0dXJlW2luc3RhbmNlVHlwZV0pID09IG51bGwgPyB2b2lkIDAgOiBfYVttZXRob2RLZXldO1xuICAgIGlmIChpdGVtSW5zdGFuY2VNZXRob2QpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG52YXIgaW52b2tlSW5zdGFuY2VNZXRob2QgPSAoZmVhdHVyZXMsIGluc3RhbmNlVHlwZSwgb3B0cywgbWV0aG9kS2V5LCBmZWF0dXJlSW5kZXgsIGFyZ3MpID0+IHtcbiAgdmFyIF9hO1xuICBjb25zdCBwcmV2SW5kZXggPSBmaW5kUHJldkluc3RhbmNlTWV0aG9kKFxuICAgIGZlYXR1cmVzLFxuICAgIGluc3RhbmNlVHlwZSxcbiAgICBtZXRob2RLZXksXG4gICAgZmVhdHVyZUluZGV4IC0gMVxuICApO1xuICBjb25zdCBpdGVtSW5zdGFuY2VNZXRob2QgPSAoX2EgPSBmZWF0dXJlc1tmZWF0dXJlSW5kZXhdW2luc3RhbmNlVHlwZV0pID09IG51bGwgPyB2b2lkIDAgOiBfYVttZXRob2RLZXldO1xuICByZXR1cm4gaXRlbUluc3RhbmNlTWV0aG9kKFxuICAgIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdHMpLCB7XG4gICAgICBwcmV2OiBwcmV2SW5kZXggIT09IG51bGwgPyAoLi4ubmV3QXJncykgPT4gaW52b2tlSW5zdGFuY2VNZXRob2QoXG4gICAgICAgIGZlYXR1cmVzLFxuICAgICAgICBpbnN0YW5jZVR5cGUsXG4gICAgICAgIG9wdHMsXG4gICAgICAgIG1ldGhvZEtleSxcbiAgICAgICAgcHJldkluZGV4LFxuICAgICAgICBuZXdBcmdzXG4gICAgICApIDogbnVsbFxuICAgIH0pLFxuICAgIC4uLmFyZ3NcbiAgKTtcbn07XG52YXIgYnVpbGRQcm94aWVkSW5zdGFuY2UgPSAoZmVhdHVyZXMsIGluc3RhbmNlVHlwZSwgYnVpbGRPcHRzKSA9PiB7XG4gIGNvbnN0IG9wdHMgPSB7fTtcbiAgY29uc3QgaXRlbSA9IG5ldyBQcm94eShcbiAgICB7fSxcbiAgICB7XG4gICAgICBoYXModGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleSA9PT0gXCJ0b0pTT05cIikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNJbnN0YW5jZU1ldGhvZCA9IGZpbmRQcmV2SW5zdGFuY2VNZXRob2QoXG4gICAgICAgICAgZmVhdHVyZXMsXG4gICAgICAgICAgaW5zdGFuY2VUeXBlLFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICBmZWF0dXJlcy5sZW5ndGggLSAxXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBCb29sZWFuKGhhc0luc3RhbmNlTWV0aG9kKTtcbiAgICAgIH0sXG4gICAgICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgPT09IFwidG9KU09OXCIpIHtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgY29uc3QgZmVhdHVyZUluZGV4ID0gZmluZFByZXZJbnN0YW5jZU1ldGhvZChcbiAgICAgICAgICAgIGZlYXR1cmVzLFxuICAgICAgICAgICAgaW5zdGFuY2VUeXBlLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZmVhdHVyZXMubGVuZ3RoIC0gMVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGZlYXR1cmVJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgdGhyb3dFcnJvcihgZmVhdHVyZSBtaXNzaW5nIGZvciBtZXRob2QgJHtrZXl9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpbnZva2VJbnN0YW5jZU1ldGhvZChcbiAgICAgICAgICAgIGZlYXR1cmVzLFxuICAgICAgICAgICAgaW5zdGFuY2VUeXBlLFxuICAgICAgICAgICAgb3B0cyxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGZlYXR1cmVJbmRleCxcbiAgICAgICAgICAgIGFyZ3NcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgKTtcbiAgT2JqZWN0LmFzc2lnbihvcHRzLCBidWlsZE9wdHMoaXRlbSkpO1xuICByZXR1cm4gW2l0ZW0sIG5vb3BdO1xufTtcbmV4cG9ydCB7XG4gIEFzc2lzdGl2ZURuZFN0YXRlLFxuICBDaGVja2VkU3RhdGUsXG4gIERyYWdUYXJnZXRQb3NpdGlvbixcbiAgYXN5bmNEYXRhTG9hZGVyRmVhdHVyZSxcbiAgYnVpbGRQcm94aWVkSW5zdGFuY2UsXG4gIGJ1aWxkU3RhdGljSW5zdGFuY2UsXG4gIGNoZWNrYm94ZXNGZWF0dXJlLFxuICBjcmVhdGVPbkRyb3BIYW5kbGVyLFxuICBjcmVhdGVUcmVlLFxuICBkcmFnQW5kRHJvcEZlYXR1cmUsXG4gIGV4cGFuZEFsbEZlYXR1cmUsXG4gIGhvdGtleXNDb3JlRmVhdHVyZSxcbiAgaW5zZXJ0SXRlbXNBdFRhcmdldCxcbiAgaXNPcmRlcmVkRHJhZ1RhcmdldCxcbiAga2V5Ym9hcmREcmFnQW5kRHJvcEZlYXR1cmUsXG4gIG1ha2VTdGF0ZVVwZGF0ZXIsXG4gIHByb3BNZW1vaXphdGlvbkZlYXR1cmUsXG4gIHJlbW92ZUl0ZW1zRnJvbVBhcmVudHMsXG4gIHJlbmFtaW5nRmVhdHVyZSxcbiAgc2VhcmNoRmVhdHVyZSxcbiAgc2VsZWN0aW9uRmVhdHVyZSxcbiAgc3luY0RhdGFMb2FkZXJGZWF0dXJlXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@headless-tree/core/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@headless-tree/react/dist/chunk-FWCSY2DS.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@headless-tree/react/dist/chunk-FWCSY2DS.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __objRest: () => (/* binding */ __objRest),\n/* harmony export */   __spreadProps: () => (/* binding */ __spreadProps),\n/* harmony export */   __spreadValues: () => (/* binding */ __spreadValues)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGhlYWRsZXNzLXRyZWUvcmVhY3QvZGlzdC9jaHVuay1GV0NTWTJEUy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFNRSIsInNvdXJjZXMiOlsiL1VzZXJzL3RlcmVjYWwvdWktaW50ZXJhY2l0dmUtbGV2MS9teS1hZG1pbi1wcm9qZWN0L3VpLWV4YW1wbGUtZnJvbnQvbm9kZV9tb2R1bGVzL0BoZWFkbGVzcy10cmVlL3JlYWN0L2Rpc3QvY2h1bmstRldDU1kyRFMubWpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xudmFyIF9fb2JqUmVzdCA9IChzb3VyY2UsIGV4Y2x1ZGUpID0+IHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoc291cmNlLCBwcm9wKSAmJiBleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwKVxuICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICBpZiAoc291cmNlICE9IG51bGwgJiYgX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoc291cmNlKSkge1xuICAgICAgaWYgKGV4Y2x1ZGUuaW5kZXhPZihwcm9wKSA8IDAgJiYgX19wcm9wSXNFbnVtLmNhbGwoc291cmNlLCBwcm9wKSlcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbmV4cG9ydCB7XG4gIF9fc3ByZWFkVmFsdWVzLFxuICBfX3NwcmVhZFByb3BzLFxuICBfX29ialJlc3Rcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@headless-tree/react/dist/chunk-FWCSY2DS.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@headless-tree/react/dist/index.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@headless-tree/react/dist/index.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AssistiveTreeDescription: () => (/* binding */ AssistiveTreeDescription),\n/* harmony export */   useTree: () => (/* binding */ useTree)\n/* harmony export */ });\n/* harmony import */ var _chunk_FWCSY2DS_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-FWCSY2DS.mjs */ \"(ssr)/./node_modules/@headless-tree/react/dist/chunk-FWCSY2DS.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _headless_tree_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @headless-tree/core */ \"(ssr)/./node_modules/@headless-tree/core/dist/index.mjs\");\n\n\n// src/assistive-tree-description.tsx\n\n\nvar styles = {\n  position: \"absolute\",\n  margin: \"-1px\",\n  width: \"1px\",\n  height: \"1px\",\n  overflow: \"hidden\",\n  clip: \"rect(0 0 0 0)\"\n};\nvar getDefaultLabel = (dnd, assistiveState, hotkeys) => {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n  if (!hotkeys.startDrag) return \"\";\n  const itemNames = (_b = (_a = dnd == null ? void 0 : dnd.draggedItems) == null ? void 0 : _a.map((item) => item.getItemName()).join(\", \")) != null ? _b : \"\";\n  const position = !(dnd == null ? void 0 : dnd.dragTarget) ? \"None\" : \"childIndex\" in dnd.dragTarget ? `${dnd.dragTarget.childIndex} of ${dnd.dragTarget.item.getChildren().length} in ${dnd.dragTarget.item.getItemName()}` : `in ${dnd.dragTarget.item.getItemName()}`;\n  const navGuide = `Press ${(_c = hotkeys.dragUp) == null ? void 0 : _c.hotkey} and ${(_d = hotkeys.dragDown) == null ? void 0 : _d.hotkey} to move up or down, ${(_e = hotkeys.completeDrag) == null ? void 0 : _e.hotkey} to drop, ${(_f = hotkeys.cancelDrag) == null ? void 0 : _f.hotkey} to abort.`;\n  switch (assistiveState) {\n    case _headless_tree_core__WEBPACK_IMPORTED_MODULE_1__.AssistiveDndState.Started:\n      return itemNames ? `Dragging ${itemNames}. Current position: ${position}. ${navGuide}` : `Current position: ${position}. ${navGuide}`;\n    case _headless_tree_core__WEBPACK_IMPORTED_MODULE_1__.AssistiveDndState.Dragging:\n      return itemNames ? `${itemNames}, ${position}` : position;\n    case _headless_tree_core__WEBPACK_IMPORTED_MODULE_1__.AssistiveDndState.Completed:\n      return `Drag completed. Press ${(_g = hotkeys.startDrag) == null ? void 0 : _g.hotkey} to move selected items`;\n    case _headless_tree_core__WEBPACK_IMPORTED_MODULE_1__.AssistiveDndState.Aborted:\n      return `Drag cancelled. Press ${(_h = hotkeys.startDrag) == null ? void 0 : _h.hotkey} to move selected items`;\n    case _headless_tree_core__WEBPACK_IMPORTED_MODULE_1__.AssistiveDndState.None:\n    default:\n      return `Press ${(_i = hotkeys.startDrag) == null ? void 0 : _i.hotkey} to move selected items`;\n  }\n};\nvar AssistiveTreeDescription = (_a) => {\n  var _b = _a, {\n    tree,\n    getLabel = getDefaultLabel\n  } = _b, props = (0,_chunk_FWCSY2DS_mjs__WEBPACK_IMPORTED_MODULE_2__.__objRest)(_b, [\n    \"tree\",\n    \"getLabel\"\n  ]);\n  var _a2;\n  const state = tree.getState();\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    \"span\",\n    (0,_chunk_FWCSY2DS_mjs__WEBPACK_IMPORTED_MODULE_2__.__spreadProps)((0,_chunk_FWCSY2DS_mjs__WEBPACK_IMPORTED_MODULE_2__.__spreadValues)({\n      \"aria-live\": \"assertive\"\n    }, props), {\n      style: (0,_chunk_FWCSY2DS_mjs__WEBPACK_IMPORTED_MODULE_2__.__spreadValues)((0,_chunk_FWCSY2DS_mjs__WEBPACK_IMPORTED_MODULE_2__.__spreadValues)({}, styles), props.style)\n    }),\n    getLabel(\n      state.dnd,\n      (_a2 = state.assistiveDndState) != null ? _a2 : _headless_tree_core__WEBPACK_IMPORTED_MODULE_1__.AssistiveDndState.None,\n      tree.getHotkeyPresets()\n    )\n  );\n};\n\n// src/use-tree.tsx\n\n\nvar useApplyAfterMount = () => {\n  const isMounted = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  const callbacks = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    isMounted.current = true;\n    callbacks.current.forEach((callback) => callback());\n  }, []);\n  const apply = (callback) => {\n    if (isMounted.current) {\n      callback();\n    } else {\n      callbacks.current.push(callback);\n    }\n  };\n  return apply;\n};\nvar useTree = (config) => {\n  const apply = useApplyAfterMount();\n  const [tree] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => ({ current: (0,_headless_tree_core__WEBPACK_IMPORTED_MODULE_1__.createTree)(config) }));\n  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n    () => tree.current.getState()\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    tree.current.rebuildTree();\n  }, [tree]);\n  tree.current.setConfig((prev) => (0,_chunk_FWCSY2DS_mjs__WEBPACK_IMPORTED_MODULE_2__.__spreadProps)((0,_chunk_FWCSY2DS_mjs__WEBPACK_IMPORTED_MODULE_2__.__spreadValues)((0,_chunk_FWCSY2DS_mjs__WEBPACK_IMPORTED_MODULE_2__.__spreadValues)({}, prev), config), {\n    state: (0,_chunk_FWCSY2DS_mjs__WEBPACK_IMPORTED_MODULE_2__.__spreadValues)((0,_chunk_FWCSY2DS_mjs__WEBPACK_IMPORTED_MODULE_2__.__spreadValues)({}, state), config.state),\n    setState: (state2) => {\n      apply(() => {\n        var _a;\n        setState(state2);\n        (_a = config.setState) == null ? void 0 : _a.call(config, state2);\n      });\n    }\n  }));\n  return tree.current;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGhlYWRsZXNzLXRyZWUvcmVhY3QvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFJOEI7O0FBRTlCO0FBQzBCO0FBR0c7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHLDJCQUEyQixLQUFLLDBDQUEwQyxLQUFLLGtDQUFrQyxVQUFVLGtDQUFrQztBQUN4USw0QkFBNEIsb0RBQW9ELE1BQU0sc0RBQXNELHNCQUFzQiwwREFBMEQsV0FBVyx3REFBd0Q7QUFDL1I7QUFDQSxTQUFTLGtFQUFpQjtBQUMxQixxQ0FBcUMsVUFBVSxzQkFBc0IsU0FBUyxJQUFJLFNBQVMseUJBQXlCLFNBQVMsSUFBSSxTQUFTO0FBQzFJLFNBQVMsa0VBQWlCO0FBQzFCLDRCQUE0QixVQUFVLElBQUksU0FBUztBQUNuRCxTQUFTLGtFQUFpQjtBQUMxQixzQ0FBc0MsdURBQXVEO0FBQzdGLFNBQVMsa0VBQWlCO0FBQzFCLHNDQUFzQyx1REFBdUQ7QUFDN0YsU0FBUyxrRUFBaUI7QUFDMUI7QUFDQSxzQkFBc0IsdURBQXVEO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksY0FBYyw4REFBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdEQUFtQjtBQUM1QztBQUNBLElBQUksa0VBQWEsQ0FBQyxtRUFBYztBQUNoQztBQUNBLEtBQUs7QUFDTCxhQUFhLG1FQUFjLENBQUMsbUVBQWMsR0FBRztBQUM3QyxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNEQUFzRCxrRUFBaUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDb0Q7QUFDSDtBQUNqRDtBQUNBLG9CQUFvQiw2Q0FBTTtBQUMxQixvQkFBb0IsNkNBQU07QUFDMUIsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLCtDQUFRLFVBQVUsU0FBUywrREFBVSxVQUFVO0FBQ2hFLDRCQUE0QiwrQ0FBUTtBQUNwQztBQUNBO0FBQ0EsRUFBRSxnREFBUztBQUNYO0FBQ0EsR0FBRztBQUNILG1DQUFtQyxrRUFBYSxDQUFDLG1FQUFjLENBQUMsbUVBQWMsR0FBRztBQUNqRixXQUFXLG1FQUFjLENBQUMsbUVBQWMsR0FBRztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFJRSIsInNvdXJjZXMiOlsiL1VzZXJzL3RlcmVjYWwvdWktaW50ZXJhY2l0dmUtbGV2MS9teS1hZG1pbi1wcm9qZWN0L3VpLWV4YW1wbGUtZnJvbnQvbm9kZV9tb2R1bGVzL0BoZWFkbGVzcy10cmVlL3JlYWN0L2Rpc3QvaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIF9fb2JqUmVzdCxcbiAgX19zcHJlYWRQcm9wcyxcbiAgX19zcHJlYWRWYWx1ZXNcbn0gZnJvbSBcIi4vY2h1bmstRldDU1kyRFMubWpzXCI7XG5cbi8vIHNyYy9hc3Npc3RpdmUtdHJlZS1kZXNjcmlwdGlvbi50c3hcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7XG4gIEFzc2lzdGl2ZURuZFN0YXRlXG59IGZyb20gXCJAaGVhZGxlc3MtdHJlZS9jb3JlXCI7XG52YXIgc3R5bGVzID0ge1xuICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICBtYXJnaW46IFwiLTFweFwiLFxuICB3aWR0aDogXCIxcHhcIixcbiAgaGVpZ2h0OiBcIjFweFwiLFxuICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgY2xpcDogXCJyZWN0KDAgMCAwIDApXCJcbn07XG52YXIgZ2V0RGVmYXVsdExhYmVsID0gKGRuZCwgYXNzaXN0aXZlU3RhdGUsIGhvdGtleXMpID0+IHtcbiAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2k7XG4gIGlmICghaG90a2V5cy5zdGFydERyYWcpIHJldHVybiBcIlwiO1xuICBjb25zdCBpdGVtTmFtZXMgPSAoX2IgPSAoX2EgPSBkbmQgPT0gbnVsbCA/IHZvaWQgMCA6IGRuZC5kcmFnZ2VkSXRlbXMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5tYXAoKGl0ZW0pID0+IGl0ZW0uZ2V0SXRlbU5hbWUoKSkuam9pbihcIiwgXCIpKSAhPSBudWxsID8gX2IgOiBcIlwiO1xuICBjb25zdCBwb3NpdGlvbiA9ICEoZG5kID09IG51bGwgPyB2b2lkIDAgOiBkbmQuZHJhZ1RhcmdldCkgPyBcIk5vbmVcIiA6IFwiY2hpbGRJbmRleFwiIGluIGRuZC5kcmFnVGFyZ2V0ID8gYCR7ZG5kLmRyYWdUYXJnZXQuY2hpbGRJbmRleH0gb2YgJHtkbmQuZHJhZ1RhcmdldC5pdGVtLmdldENoaWxkcmVuKCkubGVuZ3RofSBpbiAke2RuZC5kcmFnVGFyZ2V0Lml0ZW0uZ2V0SXRlbU5hbWUoKX1gIDogYGluICR7ZG5kLmRyYWdUYXJnZXQuaXRlbS5nZXRJdGVtTmFtZSgpfWA7XG4gIGNvbnN0IG5hdkd1aWRlID0gYFByZXNzICR7KF9jID0gaG90a2V5cy5kcmFnVXApID09IG51bGwgPyB2b2lkIDAgOiBfYy5ob3RrZXl9IGFuZCAkeyhfZCA9IGhvdGtleXMuZHJhZ0Rvd24pID09IG51bGwgPyB2b2lkIDAgOiBfZC5ob3RrZXl9IHRvIG1vdmUgdXAgb3IgZG93biwgJHsoX2UgPSBob3RrZXlzLmNvbXBsZXRlRHJhZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLmhvdGtleX0gdG8gZHJvcCwgJHsoX2YgPSBob3RrZXlzLmNhbmNlbERyYWcpID09IG51bGwgPyB2b2lkIDAgOiBfZi5ob3RrZXl9IHRvIGFib3J0LmA7XG4gIHN3aXRjaCAoYXNzaXN0aXZlU3RhdGUpIHtcbiAgICBjYXNlIEFzc2lzdGl2ZURuZFN0YXRlLlN0YXJ0ZWQ6XG4gICAgICByZXR1cm4gaXRlbU5hbWVzID8gYERyYWdnaW5nICR7aXRlbU5hbWVzfS4gQ3VycmVudCBwb3NpdGlvbjogJHtwb3NpdGlvbn0uICR7bmF2R3VpZGV9YCA6IGBDdXJyZW50IHBvc2l0aW9uOiAke3Bvc2l0aW9ufS4gJHtuYXZHdWlkZX1gO1xuICAgIGNhc2UgQXNzaXN0aXZlRG5kU3RhdGUuRHJhZ2dpbmc6XG4gICAgICByZXR1cm4gaXRlbU5hbWVzID8gYCR7aXRlbU5hbWVzfSwgJHtwb3NpdGlvbn1gIDogcG9zaXRpb247XG4gICAgY2FzZSBBc3Npc3RpdmVEbmRTdGF0ZS5Db21wbGV0ZWQ6XG4gICAgICByZXR1cm4gYERyYWcgY29tcGxldGVkLiBQcmVzcyAkeyhfZyA9IGhvdGtleXMuc3RhcnREcmFnKSA9PSBudWxsID8gdm9pZCAwIDogX2cuaG90a2V5fSB0byBtb3ZlIHNlbGVjdGVkIGl0ZW1zYDtcbiAgICBjYXNlIEFzc2lzdGl2ZURuZFN0YXRlLkFib3J0ZWQ6XG4gICAgICByZXR1cm4gYERyYWcgY2FuY2VsbGVkLiBQcmVzcyAkeyhfaCA9IGhvdGtleXMuc3RhcnREcmFnKSA9PSBudWxsID8gdm9pZCAwIDogX2guaG90a2V5fSB0byBtb3ZlIHNlbGVjdGVkIGl0ZW1zYDtcbiAgICBjYXNlIEFzc2lzdGl2ZURuZFN0YXRlLk5vbmU6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBgUHJlc3MgJHsoX2kgPSBob3RrZXlzLnN0YXJ0RHJhZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9pLmhvdGtleX0gdG8gbW92ZSBzZWxlY3RlZCBpdGVtc2A7XG4gIH1cbn07XG52YXIgQXNzaXN0aXZlVHJlZURlc2NyaXB0aW9uID0gKF9hKSA9PiB7XG4gIHZhciBfYiA9IF9hLCB7XG4gICAgdHJlZSxcbiAgICBnZXRMYWJlbCA9IGdldERlZmF1bHRMYWJlbFxuICB9ID0gX2IsIHByb3BzID0gX19vYmpSZXN0KF9iLCBbXG4gICAgXCJ0cmVlXCIsXG4gICAgXCJnZXRMYWJlbFwiXG4gIF0pO1xuICB2YXIgX2EyO1xuICBjb25zdCBzdGF0ZSA9IHRyZWUuZ2V0U3RhdGUoKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIFwic3BhblwiLFxuICAgIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgXCJhcmlhLWxpdmVcIjogXCJhc3NlcnRpdmVcIlxuICAgIH0sIHByb3BzKSwge1xuICAgICAgc3R5bGU6IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBzdHlsZXMpLCBwcm9wcy5zdHlsZSlcbiAgICB9KSxcbiAgICBnZXRMYWJlbChcbiAgICAgIHN0YXRlLmRuZCxcbiAgICAgIChfYTIgPSBzdGF0ZS5hc3Npc3RpdmVEbmRTdGF0ZSkgIT0gbnVsbCA/IF9hMiA6IEFzc2lzdGl2ZURuZFN0YXRlLk5vbmUsXG4gICAgICB0cmVlLmdldEhvdGtleVByZXNldHMoKVxuICAgIClcbiAgKTtcbn07XG5cbi8vIHNyYy91c2UtdHJlZS50c3hcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgY3JlYXRlVHJlZSB9IGZyb20gXCJAaGVhZGxlc3MtdHJlZS9jb3JlXCI7XG52YXIgdXNlQXBwbHlBZnRlck1vdW50ID0gKCkgPT4ge1xuICBjb25zdCBpc01vdW50ZWQgPSB1c2VSZWYoZmFsc2UpO1xuICBjb25zdCBjYWxsYmFja3MgPSB1c2VSZWYoW10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlzTW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICBjYWxsYmFja3MuY3VycmVudC5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soKSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgYXBwbHkgPSAoY2FsbGJhY2spID0+IHtcbiAgICBpZiAoaXNNb3VudGVkLmN1cnJlbnQpIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrcy5jdXJyZW50LnB1c2goY2FsbGJhY2spO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGFwcGx5O1xufTtcbnZhciB1c2VUcmVlID0gKGNvbmZpZykgPT4ge1xuICBjb25zdCBhcHBseSA9IHVzZUFwcGx5QWZ0ZXJNb3VudCgpO1xuICBjb25zdCBbdHJlZV0gPSB1c2VTdGF0ZSgoKSA9PiAoeyBjdXJyZW50OiBjcmVhdGVUcmVlKGNvbmZpZykgfSkpO1xuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlKFxuICAgICgpID0+IHRyZWUuY3VycmVudC5nZXRTdGF0ZSgpXG4gICk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdHJlZS5jdXJyZW50LnJlYnVpbGRUcmVlKCk7XG4gIH0sIFt0cmVlXSk7XG4gIHRyZWUuY3VycmVudC5zZXRDb25maWcoKHByZXYpID0+IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHByZXYpLCBjb25maWcpLCB7XG4gICAgc3RhdGU6IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBzdGF0ZSksIGNvbmZpZy5zdGF0ZSksXG4gICAgc2V0U3RhdGU6IChzdGF0ZTIpID0+IHtcbiAgICAgIGFwcGx5KCgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzZXRTdGF0ZShzdGF0ZTIpO1xuICAgICAgICAoX2EgPSBjb25maWcuc2V0U3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKGNvbmZpZywgc3RhdGUyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSkpO1xuICByZXR1cm4gdHJlZS5jdXJyZW50O1xufTtcbmV4cG9ydCB7XG4gIEFzc2lzdGl2ZVRyZWVEZXNjcmlwdGlvbixcbiAgdXNlVHJlZVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@headless-tree/react/dist/index.mjs\n");

/***/ })

};
;